# vim:filetype=sh
#
# Usage: remoteadmin [filter] [command ...]
# where filter is used as a simple search filter against all currently
# connected VMs. The user is prompted to pick the VM from a list and further
# prompted to run either ssh or sftp to that VM.
#
# If a command is given we assume it is to be run on the remote VM identified
# by the filter (and the assumption is that the filter will match on exactly 1
# VM).
#
# Programmer note: this script is designed to work on Linux, Cygwin, and Mac OS
# X. So do not use any obscure syntax or 3rd party tools which may not exist in
# some environments, e.g., Mac OS X's bash does not support associative arrays.
#
#exec > >(tee >(grep ^: >$cmds) | grep -v ^:)
#trap "rm -f $stdout $cmds; echo $stdout was deleted" EXIT INT

remoteadmin() {
  local exec ssh_params assume_ssh
  declare -a exec
  declare -a ssh_params
  local ssh_params_file=$HOME/.remoteadmin/ssh_options

  local filter="$1"
  shift
  if [ -z "$filter" ]; then
    filter="."
  fi

  if [ ${#@} -gt 0 ]; then
    assume_ssh=1
  else
    assume_ssh=0
  fi

  function get_extra_ssh_params() {
    local hostname=$(echo $1 | tr "[:upper:]" "[:lower:]")
    local hostname2
    local line
    if [ -f $ssh_params_file ]; then
      while read -r line; do
        if [[ $line =~ ^([-\.[:alnum:]]+)=(.+) ]]; then
          hostname2=$(echo ${BASH_REMATCH[1]} | tr "[:upper:]" "[:lower:]")
          if [ ${hostname} = ${hostname2} ]; then
            printf %s "${BASH_REMATCH[2]}"
            return
          fi
        fi
      done < $ssh_params_file
    fi
  }

  eval $(_esh_e)

  if [ -z "$RA_USER" ]; then
    read -p "What is your remoteadmin username? " RA_USER
    [ -z "$RA_USER" ] && return 1
    read -p "Confirm: username is \"$RA_USER\" (y/n, default is y)?" yesno
    [ "$yesno" -a "$yesno" != y ] && return
    _esh_e $ESH_STY RA_USER "$RA_USER"
  fi

  local pwkey="LincWare LDAP:$RA_USER"
  local pw=$(pw "$pwkey")
  [ -z "$pw" ] && {
    echo "Could not retrieve password for \"$RA_USER\" to launch remoteadmin" >&2
    return 1
  }
  local vmjson auth=$(printf "%s:%s" "$RA_USER" "$pw" | openssl enc -a -A)
  local auth_hdr=$(printf "Authorization: Basic %s" $auth)
  local endpoint=https://remoteadmin-dev.lincware.com/get-vms
  vmjson=$(curl -S -s -f -H "$auth_hdr" $endpoint)
  local rc=$?
  if [ $rc -gt 0 ]; then
    echo "Failed to read $endpoint"
    return 1
  fi
  #local matching_indices=$(jq -c "[.[] | .hostname | test(\".*$filter.*\";\"i\")] | indices(true)" <<<$vmjson)
  local matching_indices=$(node - "$vmjson" "$filter" << 'EOF'
var vms=JSON.parse(process.argv[2]);
var filter=new RegExp(process.argv[3],"i");
var matching=[];
vms.map(function(vm,idx) {
  if (vm.hostname.search(filter)>=0) {
    matching.push(idx);
  }
});
console.log(JSON.stringify(matching));
EOF
)
  if [ "$matching_indices" = "[]" ]; then
    echo "no matches for filter: $filter"
    return 1
  fi
  local vmjson_filtered=$(jq -c "[.$matching_indices]" <<<$vmjson)

  get_vm_data() {
    local key=$1
    jq -r -c ".[] | .$key" <<<$vmjson_filtered
  }

  local hostnames=($(get_vm_data hostname)) choice=0
  local n=$((${#hostnames[@]}-1))
  if [ $n -gt 1 ]; then
    local choice_list=$(
      echo "Pick:"
      for ((i=1; i<=$n; i++)); do
        printf "%s. %s\n" $i ${hostnames[$i]}
      done
    )
    if [ $(($n+2)) -gt $LINES ]; then
      less <<<"$choice_list"
    else
      echo "$choice_list"
    fi
    read -p "choose 0-$n: " choice
    if [ -z "$choice" ] || ! grep -q -w -- "$choice" <<<${!hostnames[@]}; then
      echo "invalid choice"
      return 1
    fi
  fi
  local ssh_ports=($(get_vm_data sshPort))
  local ssh_port=${ssh_ports[$choice]}
  local hostname=${hostnames[$choice]}
  local extra_params="$(get_extra_ssh_params $hostname)"
  if [ -n "$extra_params" ]; then
    echo "Passing extra params to ssh: $extra_params"
  fi
  SSH_STY_LBL=$hostname ssh -t -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -p $ssh_port $extra_params lincdoc@remoteadmin.lincware.com
}
