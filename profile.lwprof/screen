# vim:filetype=sh
screen() {
  # see if -r or -R was passed, if so just invoke screen with the current arg list "as is"
  local origArgs=("$@")
  # NOTE: cannot set OPTS in 1 line, it strips the return value from the subshell
  local OPTS
  # Note: escreen sends "--", that is why we skip it here
  if [ "$1" != -- ]; then
    for opt in "$@"; do
      case $opt in
        -r)
          local screen_exec=$(which screen) curr_sty=${STY:-some_value} choice i=0 sty tempfile
          local screen_stys=($($screen_exec -ls | grep -v $curr_sty | perl -n -e 's{^\s*(\d+\.\S+).*}{$1} && print'))
          if [ ${#screen_stys} = 0 ]; then
            echo "No screen sessions detected."
            return 1
          fi
          printf "Resume which screen session?\n"
          IFS='\n' $screen_exec -ls | grep -v $curr_sty | perl -n -e 's{^\s*(\d+\..*)}{$1} && print' | while read l; do
            printf "%s. %s\n" $i "$l"
            i=$(($i+1))
          done
          read -p "Enter choice: " choice
          if [ "$choice" -a ${screen_stys[$choice]+is_set} ]; then
            sty=${screen_stys[$choice]}
            #tempfile=$(mktemp)
            #rm $tempfile
            #mkfifo $tempfile
            # get the old value of ESH_PORT
            #$screen_exec -S $sty -X exec sh -c "echo \$ESH_PORT > $tempfile"
            # force new windows to use the new value of ESH_PORT
            #$screen_exec -S $sty -X setenv ESH_PORT $ESH_PORT
            eval $(_esh_e)
            _esh_e $sty ESH_PORT $ESH_PORT SSH_AUTH_SOCK $SSH_AUTH_SOCK
#read -p "ready to resume screen session:" ans
            #rm -f $tempfile
            # This attempt to use nc as a relay is definitely NOT working ...
            # wanted existing windows to relay from the old port to the new
            #$ESH_NC -l $old_ESH_PORT 0<$tempfile | $ESH_NC localhost $ESH_PORT | $tempfile &
            #local ncpid=$!
            $screen_exec -d -r $sty
            #kill $ncpid
            return
          else
            echo "Invalid choice."
            return 1
          fi
          ;;
        -d|-D|-R|-RR|-ls|-list|-Q|-v|-x|-X)
          env screen "$@"
          return $?
          ;;
      esac
    done
  fi
  local shell=$ESH_TMP/$USER.screen.shell
  touch $shell
  chmod 700 $shell
  # Create custom shell based on sh: call sh first so that original PS1 is
  # maintained. Update: on OSX, sh is just a thin wrapper to bash, and it
  # resets PS1. So, use perl instead.
  echo -n '#!/usr/bin/perl
#($ENV{ESH_STY})=$ENV{STY}=~m{^(\d+)}g;
#$ENV{ESH_STY}=$ENV{STY};
exec (qw(bash --norc --noprofile),@ARGV);
' > $shell
  local SCREENRC=$ESH_TMP/$USER.screenrc
  # Set up a little macro so that ^a% will dump the current screen to a file,
  # then edit it in vim.
  local printscreen_macro=$ESH_TMP/$USER.screenrc.printscreen
  local hardcopy_file=$ESH_TMP/$USER.screenrc.hardcopy
  touch $SCREENRC $printscreen_macro $hardcopy_file
  chmod 600 $SCREENRC $printscreen_macro $hardcopy_file
  cat > $SCREENRC << 'EOF'
startup_message off
bind " " windowlist -b
vbell on
vbell_msg DING
#shelltitle "$ |bash:"
bindkey "\032" stuff "\032"
caption always "%{= kw}%-w%{= BW}%n%t%{-}%+w %-= @%H %m/%d %c"
shelltitle "$ |:"
defmonitor on
msgwait 1
hardstatus ignore
# allow special screen user ":window:" to send keystrokes: used in ssh;
# man screen for some other details (used in combination with screen
# escape "ESC ] 83 ; cmd ^G")
#addacl :window: -rwx #?
#aclchg :window: +w+x stuff,sleep
EOF
  cat >> $SCREENRC << EOF
bind % source $printscreen_macro
EOF
  cat > $printscreen_macro << EOF
hardcopy_append off
hardcopy $hardcopy_file
screen bash -c "vim $hardcopy_file"
EOF

  [ "$ESH_SCREEN_EXEC" = 1 ] && {
    exec env SCREENRC=$SCREENRC screen -e^Aa -s $shell bash -c \
      '_esh_e $STY
      env screen -S $STY -X setenv ESH_STY $STY
      env screen -S $STY -X screen
      "$@"' "${origArgs[@]}"
  }
  #
  local c=$(declare -p PS1)
  c+=';_esh_e $STY'
  c+=';export ESH_STY=$STY'
  c+=';env screen -S $STY -X setenv ESH_STY $STY'
  c+=';exec env bash --norc --noprofile'
  env SCREENRC=$SCREENRC screen -e^Ee -s $shell bash -c "$c"
}
