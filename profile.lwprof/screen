# vim:filetype=sh
screen() {
  # make copy of original function args
  local args=("$@")
  # NOTE: cannot set OPTS in 1 line, it strips the return value from the subshell
  local OPTS
  # Note: escreen sends "--", that is why we skip it here
  if [ "$1" != -- ]; then
    for opt in "$@"; do
      case $opt in
        -r)
          local curr_sty=${STY:-some_value} choice i=0 sty
          local screen_stys=($(env screen -ls | grep -v $curr_sty | perl -n -e 's{^\s*(\d+\.\S+).*}{$1} && print'))
          if [ ${#screen_stys} = 0 ]; then
            echo "No screen sessions detected."
            return 1
          fi
          printf "Resume which screen session?\n"
          IFS='\n' env screen -ls | grep -v $curr_sty | perl -n -e 's{^\s*(\d+\..*)}{$1} && print' | while read l; do
            printf "%s. %s\n" $i "$l"
            i=$(($i+1))
          done
          read -p "Enter choice: " choice
          # http://unix.stackexchange.com/questions/249907/screen-fails-with-writemessage-bad-file-descriptor
          if echo ${!screen_stys[@]} | grep -q -w -- "$choice"; then
            sty=${screen_stys[$choice]}
            eval $(_esh_e)
            _esh_e $sty ESH_PORT SSH_AUTH_SOCK ESH_AT
            #local pid=$(echo $sty | cut -d. -f1)
            #read -p "Press return to continue"
            env screen -d -r $sty
            return $?
          else
            echo "Invalid choice."
            return 1
          fi
          ;;
        -d|-D|-R|-RR|-ls|-list|-Q|-v|-x|-X)
          env screen "$@"
          return $?
          ;;
      esac
    done
  fi
  # anticipitory optimization: pre-load vim, so it does not need to be loaded
  # in every screen window
  v --version >/dev/null
  local shell=$ESH_TMP/$USER.screen.shell
  touch $shell
  chmod 755 $shell
  local bashE=$(which bash) bashA="$(bash --help|grep -- --import-functions)"
  [ "$bashA" ] && bashE="$bashE $bashA"
  printf '#!%s
# Force SHELL back to normal (freebsd workaround)
SHELL=$(which bash)
[ "$STY" -a "$STY" != "$ESH_STY" ] && {
  # we are in the first window of the screen session, init some things
  #
  # setting SHELL in freebsd does not seem to work
  env screen -S $STY -X setenv SHELL $SHELL
  env screen -S $STY -X setenv ESH_STY $STY
  export ESH_SHELL=%s
  env screen -S $STY -X setenv ESH_SHELL $ESH_SHELL
  _esh_e $STY
  ESH_STY=$STY
  _esh_i
}
# use this trap with DEBUG signal trick to load key environment variables
# before any/all commands are run - useful for resuming screen sessions on
# remote hosts; might want to utilize $BASH_COMMAND at some point to
# conditionally call _esh_e
trap "eval \$(_esh_e)" DEBUG
%s
[ $# -eq 0 -o "$1" = "-c" ] && exec $SHELL --norc --noprofile "$@"
"$@"' $bashE $shell "$(declare -p PS1)" > $shell

  local SCREENRC=$ESH_TMP/$USER.screenrc
  # Set up a little macro so that ^a% will dump the current screen to a file,
  # then edit it in vim.
  local printscreen_macro=$ESH_TMP/$USER.screenrc.printscreen
  local hardcopy_file=$ESH_TMP/$USER.screenrc.hardcopy
  touch $SCREENRC $printscreen_macro $hardcopy_file
  chmod 600 $SCREENRC $printscreen_macro $hardcopy_file
  cat > $SCREENRC << 'EOF'
startup_message off
bind " " windowlist -b
vbell on
vbell_msg DING
#shelltitle "$ |bash:"
bindkey "\032" stuff "\032"
caption always "%{= kw}%-w%{= BW}%n%t%{-}%+w %-= @%H %{= Y}%l%{-} %m/%d %c"
shelltitle "$ |:"
defmonitor on
msgwait 1
hardstatus ignore
# allow special screen user ":window:" to send keystrokes: used in ssh;
# man screen for some other details (used in combination with screen
# escape "ESC ] 83 ; cmd ^G")
#addacl :window: -rwx #?
#aclchg :window: +w+x stuff,sleep
bind / screen $ESH_EDITOR "$ESH_PW_FILE"
EOF
  cat >> $SCREENRC << EOF
bind % source $printscreen_macro
EOF
  cat > $printscreen_macro << EOF
hardcopy_append off
hardcopy $hardcopy_file
screen $ESH_EDITOR $hardcopy_file
EOF

  #local c esc=^Ee initfile=$(mktemp -t escreen.XXX)
  local exec c esc=^Ee

  #export SHELL=$shell

  #c='env screen -S $STY -X setenv ESH_STY $STY'
  #c+=';_esh_e $STY'
  #c+=';export ESH_STY=$STY'
  #c+=';nohup sh -c "while kill -0 ${STY%%.*}; do sleep 5; done; rm -f $(_esh_e -f)" </dev/null >/dev/null 2>&1 & '
  #c+='"$@"'

  if [ "$ESH_SCREEN_EXEC" = 1 ]; then
    esc=^Aa
    exec=exec
  #else
    #c="$(declare -p PS1);$c"
    #[ ${#args[@]} = 0 ] && args=(exec bash --norc --noprofile)
  fi

  #echo "rm $initfile;$c" > $initfile

  # need --import-functions when on freebsd
  #env SCREENRC=$SCREENRC screen -e$esc -s $shell bash $(bash --help|grep -- --import-functions) -c "source $initfile" "${args[@]}"

  # freebsd: screen seems to completely ignore the "-s" flag, so use SHELL
  # environment var instead
  $exec env SCREENRC=$SCREENRC SHELL=$shell screen -e$esc "${args[@]}"
}
