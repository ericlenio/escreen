#
# get/set the main communications port, and other environment variables
#
# if 0 args: cat out current file
#
# if 1 arg:
#   arg is -f: echo the name of file
#
#   arg is a plus sign followed by a variable name: append this variable to the
#   file (as a new "declare" statement)
#
#   arg is any other value: arg is assumed to be a new ESH_STY value to be used
#   in the new file name, and we copy variables from old file to new file
#
# if 2+ args:
# 1st arg: $ESH_STY value
# all remaining args: names of variables to be saved to file
#
_esh_e() {
  local s=${1:-$ESH_STY} n f
  # little nested function here to derive name of file to stash environment
  # vars
  F() {
    printf "%s/STY-%s.env" $ESH_TMP $1
  }
  f=$(F $s)
  case $# in
    0)
      # touch file to keep it fresh so it doesn't get deleted by OS (which
      # might be deleting old files under /tmp)
      touch $f 2>/dev/null
      cat $f
      ;;
    1)
      f=$(F $ESH_STY)
      case $1 in
        -f)
          echo $f
          ;;
        +*)
          # strip leading plus sign, we should be left with a variable name
          n=${1#+}
          # append var name and value to the file
          declare -p $n >> $f
          ;;
        *)
          cat $f > $(F $1)
          ;;
      esac
      ;;
    *)
      shift
      rm -f $f && touch $f && {
        while [ $# -gt 0 ]; do
          n=$1
          shift
          declare -p $n >> $f
        done
        echo wrote $f: $(cat $f) 1>&2
      }
  esac
}
export -f _esh_e

# bootstrapping function: 1st arg is an event ID that the server will inspect
# and run appropriate event handler for; event IDs starting with "z" send back
# a gzip'd response from the server.
#_esh_b() {
  #exec 3<>/dev/tcp/localhost/$ESH_PORT
  #echo $ESH_AT "$*" >&3
  ## Send stdin of this function to esh server (like with cp2cb). This next
  ## cat may show "Resource temporarily unavailable" under certain
  ## conditions, if so generally just set stdin of caller to </dev/null.
  #[ ! -t 0 ] && cat >&3
  #[ ${1:0:1} = z ] && gzip -d -c <&3 || cat <&3
  #exec 3<&- 3>&-
#}
# older shells may not be able to do the /dev/tcp/host/port trick, this works
# around that ... netcat will be needed though
_esh_b() {
  eval "$(_esh_e)"
  {
    echo $ESH_AT "$*"
    #[ ! -t 0 ] && { [ "$(which perl)" ] && perl -pe 'BEGIN{$|=1}' || cat; }
    [ ! -t 0 ] && cat
  } | nc 127.0.0.1 $ESH_PORT | {
    [ ${1:0:1} = z ] && gzip -d -c || cat
  }
}
export -f _esh_b


# load a bash function into the session: first try using cached version,
# re-uploading if it is out of date (or non-existent). Args:
# 1: full pathname to cached file
# 2: optional: password (just be sure to pass a known valid password)
# 3: optional: if non-zero length, just echo the cached file; default is
# to eval it
_esh_l() {
  local f=$1 c p o
  export p=$([ "$2" ] && echo $2 || echo $(_esh_b fpw ${f/*.} </dev/null))
  o="openssl enc -aes256 -pass env:p"
  # https://cryptosense.com/weak-key-derivation-in-openssl/
  # try to use the cached file first ...
  [ -f $f ] && 
    c="$($o -d -in $f 2>/dev/null)" &&
    # check for 16 byte header block injected by server: integrity check for
    # #16
    [[ "$c" =~ ^0000000000000000 ]] || {
    # cached file does not exist or is expired, or failed integrity check so
    # re-cache it
    echo -n "up:${f/*.} " >&2
    c="$(_esh_b zup ${f/*.} </dev/null)"
    echo ${#c} bytes >&2
    echo "$c" | $o >$f
    chmod 666 $f
  }
  # strip out 16 byte header block for integrity check
  c=${c:16}
  [ -z "$3" ] && eval "$c" || echo "$c"
}
export -f _esh_l

# ESH_AT is a simple security access token
#export ESH_AT=$(openssl rand 3 -hex)
#export ESH_HOME=$(dirname $(perl -MCwd -e 'print Cwd::abs_path shift' $0))
#[ -z "$ESH_TMP" ] && {
  #escreen_branch=$(cd $ESH_HOME && git rev-parse --abbrev-ref HEAD)
  #suffix=-$escreen_branch
  #[ $escreen_branch = master ] && suffix=""
  #ESH_TMP=/tmp/esh$suffix
#}
#export ESH_TMP
#[ ! -d $ESH_TMP ] && mkdir $ESH_TMP && chmod 1777 $ESH_TMP
#export ESH_USER=$USER

# shell init script here
_esh_i() {
  local i=$HOME/.escreen_profile
  [ -f $i ] && . $i
  local t=$ESH_TMP u=$ESH_USER f=$(_esh_e -f)
  [ ! -d $t ] && mkdir $t && chmod 1777 $t
  [ ! -f $f ] && {
    _esh_e "$@"
    #nohup sh -c "while kill -0 $$; do sleep 5; done; rm -f $f" </dev/null >/dev/null 2>&1 &
  }
  #[ $# -gt 0 ] && _esh_e "$@"
  # p0, p1, p2 are set by fpw call
  local $(_esh_b fpw cbf </dev/null)
  _esh_l $t/$u.core $p0
  for f in $(_esh_l $t/$u.fcnlist $p1 1); do
    _esh_gen_stub $t/$u.f.$f
  done
  export ESH_TMP ESH_STY SHELL=$(which bash)
  export -f _esh_e _esh_i _esh_b _esh_l _esh_y
  # generate vim executable so it is ready for user, e.g. if escreen starts and
  # then immediately:
  #   s nobody
  #   fc
  _vime
  # use DEBUG trap to load environment vars from _esh_e before every command is
  # run; only set the trap if we detect DEBUG has no signal handler yet
  #
  # TO DO: do some sort of sanity checking that _esh_e contains only "declare"
  # statements
  export PROMPT_COMMAND='[ "$(trap -p DEBUG)" ] || trap '"'"'eval "$(_esh_e)"'"'"' DEBUG'
}

export -f _esh_i

_esh_y() {
  local v
  dcs() {
    # not totally clear when the gnu screen Device Control Strings were needed,
    # but they seemed to be required for "conceal text" (8m) and "restore text"
    # (0m) at least (arg 1 to this function is either "1" or "0", "1" meaning
    # we should send the string so long as we detect we are in a gnu screen
    # session)
    #
    # it makes sense it is needed for conceal text because the gnu screen man
    # page doesn't say that conceal is supported ... but 0m is ("Default
    # Rendition")
    [[ $TERM =~ screen* && $1 = 1 ]] && printf "$2"
  }
  ansi() {
    {
      # gnu screen start Device Control String
      dcs $1 '\x1bP'
      printf '\x1b[%s' "$2"
      # gnu screen finish Device Control String
      dcs $1 '\x1b\\'
    } >/dev/tty
  }
  stty -echo
  # save cursor position
  ansi 0 's'
  # this ANSI pattern matched at the server, and conceals text
  ansi 1 '8m'
  #printf ':%s' "$1" >/dev/tty
  v=$(_esh_b m $ESH_TERM_PID "$1")
  # erase line
  ansi 0 '2K'
  # restore cursor position
  ansi 0 'u'
  [ "$v" = E_OK ] && read -d ';' v </dev/tty
  # erase line
  ansi 0 '2K'
  # restore cursor position, again
  ansi 0 'u'
  # unconceal
  ansi 1 '0m'
  # echo back the value we just read to stdout
  stty echo
  echo "$v"
}
export -f _esh_y

ESH_CORE=$ESH_HOME/core
#[ "$1" ] && ESH_PROFILE="$1" || ESH_PROFILE=$ESH_HOME/profile.lwprof

# ESH_STY is conceptually tied to screen's STY variable ... it gets used as a
# unique ID to properly track the communications port (ESH_PORT) to use in a
# given shell between various combinations of screen, sudo, and ssh
export ESH_STY=$$
