#! /usr/bin/env node
// vim:filetype=javascript
// To do:
//   change auth token every X hours
//   strip whitespace from functions
//
//require('shelljs/global');
var util=require('util');
var fs=require('fs');
var path=require('path');
var zlib=require('zlib');
var net=require('net');
var crypto=require('crypto');
var child_process = require('child_process');
var ESH_TMP="/tmp/esh";
var ESH_CORE_FCN_PREFIX="_";

var opt = require('node-getopt').create([
  ['h','help','display this help'],
  ['r','resume=ARG','resume a GNU screen session (supply the screen STY value)']
])
.bindHelp()
.parseSystem();

var esh = {
  authToken : "",
  oneTimeAuthTokens : [],
  expireOneTimeAuthToken : function(at) {
    var idx=this.oneTimeAuthTokens.indexOf(at);
    if (idx<0) return;
    esh.oneTimeAuthTokens.splice(idx,1);
  },
  getBootstrapScript : function(port,authToken) {
    return util.format(
      // _esh_b is a bootstrap function to request some resource from, or push
      // some data to, the esh server; the esh server responds by sending the
      // response to stdout; by default the server sends the response gzip'd,
      // except for passwords
      //
      // if 1st char of 1st arg is "z", then we expect a gzip'd response from
      // server
      //
      'ESH_PORT=%s;' +
      'ESH_AT=%s;' +
      '_esh_b() { ' +
      'exec 3<>/dev/tcp/localhost/$ESH_PORT;' +
      'echo $ESH_AT "$*" >&3;' +
      // Send stdin of this function to esh server (like with cp2cb). This next
      // cat may show "Resource temporarily unavailable" under certain
      // conditions, if so generally just set stdin of caller to </dev/null.
      '[ ! -t 0 ] && cat >&3;' +
      '[ ${1:0:1} = z ] && gzip -d -c <&3 || cat <&3;' +
      'exec 3>&-;' +
      ' };' +
      'eval "$(_esh_b zI)";',
      port,authToken);
  },
  getProfileDir : function() {return util.format("%s/profile.lenio",this.eshHome)},
  handlers : [],
  eshRcFile : util.format("%s/.eshrc",process.env.HOME),
  getCachedFcnlistFile : function() {
    return util.format("%s/%s.fcnlist",ESH_TMP,process.env.USER);
  },
  getFcnlist: function() {
    var list=[];
    var dirs=new Array(
      this.getProfileDir(),
      this.getCoreDir()
    );
    for (var i in dirs) {
      var dir=dirs[i];
      var ls=fs.readdirSync(dir);
      for (var j=0; j<ls.length; j++) {
        if (ls[j].search('^\\w+$')<0) continue;
        if (list.indexOf(ls[j])>=0) continue;
        if (ls[j]=="README") continue;
        list.push(ls[j]);
      }
    }
    list.sort();
    return list.join("\n");
  },
  eshHome : path.dirname(process.argv[1]),
  getCachedBashrcFile : function() {
    return util.format("%s/%s.bashrc",ESH_TMP,process.env.USER);
  },
  getBashrc : function() {
    var f=util.format("%s/bashrc",this.getProfileDir());
    var s="";
    if (fs.existsSync(f)) {
      s=fs.readFileSync(f);
    }
    return s;
  },
  getCachedCoreFile : function() {
    return util.format("%s/%s.core",ESH_TMP,process.env.USER);
  },
  getCoreDir : function() {
    return util.format("%s/core",this.eshHome);
  },
  getCore : function() {
    var dir=this.getCoreDir();
    var ls=fs.readdirSync(dir);
    var s="";
    for (var i=0; i<ls.length; i++) {
      if (ls[i].search("^"+ESH_CORE_FCN_PREFIX)<0) continue;
      s+=fs.readFileSync(dir+"/"+ls[i]);
    }
    return s;
  },
  computeHash : function(s) {
    var h = crypto.createHash('sha1');
    h.update(s);
    return h.digest('hex').toLowerCase();
  },
  computePassword : function(s) {
    // MY_PASSWORD should be defined in esh.eshRcFile
    return this.computeHash( MY_PASSWORD + s ).substr(0,6);
  },
  generateAuthToken : function() {
    return crypto.randomBytes(3).toString('hex');
  },
  getZlib : function() {
    return zlib.createGzip({level:zlib.Z_BEST_COMPRESSION});
  },
  getSource : function(key) {
    var buf="";
    if (key=="core") {
      buf=this.getCore();
    } else if (key=="bashrc") {
      buf=this.getBashrc();
    } else if (key=="fcnlist") {
      buf=this.getFcnlist();
    } else {
      var dirs=new Array(
        this.getProfileDir(),
        this.getCoreDir()
      );
      for (var i in dirs) {
        var f=util.format("%s/%s",dirs[i],key);
        if (fs.existsSync(f)) {
          buf=fs.readFileSync(f);
          break;
        }
      }
    }
    return buf;
  },
  startServer : function(listen_port,launch_cmd) {
    var server = net.createServer({allowHalfOpen:true}, function (socket) {
      //console.log("Connection from " + socket.remoteAddress + " at " + new Date() );
      socket.setNoDelay(true);
      // Define a little object to capture this event
      var evt = {
        socket : socket,
        getEventType : function() {
          var err;
          var chunk=socket.read();
          if (chunk==null) {
            console.log("WARNING: null chunk");
            return;
          }
          var hdr=[];
          for (var i=0;i<chunk.length;i++) {
            if (chunk[i]==10) {
              var xtra;
              if (i<chunk.length-1) {
                var xtra=chunk.slice(i+1);
                var res=socket.unshift(xtra);
              }
              hdr=new String(chunk.slice(0,i)).split(" ");
              break;
            }
          }
          if (hdr.length==0) {
            hdr=new String(chunk).trim().split(" ");
          }
          if (esh.oneTimeAuthTokens.indexOf(hdr[0])>=0) {
            esh.expireOneTimeAuthToken(hdr[0]);
          } else if (hdr[0]!=esh.authToken) {
            console.log("ERROR: unmatched auth token");
            setTimeout( function() { socket.end("bad auth token"); }, 5000 );
            return;
          }
          evt.evt_id = hdr[1];
          hdr.splice(0,2);
          hdr.unshift(evt);
          try {
            // Call the handler
            //esh.handlers[evt.evt_id](evt,hdr);
            esh.handlers[evt.evt_id].apply(null,hdr);
          } catch (err) {
            console.log( "EXCEPTION: chunk:" + chunk + "Message: " + err );
          }
        },
      };
      // Do readable here since on slow connection we may need to push data back
      // into the buffer, especially with setCb. Once a "data" event is listened
      // for it puts the stream into flow mode, and then unshift would not work.
      socket.once("readable",evt.getEventType);
    });

    server.listen(Number(listen_port),"localhost",null,function(e) {
      var port = server.address().port;
      esh.authToken = esh.generateAuthToken();
      console.log("esh server listening on port=%s, auth token=%s",port,esh.authToken);
      var bash = child_process.spawn("bash",
        ["-c",esh.getBootstrapScript(port,esh.authToken)+launch_cmd],
        {
          stdio: 'inherit'
        });

      bash.on('exit', function (e, code) {
        console.log("shutting down esh");
        process.exit();
      });

    });
  },
};

if (fs.existsSync(esh.eshRcFile)) {
  eval(fs.readFileSync(esh.eshRcFile).toString());
} else {
  console.log( "Please create " + esh.eshRcFile + ", with MY_PASSWORD value." );
  process.exit(1);
}

esh.registerHandler=function(evt_id,f) {
  esh.handlers[evt_id]=f;
};

// Bootstrap stage 1
esh.registerHandler( "zI", function(evt) {
  var s=evt.socket;
  var buf="";
  //buf+="echo 'bootstrapping shell now ...'\n";
  buf+="ESH_TMP="+ESH_TMP+";";
  buf+="t=$ESH_TMP;";
  buf+="[ ! -d $t ] && mkdir $t && chmod 1777 $t;";
  // function _esh_l: load the cached file and eval it
  // arg 1: cache file name
  // optional arg 2: if non-blank, cat the file instead of eval-ing
  buf+='_esh_l() { ' +
    'local f p c;' +
    'f=$1;' +
    'o="openssl enc -a -aes256 -pass pass:$(_esh_b fpw ${f/*.})";' +
    // try to use the cached file first ...
    '[ -f $f ] && c="$($o -d -in $f 2>/dev/null)" || ' +
    // cached file does not exist or is expired, so re-cache it
    '{ echo up:${f/*.} >&2;c="$(_esh_b zup ${f/*.})";echo "$c" | $o >$f;chmod 666 $f; };' +
    '[ -z "$2" ] && eval "$c" || echo "$c";' +
    '};'
    ;

  buf+='_esh_l ' + esh.getCachedCoreFile() + ';';
  buf+='_esh_l ' + esh.getCachedBashrcFile() + ';';
  buf+=util.format(
    'for f in $(_esh_l %s 1); do _esh_gen_stub $t/%s.f.$f; done;',
    esh.getCachedFcnlistFile(),
    process.env.USER
    );
  buf+='_esh_init;'

  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

// get bash bootstrapping script
esh.registerHandler( "zB", function(evt,port,authToken) {
  var s=evt.socket;
  var z=esh.getZlib();
  z.pipe(s);
  z.end(esh.getBootstrapScript(port,authToken));
});

// upload a file to client
esh.registerHandler( "zup", function(evt,key) {
  var s=evt.socket;
  var buf=esh.getSource(key);
  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

// get function password
esh.registerHandler( "fpw", function(evt,key) {
  var s=evt.socket;
  var pw=esh.computePassword(esh.getSource(key));
  s.end(pw);
});

// one time auth token
esh.registerHandler( "otat", function(evt) {
  var s=evt.socket;
  var at=esh.generateAuthToken();
  esh.oneTimeAuthTokens.push(at);
  setTimeout(function() {
    esh.expireOneTimeAuthToken(at);
  },60000);
  s.end(at);
});

// receive clipboard data from client, and store inside clipboard
esh.registerHandler( "setCb", function(evt) {
  var s=evt.socket;
  var z=zlib.Gunzip();
  var buf="";
  var p=child_process.spawn("clipit", [], {stdio:['pipe',process.stdout,process.stderr]});
  var cleanExit=false;
  p.on('exit',function() {
    cleanExit=true;
    //console.log("copied "+buf.length+" bytes to clipboard");
    // if small enough buffer, place into X Windows primary selection too for
    // convenience
    if (buf.length>255) return;
    var p2 = child_process.spawn("xsel", ["-i","-p"], {stdio:['pipe',process.stdout,process.stderr]});
    p2.stdin.end(buf);
  });
  s.pipe(z).pipe(p.stdin);
  s.end();
  setTimeout(function() {
    if (cleanExit) return;
    console.log("TIMEOUT writing to clipboard");
    //s.unpipe(z);
    //z.end();
    //z.unpipe(p.stdin);
    //p.stdin.end();
    p.kill();
  },10000);

  z.on("data", function(chunk) {
    buf+=new String(chunk);
  });
});

// send clipboard data to client
esh.registerHandler( "zGetCb", function(evt,key) {
  var s=evt.socket;
  var p=child_process.spawn("clipit", ["-c"], {stdio:['ignore','pipe',process.stderr]});
  var z=esh.getZlib();
  p.stdout.pipe(z).pipe(s);
});

if (opt.options.resume) {
  //var p=child_process.spawn("/usr/bin/screen", ["-ls"], {stdio:['ignore','pipe',process.stderr]});
  //var sty=[];
  //var stdout="";
  //p.stdout.on("data",function(chunk) {
    //stdout+=chunk.toString();
  //});
  //p.on("close",function() {
    //console.log(stdout);
    //var res;
    //var re=/^\s+(\d+)/gm;
    //while ((res=re.exec(stdout))!==null) {
      //sty.push(res[1]);
    //}
    //console.log(">"+JSON.stringify(sty));
  //});
  var portfile=util.format("%s/%s.screen.%s",
    ESH_TMP,process.env.USER,opt.options.resume);
  var port=fs.readFileSync(portfile);
  esh.startServer(port,util.format("screen -d -r %s",opt.options.resume));
} else {
  esh.startServer(0,"exec /bin/bash --norc --noprofile");
}
