#! /usr/bin/env node
// vim:filetype=javascript
// To do:
//   change auth token every X hours
//
//require('shelljs/global');
var util=require('util');
var fs=require('fs');
var path=require('path');
var zlib=require('zlib');
var net=require('net');
var crypto=require('crypto');
var child_process=require('child_process');
var clim=require('clim');
clim("",console,true);
require('date-format-lite');
clim.getTime=function() {
  var d=new Date();
  return d.format("MM/DD hh:mm:ss.SS");
};

var ESH_TMP=process.env.ESH_TMP;
var ESH_CORE_FCN_PREFIX="_";

var opt = require('node-getopt').create([
  ['h','help','display this help'],
  ['p','port=ARG','port number to listen'],
  ['','get_free_port','get a free port'],
  //['r','resume=ARG','resume a GNU screen session (supply the screen STY value)']
])
.bindHelp()
.parseSystem();

var esh = {
  authToken : "",
  oneTimeAuthTokens : [],
  expireOneTimeAuthToken : function(at) {
    var idx=this.oneTimeAuthTokens.indexOf(at);
    if (idx<0) return;
    esh.oneTimeAuthTokens.splice(idx,1);
  },
  getProfileDir : function() {return util.format("%s/profile.lenio",this.eshHome)},
  handlers : [],
  eshRcFile : util.format("%s/.eshrc",process.env.HOME),
  getCachedFcnlistFile : function() {
    return util.format("%s/%s.fcnlist",ESH_TMP,process.env.USER);
  },
  getFcnlist: function() {
    var list=[];
    var dirs=new Array(
      this.getProfileDir(),
      this.getCoreDir()
    );
    for (var i in dirs) {
      var dir=dirs[i];
      var ls=fs.readdirSync(dir);
      for (var j=0; j<ls.length; j++) {
        if (ls[j].search('^\\w+$')<0) continue;
        if (list.indexOf(ls[j])>=0) continue;
        if (ls[j]=="README") continue;
        list.push(ls[j]);
      }
    }
    list.sort();
    return list.join("\n");
  },
  eshHome : path.dirname(process.argv[1]),
  getCachedBashrcFile : function() {
    return util.format("%s/%s.bashrc",ESH_TMP,process.env.USER);
  },
  getBashrc : function() {
    var f=util.format("%s/bashrc",this.getProfileDir());
    var s="";
    if (fs.existsSync(f)) {
      s=fs.readFileSync(f);
    }
    return s;
  },
  getCachedCoreFile : function() {
    return util.format("%s/%s.core",ESH_TMP,process.env.USER);
  },
  getCoreDir : function() {
    return util.format("%s/core",this.eshHome);
  },
  getCore : function() {
    var dir=this.getCoreDir();
    var ls=fs.readdirSync(dir);
    var s="";
    for (var i=0; i<ls.length; i++) {
      if (ls[i].search("^"+ESH_CORE_FCN_PREFIX)<0) continue;
      s+=fs.readFileSync(dir+"/"+ls[i]);
    }
    return s;
  },
  computeHash : function(s) {
    var h = crypto.createHash('sha1');
    h.update(s);
    return h.digest('hex').toLowerCase();
  },
  computePassword : function(s) {
    // MY_PASSWORD should be defined in esh.eshRcFile
    return this.computeHash( MY_PASSWORD + s ).substr(0,6);
  },
  generateAuthToken : function() {
    return crypto.randomBytes(3).toString('hex');
  },
  getZlib : function() {
    return zlib.createGzip({level:zlib.Z_BEST_COMPRESSION});
  },
  getSource : function(key) {
    var buf="";
    if (key=="core") {
      buf=this.getCore();
    } else if (key=="bashrc") {
      buf=this.getBashrc();
    } else if (key=="fcnlist") {
      buf=this.getFcnlist();
    } else {
      var dirs=new Array(
        this.getProfileDir(),
        this.getCoreDir()
      );
      for (var i in dirs) {
        var f=util.format("%s/%s",dirs[i],key);
        if (fs.existsSync(f)) {
          buf=fs.readFileSync(f);
          break;
        }
      }
    }
    var buf2=String(buf).replace(/(^|\n)\s*#(?!#)[^\n]*\n/mg,"$1");
    return buf2;
  },
  startServer : function(port) {
    var server = net.createServer({allowHalfOpen:true}, function (socket) {
      //console.log("Connection from " + socket.remoteAddress + " at " + new Date() );
      socket.setNoDelay(true);
      // Define a little object to capture this event
      var evt = {
        socket : socket,
        getEventType : function() {
          var err;
          var chunk=socket.read();
          if (chunk==null) {
            console.log("WARNING: null chunk");
            return;
          }
          var hdr=[];
          for (var i=0;i<chunk.length;i++) {
            if (chunk[i]==10) {
              var xtra;
              if (i<chunk.length-1) {
                var xtra=chunk.slice(i+1);
                var res=socket.unshift(xtra);
              }
              hdr=new String(chunk.slice(0,i)).split(" ");
              break;
            }
          }
          if (hdr.length==0) {
            hdr=new String(chunk).trim().split(" ");
          }
          if (esh.oneTimeAuthTokens.indexOf(hdr[0])>=0) {
            esh.expireOneTimeAuthToken(hdr[0]);
          } else if (hdr[0]!=esh.authToken) {
            console.log("ERROR: unmatched auth token");
            setTimeout( function() { socket.end("bad auth token"); }, 5000 );
            return;
          }
          evt.evt_id = hdr[1];
          hdr.splice(0,2);
          console.log(evt.evt_id+":"+hdr);
          hdr.unshift(evt);
          try {
            // Call the handler
            //esh.handlers[evt.evt_id](evt,hdr);
            esh.handlers[evt.evt_id].apply(null,hdr);
          } catch (err) {
            console.log( "EXCEPTION: chunk:" + chunk + "Message: " + err );
          }
        },
      };
      // Do readable here since on slow connection we may need to push data back
      // into the buffer, especially with setCb. Once a "data" event is listened
      // for it puts the stream into flow mode, and then unshift would not work.
      socket.once("readable",evt.getEventType);
    });

    server.listen(Number(port),"localhost",null,function(e) {
      var port2 = server.address().port;
      if (opt.options.get_free_port) {
        process.stdout.write(""+port2);
        process.exit();
      }
      console.log("START esh server listening on: " + port2);
      esh.authToken = process.env.ESH_AT;
      //child_process.fork("");
      //process.exit();
      // push the value of the port into screen's environment
      //var p=child_process.spawn("screen",
        //["-S",process.env.STY,"-X","setenv","ESH_PORT",port],
        //{stdio:['ignore',process.stdout,process.stderr]}
        //);
    });
  },
};

if (fs.existsSync(esh.eshRcFile)) {
  eval(fs.readFileSync(esh.eshRcFile).toString());
} else {
  console.log( "Please create " + esh.eshRcFile + ", with MY_PASSWORD value." );
  process.exit(1);
}

esh.registerHandler=function(evt_id,f) {
  esh.handlers[evt_id]=f;
};

esh.registerHandler( "test", function(evt) {
  // https://gist.github.com/pguillory/729616 (suggests overloading process.stdout.write method)
  var s=evt.socket;
  s.end("got it:"+process.env.ESH_FIFO+"\n");
  if (flag==0) {
    console.log("write:"+process.stdout.write);
    //var ptstream=require('stream').PassThrough;
    var stream=fs.createWriteStream(process.env.ESH_FIFO);
    process.stdout.on("data",function(chunk) {
      stream.write("on:"+chunk);
    });
    //process.stdout.pipe(new ptstream).pipe(stream);
    console.log("see it?");
    flag=1;
  }
  console.log("test");
});

// upload a file to client
esh.registerHandler( "zup", function(evt,key) {
  var s=evt.socket;
  var buf=esh.getSource(key);
  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

// get function password
esh.registerHandler( "fpw", function(evt,key) {
  var s=evt.socket;
  var pw="";
  if (key=="cbf") {
    // optimization: return 3 passwords for core, bashrc, and fcnlist
    pw=util.format("p0=%s p1=%s p2=%s",
      esh.computePassword(esh.getSource("core")),
      esh.computePassword(esh.getSource("bashrc")),
      esh.computePassword(esh.getSource("fcnlist"))
      );
  } else {
    pw=esh.computePassword(esh.getSource(key));
  }
  s.end(pw);
});

// one time auth token - UNUSED
esh.registerHandler( "otat", function(evt) {
  var s=evt.socket;
  var at=esh.generateAuthToken();
  esh.oneTimeAuthTokens.push(at);
  setTimeout(function() {
    esh.expireOneTimeAuthToken(at);
  },60000);
  s.end(at);
});

// receive clipboard data from client, and store inside clipboard
esh.registerHandler( "setCb", function(evt) {
  var s=evt.socket;
  var z=zlib.Gunzip();
  var buf="";
  var p=child_process.spawn("clipit", [], {stdio:['pipe',process.stdout,process.stderr]});
  var cleanExit=false;
  p.on('exit',function() {
    cleanExit=true;
    console.log("copied "+buf.length+" bytes to clipboard");
    // if small enough buffer, place into X Windows primary selection too for
    // convenience
    if (buf.length>255) return;
    var p2 = child_process.spawn("xsel", ["-i","-p"], {stdio:['pipe',process.stdout,process.stderr]});
    p2.stdin.end(buf);
  });
  s.pipe(z).pipe(p.stdin);
  s.end();
  setTimeout(function() {
    if (cleanExit) return;
    console.log("TIMEOUT writing to clipboard");
    //s.unpipe(z);
    //z.end();
    //z.unpipe(p.stdin);
    //p.stdin.end();
    p.kill();
  },10000);

  z.on("data", function(chunk) {
    buf+=new String(chunk);
  });
});

// send clipboard data to client
esh.registerHandler( "zGetCb", function(evt,key) {
  var s=evt.socket;
  var p=child_process.spawn("clipit", ["-c"], {stdio:['ignore','pipe',process.stderr]});
  var z=esh.getZlib();
  p.stdout.pipe(z).pipe(s);
});

var port=opt.options.port || 0;
esh.startServer(port);
