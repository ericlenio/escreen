#! /usr/bin/nodejs
// vim:filetype=javascript
// To do:
//   change auth token every X hours
//   strip whitespace from functions
//
//var opt = require('node-getopt');
//require('shelljs/global');
var util=require('util');
var fs=require('fs');
var path=require('path');
var zlib=require('zlib');
var net=require('net');
var crypto=require('crypto');
var ESH_TMP="/tmp/esh";
var ESH_CORE_FCN_PREFIX="_ES_";

var esh = {
  authToken : "",
  getProfileDir : function() {return util.format("%s/profile.lenio",this.eshHome)},
  handlers : [],
  eshRcFile : util.format("%s/.eshrc",process.env.HOME),
  getCachedFcnlistFile : function() {
    return util.format("%s/%s.fcnlist",ESH_TMP,process.env.USER);
  },
  getFcnlist: function() {
    var dir=this.getProfileDir();
    var ls=fs.readdirSync(dir);
    var s="";
    for (var i=0; i<ls.length; i++) {
      if (ls[i].search('^\\w+$')<0) continue;
      if (s.length>0) s+="\n";
      s+=ls[i];
    }
    return s;
  },
  eshHome : path.dirname(process.argv[1]),
  getCachedBashrcFile : function() {
    return util.format("%s/%s.bashrc",ESH_TMP,process.env.USER);
  },
  getBashrc : function() {
    var f=util.format("%s/bashrc",this.getProfileDir());
    var s="";
    if (fs.existsSync(f)) {
      s=fs.readFileSync(f);
    }
    return s;
  },
  getCachedCoreFile : function() {
    return util.format("%s/%s.core",ESH_TMP,process.env.USER);
  },
  getCore : function() {
    var dir=util.format("%s/core",this.eshHome);
    var ls=fs.readdirSync(dir);
    var s="echo LOADING CORE\n";
    for (var i=0; i<ls.length; i++) {
      if (ls[i].search("^"+ESH_CORE_FCN_PREFIX)<0) continue;
      s+=fs.readFileSync(dir+"/"+ls[i]);
    }
    //s+=util.format(". %s\n",this.getBashrcFile());
    return s;
  },
  computeHash : function(s) {
    var h = crypto.createHash('sha1');
    h.update(s);
    return h.digest('hex').toLowerCase();
  },
  computePassword : function(s) {
    // MY_PASSWORD should be defined in esh.eshRcFile
    return this.computeHash( MY_PASSWORD + s ).substr(0,6);
  },
  generateAuthToken : function() {
    return crypto.randomBytes(3).toString('hex');
  },
  getZlib : function() {
    return zlib.createGzip({level:zlib.Z_BEST_COMPRESSION});
  },
  getSource : function(key) {
    var buf="";
    if (key=="core") {
      buf=this.getCore();
    } else if (key=="bashrc") {
      buf=this.getBashrc();
    } else if (key=="fcnlist") {
      buf=this.getFcnlist();
    }
    return buf;
  }
};

if (fs.existsSync(esh.eshRcFile)) {
  eval(fs.readFileSync(esh.eshRcFile).toString());
} else {
  console.log( "Please create " + esh.eshRcFile + ", with MY_PASSWORD value." );
  process.exit(1);
}

esh.registerHandler=function(evt_id,f) {
  esh.handlers[evt_id]=f;
};

// Bootstrap stage 1
esh.registerHandler( "BS1", function(evt) {
  var s=evt.socket;
  var buf="";
  buf+="echo 'bootstrapping shell now ...'\n";
  buf+="ESH_TMP="+ESH_TMP+"\n";
  buf+="[ ! -d $ESH_TMP ] && mkdir $ESH_TMP && chmod 1777 $ESH_TMP;";
  // arg 1: cache file name
  // optional arg 2: if non-blank, do not attempt to eval the file
  buf+='l() { ' +
    'f=$1;' +
    // get the password
    'p=pass:$(b pw ${f/*.});' +
    // try to use the cached file first ...
    '[ -f $f ] && c="$(openssl enc -a -d -aes256 -in $f -pass $p 2>/dev/null)" || ' +
    // cached file does not exist or is expired, so re-cache it
    '{ c="$(b up ${f/*.})"; echo "$c" | openssl enc -a -aes256 -pass $p >$f; };' +
    '[ -z "$2" ] && eval "$c";' +
    '};'
    ;

  buf+='l ' + esh.getCachedCoreFile() + ';';
  buf+='l ' + esh.getCachedBashrcFile() + ';';
  buf+='l ' + esh.getCachedFcnlistFile() + ' 1;';

  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

esh.registerHandler( "up", function(evt,key) {
console.log("up:"+key);
  var s=evt.socket;
  var buf=esh.getSource(key);
  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

esh.registerHandler( "pw", function(evt,key) {
  var s=evt.socket;
  var buf=esh.computePassword(esh.getSource(key));
  s.end(buf);
});

var server = net.createServer({allowHalfOpen:true}, function (socket) {
  //console.log("Connection from " + socket.remoteAddress + " at " + new Date() );
  socket.setNoDelay(true);
  // Define a little object to capture this event
  var evt = {
    socket : socket,
    onData : function(data) {
      var err;
      try {
        if (evt.evt_id==undefined) {
          var m=new String(data).trim().split(" ");
          if (m[0]!=esh.authToken) {
            console.log("ERROR: unmatched auth token");
            setTimeout( function() { socket.end("bad auth token"); }, 5000 );
            return;
          }
          evt.evt_id = m[1];
          m.splice(0,2);
          // Call the handler
          esh.handlers[evt.evt_id](evt,m);
        }
      } catch (err) {
        console.log( "EXCEPTION: data:" + data + "Message: " + err );
      }
    },
  };
  socket.on("data", evt.onData );
  socket.on("end", function() {
    //console.log( "END of socket" );
  });
});

server.listen(0, "localhost", null, function(e) {
  esh.port = server.address().port;
  esh.authToken = esh.generateAuthToken();
  console.log("esh server listening on port=%s, auth token=%s",esh.port,esh.authToken);
  var bash = require('child_process').spawn("bash", [
    "-c",
    util.format(
      // b is a bootstrap function to request some resource from the esh
      // server, sending the response to stdout; by default the server sends
      // the response gzip'd, except for passwords
      'b() { exec 3<>/dev/tcp/localhost/%s; echo %s "$*" >&3; [ $1 = pw ] && cat <&3 || gzip -d -c <&3; exec 3>&-; }; eval "$(b BS1)"; exec bash --norc --noprofile',
      esh.port,esh.authToken )
  ], {
    stdio: 'inherit'
  });

  bash.on('exit', function (e, code) {
    console.log("shutting down esh");
    process.exit();
  });

});
