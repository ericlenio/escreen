#! /usr/bin/nodejs
// vim:filetype=javascript
// To do:
//   change auth token every X hours
//
//var opt = require('node-getopt');
//require('shelljs/global');
var util=require('util');
var fs=require('fs');
var path=require('path');
var zlib=require('zlib');
var net=require('net');
var crypto=require('crypto');
var ESH_TMP="/tmp/esh";
var ESH_CORE_FCN_PREFIX="_ES_";

var esh = {
  authToken : "",
  getProfileDir : function() {return util.format("%s/profile.lenio",this.eshHome)},
  handlers : [],
  eshRcFile : util.format("%s/.eshrc",process.env.HOME),
  getFcnlistFile : function() {return util.format("%s/%s.fcnlist",ESH_TMP,process.env.USER);},
  eshCore : util.format("%s/%s.eshCore",ESH_TMP,process.env.LOGNAME),
  eshHome : path.dirname(process.argv[1]),
  getBashrcFile : function() {return util.format("%s/%s.bashrc",ESH_TMP,process.env.USER);},
  getBashrc : function() {
    var f=this.getProfileDir()+"/.bashrc";
    var s="";
    if (fs.existsSync(f)) {
      s=fs.readFileSync(f);
    }
    return s;
  },
  getEshCore : function() {
    var dir=util.format("%s/core",this.eshHome);
    var ls=fs.readdirSync(dir);
    var s="";
    for (var i=0; i<ls.length; i++) {
      if (ls[i].search("^"+ESH_CORE_FCN_PREFIX)<0) continue;
      s+=fs.readFileSync(dir+"/"+ls[i]);
    }
    var bs="_ES_core() {\n";
    bs+=util.format("f=%s\n",esh.getBashrc());
    return bs;
  },
  computeHash : function(s) {
    var h = crypto.createHash('sha1');
    h.update(s);
    return h.digest('hex').toLowerCase();
  },
  computePassword : function(s) {
    // MY_PASSWORD should be defined in esh.eshRcFile
    return this.computeHash( MY_PASSWORD + s ).substr(0,6);
  },
  generateAuthToken : function() {
    return crypto.randomBytes(3).toString('hex');
  },
  getZlib : function() {
    return zlib.createGzip({level:zlib.Z_BEST_COMPRESSION});
  },
  getSource : function(key) {
    var buf="";
    if (key=="core") {
      buf=this.getEshCore();
    } else if (key=="bashrc") {
      buf=this.getBashrc();
    }
    return buf;
  }
};

if (fs.existsSync(esh.eshRcFile)) {
  eval(fs.readFileSync(esh.eshRcFile).toString());
} else {
  console.log( "Please create " + esh.eshRcFile + ", with MY_PASSWORD value." );
  process.exit(1);
}

esh.registerHandler=function(evt_id,f) {
  esh.handlers[evt_id]=f;
};

// Bootstrap stage 1
esh.registerHandler( "BS1", function(evt) {
  var s=evt.socket;
  var buf="";
  buf+="echo 'bootstrapping shell now ...'\n";
  buf+="ESH_TMP="+ESH_TMP+"\n";
  buf+="[ ! -d $ESH_TMP ] && mkdir $ESH_TMP && chmod 1777 $ESH_TMP;";
  //buf+="export ESH_PORT="+esh.port+"\n";
  buf+=util.format("f=%s\n",esh.eshCore);
  //var pw=esh.computePassword(core);
  buf+='l() { ' +
    'f=$1;' +
    // get the password
    'p=pass:$(b pw ${f/*.});' +
    // try to use the cached file first ...
    '[ -f $f ] && c="$(openssl enc -a -d -aes256 -in $f -pass $p)" || ' +
    // cached file does not exist or is expired, so re-cache it
    '{ c="$(b up ${f/*.})"; echo "$c" | openssl enc -a -aes256 -pass $p >$f; };' +
    'eval "$c";' +
    '};'
    ;
  buf+='l $f;';
  buf+='l ' + esh.getBashrcFile() + ';';
  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

esh.registerHandler( "up", function(evt,key) {
  var s=evt.socket;
  var buf=esh.getSource(key);
  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

esh.registerHandler( "pw", function(evt,key) {
  var s=evt.socket;
  var buf=esh.computePassword(esh.getSource(key));
  s.end(buf);
});

var server = net.createServer({allowHalfOpen:true}, function (socket) {
  console.log("Connection from " + socket.remoteAddress + " at " + new Date() );
  socket.setNoDelay(true);
  // Define a little object to capture this event
  var evt = {
    socket : socket,
    onData : function(data) {
      var err;
      try {
        if (evt.evt_id==undefined) {
          var m=new String(data).trim().split(" ");
console.log("m:" +JSON.stringify(m));
          if (m[0]!=esh.authToken) {
            console.log("ERROR: unmatched auth token");
            setTimeout( function() { socket.end("bad auth token"); }, 5000 );
            return;
          }
          evt.evt_id = m[1];
          m.splice(0,2);
          // Call the handler
          esh.handlers[evt.evt_id](evt,m);
        }
      } catch (err) {
        console.log( "EXCEPTION: data:" + data + "Message: " + err );
      }
    },
  };
  socket.on("data", evt.onData );
  socket.on("end", function() {
    //console.log( "END of socket" );
  });
});

server.listen(0, "localhost", null, function(e) {
  esh.port = server.address().port;
  esh.authToken = esh.generateAuthToken();
  console.log("esh server listening on port=%s, auth token=%s",esh.port,esh.authToken);
  var bash = require('child_process').spawn("bash", [
    "-c",
    util.format(
      'b() { exec 3<>/dev/tcp/localhost/%s; echo %s "$*" >&3; [ $1 = pw ] && cat <&3 || gzip -d -c <&3; exec 3>&-; }; eval "$(b BS1)"; exec bash',
      esh.port,esh.authToken )
  ], {
    stdio: 'inherit'
  });

  bash.on('exit', function (e, code) {
    console.log("shutting down esh");
    process.exit();
  });

});
