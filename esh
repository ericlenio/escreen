#! /usr/bin/env node
// vim:filetype=javascript
// To do:
//   change auth token every X hours
//   strip whitespace from functions
//
//var opt = require('node-getopt');
//require('shelljs/global');
var util=require('util');
var fs=require('fs');
var path=require('path');
var zlib=require('zlib');
var net=require('net');
var crypto=require('crypto');
var child_process = require('child_process');
var ESH_TMP="/tmp/esh";
var ESH_CORE_FCN_PREFIX="_";

var esh = {
  authToken : "",
  oneTimeAuthTokens : [],
  expireOneTimeAuthToken : function(pw) {
    var idx=this.oneTimeAuthTokens.indexOf(pw);
    if (idx<0) return;
    esh.oneTimeAuthTokens.splice(idx,1);
    console.log("dropped:"+pw);
  },
  getBootstrapScript : function(port) {
    return util.format(
      // _esh_b is a bootstrap function to request some resource from, or push
      // some data to, the esh server; the esh server responds by sending the
      // response to stdout; by default the server sends the response gzip'd,
      // except for passwords
      //
      // if 1st char of 1st arg is "z", then we expect a gzip'd response from
      // server
      //
      'ESH_PORT=%s;' +
      '_esh_b() { ' +
      'exec 3<>/dev/tcp/localhost/$ESH_PORT;' +
      'echo %s "$*" >&3;' +
      // Send stdin of this function to esh server (like with cp2cb). This next
      // cat may show "Resource temporarily unavailable" under certain
      // conditions, if so generally just set stdin of caller to </dev/null.
      '[ ! -t 0 ] && cat >&3;' +
      '[ ${1:0:1} = z ] && gzip -d -c <&3 || cat <&3;' +
      'exec 3>&-;' +
      ' };' +
      'eval "$(_esh_b zI)";',
      port,this.authToken);
  },
  getProfileDir : function() {return util.format("%s/profile.lenio",this.eshHome)},
  handlers : [],
  eshRcFile : util.format("%s/.eshrc",process.env.HOME),
  getCachedFcnlistFile : function() {
    return util.format("%s/%s.fcnlist",ESH_TMP,process.env.USER);
  },
  getFcnlist: function() {
    var list=[];
    var dirs=new Array(
      this.getProfileDir(),
      this.getCoreDir()
    );
    for (var i in dirs) {
      var dir=dirs[i];
      var ls=fs.readdirSync(dir);
      for (var j=0; j<ls.length; j++) {
        if (ls[j].search('^\\w+$')<0) continue;
        if (list.indexOf(ls[j])>=0) continue;
        if (ls[j]=="README") continue;
        list.push(ls[j]);
      }
    }
    list.sort();
    return list.join("\n");
  },
  eshHome : path.dirname(process.argv[1]),
  getCachedBashrcFile : function() {
    return util.format("%s/%s.bashrc",ESH_TMP,process.env.USER);
  },
  getBashrc : function() {
    var f=util.format("%s/bashrc",this.getProfileDir());
    var s="";
    if (fs.existsSync(f)) {
      s=fs.readFileSync(f);
    }
    return s;
  },
  getCachedCoreFile : function() {
    return util.format("%s/%s.core",ESH_TMP,process.env.USER);
  },
  getCoreDir : function() {
    return util.format("%s/core",this.eshHome);
  },
  getCore : function() {
    var dir=this.getCoreDir();
    var ls=fs.readdirSync(dir);
    var s="";
    for (var i=0; i<ls.length; i++) {
      if (ls[i].search("^"+ESH_CORE_FCN_PREFIX)<0) continue;
      s+=fs.readFileSync(dir+"/"+ls[i]);
    }
    return s;
  },
  computeHash : function(s) {
    var h = crypto.createHash('sha1');
    h.update(s);
    return h.digest('hex').toLowerCase();
  },
  computePassword : function(s) {
    // MY_PASSWORD should be defined in esh.eshRcFile
    return this.computeHash( MY_PASSWORD + s ).substr(0,6);
  },
  generateAuthToken : function() {
    return crypto.randomBytes(3).toString('hex');
  },
  getZlib : function() {
    return zlib.createGzip({level:zlib.Z_BEST_COMPRESSION});
  },
  getSource : function(key) {
    var buf="";
    if (key=="core") {
      buf=this.getCore();
    } else if (key=="bashrc") {
      buf=this.getBashrc();
    } else if (key=="fcnlist") {
      buf=this.getFcnlist();
    } else {
      var dirs=new Array(
        this.getProfileDir(),
        this.getCoreDir()
      );
      for (var i in dirs) {
        var f=util.format("%s/%s",dirs[i],key);
        if (fs.existsSync(f)) {
          buf=fs.readFileSync(f);
          break;
        }
      }
    }
    return buf;
  }
};

if (fs.existsSync(esh.eshRcFile)) {
  eval(fs.readFileSync(esh.eshRcFile).toString());
} else {
  console.log( "Please create " + esh.eshRcFile + ", with MY_PASSWORD value." );
  process.exit(1);
}

esh.registerHandler=function(evt_id,f) {
  esh.handlers[evt_id]=f;
};

// Bootstrap stage 1
esh.registerHandler( "zI", function(evt) {
  var s=evt.socket;
  var buf="";
  //buf+="echo 'bootstrapping shell now ...'\n";
  buf+="ESH_TMP="+ESH_TMP+";";
  buf+="t=$ESH_TMP;";
  buf+="[ ! -d $t ] && mkdir $t && chmod 1777 $t;";
  // function _esh_l: load the cached file and eval it
  // arg 1: cache file name
  // optional arg 2: if non-blank, cat the file instead of eval-ing
  buf+='_esh_l() { ' +
    'local f p c;' +
    'f=$1;' +
    'o="openssl enc -a -aes256 -pass pass:$(_esh_b pw ${f/*.})";' +
    // try to use the cached file first ...
    '[ -f $f ] && c="$($o -d -in $f 2>/dev/null)" || ' +
    // cached file does not exist or is expired, so re-cache it
    '{ c="$(_esh_b zup ${f/*.})"; echo "$c" | $o >$f; chmod 666 $f; };' +
    //'echo "c:<<$c>>" >&2;' +
    '[ -z "$2" ] && eval "$c" || echo "$c";' +
    '};'
    ;

  buf+='_esh_l ' + esh.getCachedCoreFile() + ';';
  buf+='_esh_l ' + esh.getCachedBashrcFile() + ';';
  buf+=util.format(
    'for f in $(_esh_l %s 1); do _ES_gen_stub $t/%s.f.$f; done;',
    esh.getCachedFcnlistFile(),
    process.env.USER
    );
  buf+='_esh_init;'

  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

esh.registerHandler( "zB", function(evt,port) {
  var s=evt.socket;
  var z=esh.getZlib();
  z.pipe(s);
  z.end(esh.getBootstrapScript(port));
});

esh.registerHandler( "zup", function(evt,key) {
  console.log("upload:"+key);
  var s=evt.socket;
  var buf=esh.getSource(key);
  var z=esh.getZlib();
  z.pipe(s);
  z.end(buf);
});

esh.registerHandler( "pw", function(evt,key) {
  var s=evt.socket;
  var pw=esh.computePassword(esh.getSource(key));
  s.end(pw);
});

// one time auth token
esh.registerHandler( "otat", function(evt) {
  var s=evt.socket;
  var pw=esh.computePassword(esh.generateAuthToken());
  esh.oneTimeAuthTokens.push(pw);
  setTimeout(function() {
    esh.expireOneTimeAuthToken(pw);
  },60000);
  s.end(pw);
});

// receive clipboard data from client, and store inside clipboard
esh.registerHandler( "setCb", function(evt,key) {
  var s=evt.socket;
  var z=zlib.Gunzip();
  var buf="";
  var p = child_process.spawn("clipit", [], {stdio:['pipe',process.stdout,process.stderr]});
  p.on('exit',function() {
    //console.log("copied "+buf.length+" bytes to clipboard");
    // if small enough buffer, place into X Windows primary selection too for
    // convenience
    if (buf.length>255) return;
    var p2 = child_process.spawn("xsel", ["-i","-p"], {stdio:['pipe',process.stdout,process.stderr]});
    p2.stdin.end(buf);
  });
  s.pipe(z).pipe(p.stdin);
  // need to send back gzip'd null string, because _esh_b will be attempting to gunzip
  //var z1=esh.getZlib();
  //z1.pipe(s);
  //z1.end();
  s.end();

  z.on("data", function(chunk) {
    buf+=new String(chunk);
  });
});

// send clipboard data to client
esh.registerHandler( "zGetCb", function(evt,key) {
  var s=evt.socket;
  var p=child_process.spawn("clipit", ["-c"], {stdio:['ignore','pipe',process.stderr]});
  var z=esh.getZlib();
  p.stdout.pipe(z).pipe(s);
});

var server = net.createServer({allowHalfOpen:true}, function (socket) {
  //console.log("Connection from " + socket.remoteAddress + " at " + new Date() );
  socket.setNoDelay(true);
  // Define a little object to capture this event
  var evt = {
    socket : socket,
    getEventType : function(data) {
      var err;
      try {
        var m=new String(data).trim().split(" ");
console.log("m:"+m.join(":"));
        if (esh.oneTimeAuthTokens.indexOf(m[0])>=0) {
          esh.expireOneTimeAuthToken(m[0]);
        } else if (m[0]!=esh.authToken) {
          console.log("ERROR: unmatched auth token");
          setTimeout( function() { socket.end("bad auth token"); }, 5000 );
          return;
        }
        evt.evt_id = m[1];
        m.splice(0,2);
        // Call the handler
        esh.handlers[evt.evt_id](evt,m);
      } catch (err) {
        console.log( "EXCEPTION: data:" + data + "Message: " + err );
      }
    },
  };
  socket.once("data",evt.getEventType);
  socket.on("end", function() {
    //console.log( "END of socket" );
  });
});

server.listen(0, "localhost", null, function(e) {
  var port = server.address().port;
  esh.authToken = esh.generateAuthToken();
  console.log("esh server listening on port=%s, auth token=%s",port,esh.authToken);
  var bash = child_process.spawn("bash", ["-c",esh.getBootstrapScript(port)+"exec /bin/bash --norc --noprofile"],
  {
    stdio: 'inherit'
  });

  bash.on('exit', function (e, code) {
    console.log("shutting down esh");
    process.exit();
  });

});
