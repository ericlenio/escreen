#!/usr/bin/expect
# vim:filetype=expect
# Drop in replacement script for ssh, with helpful integrations to use bash,
# sudo, screen, and vim more effectively. Run with -help to see arguments.
#
# apt-get install tcllib
package require md5

regsub -- {.*origin/([\d\.]+).*} [exec bash -c "cd [file dirname $argv0] && git status --porcelain -b|grep '^##'"] {\1} GIT_BRANCH

if {[string length $GIT_BRANCH]==0} {
  puts "Unable to parse git branch, stop."
  exit 1
}
set env(EXPECTSSH_TMPDIR) /tmp/.expect-ssh-$GIT_BRANCH
set EXPECTSSH_TMPDIR $env(EXPECTSSH_TMPDIR)
set EXPECTSSH_MYBASHPREFS $EXPECTSSH_TMPDIR/mybashprefs.$env(USER)
# TO DO: make the profile a command line parameter
set EXPECTSSH_PROFILE [file dirname $argv0]/profile.lenio
# if stdin is not a terminal, or $EXPECT_SSH exists, then we just
# want to do regular ssh.
set overlay_test [exec bash -c {
  [ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }
  [ ! -t 0 -o -n "$EXPECT_SSH" ] && echo overlay_flag
  true
}]

if {[regexp {overlay_flag} $overlay_test]==1} {
  # overlay the expect process with ssh, effectively leaving this script
  eval overlay /usr/bin/ssh $argv
}

set spawn_out_slave_name 0
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*[m]}
set ANSI_RE_CURSOR_POSITIONING {\u001b\\\[\d+;\d+[Hf]}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}

array set MARKER {}

# EXPECTSSH_PS1_MARKER is a non-regexp marker in the normal PS1 prompt that we search for
# in certain situations to see if we need to load bash prefs. Watch that it
# works in regular bash, as well as inside a screen session because screen
# will translate many ANSI escape codes.
#
# TO DO: figure out why screen always translates "\033[9Xm" to
# "\033[3Xm\033[9Xm" for X=0..9. It won't hurt us here because the 
# marker is still in the PS1 string.
#set EXPECTSSH_PS1_MARKER {:\033[7m$\033[0m }
#set EXPECTSSH_PS1_MARKER {:\033[7m\$\033[0m }
set OS [exec uname -s]
set LOGFILE $EXPECTSSH_TMPDIR/$env(USER).log
match_max 10000
set configdir "$env(HOME)/.expect-ssh"
set rcfile "$configdir/config"
set EXPECTSSH_FUNCTIONS_DIR "$configdir/functions.d"
set is_marker_prompt 0
array set load_mybashprefs_args {}

##
##
## DEFINE ALL PROCS
##
##

#
# Optional arg is an index number, if not given then just return the regex of a
# generic marker.
proc get_marker {{idx ""}} {
  # Certain bash functions will send patterns (markers) which expect picks up
  # on to do further processing. The patterns are of the form of
  # GENERIC_MARKER.  It is required that after the pattern is sent there will
  # be a \n and then gzipped and base64 encoded data (optional), then a period
  # (not optional).
  set precision 2
  set GENERIC_MARKER_RE "~@(\[0-9]{$precision}):"
  if {[string length $idx]==0} { return $GENERIC_MARKER_RE }
  set marker [join [list ~@ [format "%0*d" $precision $idx] :] {}]
  return $marker
}

proc _ES_register_marker { marker_key handler } {
  global MARKER
  set idx [llength [array names MARKER -regexp {^(\w+)$}]]
  set MARKER($marker_key) [get_marker $idx]
  set MARKER($marker_key,idx) $idx
  set MARKER($marker_key,handler) $handler
  puts "_ES_register_marker: registered new marker $marker_key with handler: $handler idx=$idx"
}

proc _ES_run_marker_handler { marker_idx } {
  global MARKER ANSI_RE_GENERAL
  set encoded_args ""
  set decoded_args ""
  expect \n
  expect {
    -re {([^\.]*)\.} {
      append encoded_args $expect_out(1,string)
    }
    -re {([^\.]{1,255})} {
      append encoded_args $expect_out(1,string)
      exp_continue
    }
  }
  # convert all \015 back to \n
  regsub -all "\015" $encoded_args "\n" encoded_args
  # clean out any cursor movement sequences that sometimes get thrown in by screen
  regsub -all $ANSI_RE_GENERAL $encoded_args "" encoded_args

  if {[string length [string trim $encoded_args]]>0} {
    if {[catch {
      set decoded_args [exec sh -c "printf '%s' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
    } err]} {
      send_error "ERROR decoding args: $err\r\n"
      return
    }
  }

  # find the handler and run it
  foreach key [array names MARKER -regexp {^(\w+)$}] {
    if {$marker_idx == $MARKER($key,idx)} {
      set handler $MARKER($key,handler)
      catch {
        eval [list $handler $decoded_args]
      } err
      if {[string length $err]>0} {
        send_error "ERROR invoking handler $handler: $err\r\n"
      }
      return
    }
  }
  send_error "ERROR in _ES_run_marker_handler: no handler found for idx=$marker_idx\r\n"
}

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

proc compute_md5 {s} {
  return [string tolower [md5::md5 -hex $s]]
}

proc slurp_file {f} {
  set fp [open $f r]
  set file_data [read $fp]
  close $fp
  return $file_data
}

#
# User custom functions
#
proc get_scripts {} {
  global EXPECTSSH_FUNCTIONS_DIR EXPECTSSH_TMPDIR EXPECTSSH_PROFILE env
  array unset FUNCMAP
  set FUNCMAP(:remote_file) $EXPECTSSH_TMPDIR/$env(USER).FUNCMAP
  set FUNCMAP(:remote_file_prefix) $EXPECTSSH_TMPDIR/$env(USER).f.
  foreach dir [list $EXPECTSSH_FUNCTIONS_DIR $EXPECTSSH_PROFILE] {
    if { [file isdirectory $dir]==1 } {
      foreach funcname [glob -directory $dir -tails *] {
        if { $funcname eq "README" } { continue }
        set func_def [slurp_file $dir/$funcname]
        set FUNCMAP($funcname) ""
        #set FUNCMAP($funcname,file) $dir/$funcname
        set FUNCMAP($funcname,md5) [compute_md5 $func_def]
        set FUNCMAP($funcname,defn) $func_def
        #set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname.$FUNCMAP($funcname,md5)
        set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
      }
    }
  }

  array set SYSFUNCMAP [get_system_functions]
  foreach funcname [array names SYSFUNCMAP] {
    set func_def $SYSFUNCMAP($funcname)
    set FUNCMAP($funcname) ""
    set FUNCMAP($funcname,md5) [compute_md5 $func_def]
    set FUNCMAP($funcname,defn) $func_def
    set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
  }

  #
  # Find dependencies
  #
  foreach funcname [lsort [array names FUNCMAP -regexp {^\w+$}]] {
    set FUNCMAP($funcname,depends_on) [get_dependencies $funcname [array get FUNCMAP]]
  }

  return [array get FUNCMAP]
}

proc get_dependencies {funcname FUNCMAP {depends_list ""}} {
  array set FUNCMAP2 $FUNCMAP
  set depends ""
  regexp -line {^\s*#\s*depends:(.*)$} $FUNCMAP2($funcname,defn) - depends
  if {[string length $depends]>0} {
    foreach funcname2 [split $depends {,}] {
      set temp [get_dependencies $funcname2 [array get FUNCMAP2]]
      if {[string length $temp]>0} {
        lappend depends_list $temp
      }
      lappend depends_list $funcname2
    }
  }
  return $depends_list
}


#
# System level functions
#
proc get_system_functions {} {
  # EXPECTSSH_IN_SCREEN is a flag to know if current shell is (ultimately)
  # inside a screen session, and if so when ssh-ing to a new host we can update
  # the screen window title with the new hostname.
  set script {
  function signal_load_mybashprefs() {
    local marker="$(_ES_marker LOAD_MYBASHPREFS)"
    local in_screen=0
    if [ -n "$STY" -o -n "$EXPECTSSH_IN_SCREEN" ]; then in_screen=1; fi
    local CMD_ARRAY=("$@")
    local args=$(printf "EXPECT_SSH %s EXPECTSSH_IN_SCREEN {%s} CMD_ARRAY {%s}" $EXPECT_SSH "$in_screen" "$(declare -p CMD_ARRAY)")
    _ES_send_marker "$marker" "$args"
  }
  export -f signal_load_mybashprefs
}
  set FUNCMAP(signal_load_mybashprefs) $script

  set script {
  # depends:signal_load_mybashprefs
  function ssh() {
    if [ -t 1 ]; then
      signal_load_mybashprefs
      /usr/bin/ssh "$@"
      local rc=$?
      if [ "$EXPECTSSH_IN_SCREEN" = 1 -o -n "$STY" ]; then
        printf "\033k${HOSTNAME}\033\134"
      fi
      return $rc
    else
      # we are in a pipeline
      /usr/bin/ssh "$@"
    fi
  }
  export -f ssh
  }
  set FUNCMAP(ssh) $script

  return [array get FUNCMAP]
}

# FIXME
proc download_default_file_handler {decoded_args} {
  array set args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
  set outfile [get_download_filename $args(default_file_name)]
  if { $outfile == "" } {
    # discontinue downloading
    send "NO\r"
  } else {
    send "y\r"
    expect -ex \n
  }
}

proc get_download_filename {default_file_name} {
  global PROMPT OS spawn_id
  set default_outfile "/tmp/$default_file_name"
  set outfile ""
  set main_spawn_id $spawn_id
  set bashscript {function get_download_file() {
    read -e -p 'Save downloaded file to (leave blank to cancel): ' f
    if [ -z "$f" ]; then return; fi
    if [ -e "$f" -a ! -w "$f" ]; then echo "$f is not writable"; return; fi
    local dir=$(dirname "$f")
    if [ -z "$dir" ]; then dir=$(pwd); fi
    if [ ! -e "$f" -a ! -w "$dir" ]; then echo "Directory $dir is not writable"; return; fi
    echo "File will be downloaded to: $f"
    }
    get_download_file
  }
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  expect ": "
  send $default_outfile
  interact {
    -o -nobuffer -re "File will be downloaded to: (.*)\r" {
      set outfile $interact_out(1,string)
    }
  }
  set spawn_id $main_spawn_id
  return $outfile
}

#
# Upload a local file to the remote session.
#
proc upload_file {} {
  global PROMPT OS spawn_id
  set bashscript {function get_upload_file() {
    local f
    local yn
    read -e -p 'Choose a file to be uploaded: ' f
    # canonicalize f: must do tilde expansion
    f=${f/#~/$HOME}
    if [ ! -e "$f" ]; then
      echo "Error: no such file, or file is not readable: $f"
      return 1
    fi
    read -p "Confirm: upload \"$f\" (y/n, default y): " yn
    [ -z "$yn" ] && yn=y
    [ "$yn" != y ] && return
    echo "File to be uploaded: $f"
    local outfile=/tmp/$(basename "$f")
    echo "Will be uploaded to: $outfile"
    }
    # execute the function
    get_upload_file
  }
  set main_spawn_id $spawn_id
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  set upload_file ""
  interact {
    -o -nobuffer -re "File to be uploaded: (.*)\r\nWill be uploaded to: (.*)\r" {
      set upload_file $interact_out(1,string)
      set outfile $interact_out(2,string)
    }
  }
  set spawn_id $main_spawn_id
  if { [file exists $upload_file] == 0 } {
    return
  }
  # Delimit the input with a space, and after each line is sent send \r so
  # the terminal does not scroll
  send " \[ -e \"$outfile\" -a ! -w \"$outfile\" ] && echo '$outfile is not writable, aborting upload.'\r"
  expect {
    -re "\n.*aborting" {
      return
    }
    -re $PROMPT
  }
  send " exec 3> >(/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\")\r"
  send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&3; printf "\015"; done; exec 3>&-}
  send \r
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set upload_file_enc [exec "bash" "-c" "gzip -9 -c \"$upload_file\" | openssl enc -base64"]
  set c_len [string length $upload_file_enc]
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$upload_file_enc\n"] {
    send "[string trimright $line] "
    expect -re "\x0d$"
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    set precision [string length $c_len]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload to $outfile\r\n"
  send ". "
  expect ". "
  log_user 1
  expect -re $PROMPT
}

proc download_data_handler {outfile encoded_data} {
  set l -1
  if { [catch {
    set chan [open "|/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\"" w]
    fconfigure $chan -translation binary -encoding binary
    puts $chan $encoded_data
    flush $chan
    close $chan
    set l [file size $outfile]
    send_user "DONE...downloaded to $outfile, $l bytes"
    } err] } {
    send_error "ERROR in proc download: $err"
  }
  return $l
}

proc load_mybashprefs_handler {decoded_args} {
  global load_mybashprefs_args
  #
  # We have a request to load bash prefs into the current shell, but we
  # only do that under certain conditions below. For example, "ssh
  # localhost uname" should NOT trigger loading bash prefs, but "ssh
  # localhost" should.
  #
  array set load_mybashprefs_args $decoded_args
}

proc load_mybashprefs {EXPECT_SSH {nest_level 0}} {
  global PROMPT ANSI_RE_TEXT_FORMATTING EXPECTSSH_PS1_MARKER EXPECTSSH_TMPDIR MYBASHPREFS_PASSWORD
  global MARKER EXPECTSSH_MYBASHPREFS EXPECTSSH_PROFILE
  log_user 1
  # TO DO: verify we are in bash
  #send " echo 'test for bash'\r"
  #expect {
    #-re "\ntest for bash\r.*$PROMPT" {}
    #timeout {
      #send_error "timeout in load_mybashprefs while testing for bash\n"
      #return
    #}
  #}
  array set FUNCMAP [get_scripts]

  set mybashprefs "export EXPECTSSH_TMPDIR=$EXPECTSSH_TMPDIR\n"
  append mybashprefs "export EXPECTSSH_PS1_MARKER='$EXPECTSSH_PS1_MARKER'\n"
  append mybashprefs "export EXPECTSSH_PROFILE=$EXPECTSSH_PROFILE\n"

  append mybashprefs "function _ES_marker() {\n"
  append mybashprefs "local MARKER\n"
  append mybashprefs "declare -A MARKER=("
  foreach marker_name [array names MARKER -regexp {^(\w+)$}] {
    append mybashprefs "\[$marker_name]=$MARKER($marker_name) "
  }
  append mybashprefs ")\n"
  append mybashprefs {echo ${MARKER[$1]}}
  append mybashprefs "\n}\n"
  append mybashprefs "export -f _ES_marker\n"

  ## see if previous command in history was the line to decode bashprefs, and if so delete it from history
  #append mybashprefs {history -p '!!'|grep -q ^' c=' && TMP=$(history|tail -1|awk '{print $1}') && history -d $TMP && unset TMP}
  #append mybashprefs \n
  #append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  ## NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  ## otherwise the line spacing gets all weird when typing out long bash commands
  #append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $EXPECTSSH_PS1_MARKER [join { {\[} {\0} {\]} } {}]]
  #append mybashprefs "'\n"

  append mybashprefs {function _ES_source_script() {
  local script=$1
  if [ ! -e "$script" ]; then
    echo "No such file"
    return
  fi
  local c
  c="$(openssl enc -a -d -aes256 -in $script)" && eval "$c"
}
export -f _ES_source_script

#
# Receive a file on the remote end
#
function _ES_rec_rem() {
  local remote_file="$1"
  local pass="$2"
  local l
  if [ ! -e $remote_file ]; then
    touch $remote_file
    chmod 666 $remote_file
  fi
  exec 3< <(echo "$pass")
  # Delimit the input with a space, and after each line is sent send \r so the
  # terminal does not scroll
  exec 4> >(openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out $remote_file)
  while true; do
    read -d' ' l
    [ "$l" = . ] && break
    printf "%s\n" $l >&4
    printf "\015"
  done
  exec 3<&- 4>&-
}
export -f _ES_rec_rem

#
# The first time a user custom function runs, it goes through this function
# because just before this is called, the real function was dynamically
# generated and now we need to run it.
#
function _ES_lf() {
  local funcname=$1
  echo "$EXPECTSSH_LOADED_FUNCS" | grep -q -w $funcname || {
    [ -n "$EXPECTSSH_LOADED_FUNCS" ] && EXPECTSSH_LOADED_FUNCS+=" "
    EXPECTSSH_LOADED_FUNCS+=$funcname
  }
  export EXPECTSSH_LOADED_FUNCS
  if [ -n "$2" ]; then
    local args
    eval $(echo "$2"|openssl enc -d -base64|gzip -d -c)
    $funcname "${args[@]}"
  fi
}
export -f _ES_lf

#
# Send a marker, with arguments.
#
function _ES_send_marker() {
  local marker="$1"
  local args=$(echo -n "$2"|gzip -9 -c|openssl enc -base64)
  local l
  # pass a \010 (backspace) character to erase last character of the pattern so
  # that expect-ssh only processes this signal 1 time ... else when inside
  # screen it would potentially get re-executed from a resumed session.
  printf "%s\010.\n" "$marker"
  printf "$args" | {
    while IFS=$'\n' read -r l || [ -n "$l" ]; do
      printf "%s\015" $l
    done
  }
  # send terminating period for the pattern to match
  printf ".\n"
}
export -f _ES_send_marker

}
  #
  # _ES_stub_fcn generates a stub function for each user's custom function.
  #
  set stub_flag "_ES_stub_flag"
  append mybashprefs "function _ES_stub_fcn() { local stub_flag=$stub_flag; local marker=\$(_ES_marker UPLOAD_SCRIPT)\n"
  append mybashprefs {local funcname=$1
  if [ -z "$(declare -F $funcname)" ]; then
    local f="function $funcname() { local funcname=$funcname; local marker=$marker;"
    f+="local stub_flag=$stub_flag;"
    f+='local args=("$@");'
    f+='local args_enc=$(declare -p args|gzip -9 -c|openssl enc -base64);'
    f+='local args2=$(echo "funcname $funcname args {$args_enc}");'
    f+="unset -f $funcname;"
    f+='_ES_send_marker "$marker" "$args2";'
    f+='}'
    eval $f
    export -f $funcname
    unalias $funcname 2>/dev/null
    echo "generated stub function: $funcname"
  else
    echo "skip generating stub for $funcname: function already exists"
  fi
}
  append mybashprefs "}; export -f _ES_stub_fcn\n"
  #
  # _ES_is_stub_fcn: detect if given funcname is a stub function
  #
  append mybashprefs "function _ES_is_stub_fcn() { local stub_flag=$stub_flag\n"
  append mybashprefs {local funcname=$1
    declare -f $funcname | grep -q $stub_flag && echo 1 || echo 0
  }
  append mybashprefs "}; export -f _ES_is_stub_fcn\n"

  #
  # escape the regex for the PS1 marker
  append mybashprefs {function _ES_eps1m() {
    echo "$EXPECTSSH_PS1_MARKER"|perl -pe 's{(\\033\[[^a-zA-Z]*[a-zA-Z])}{\\[$1\\]}g'
    }
    export -f _ES_eps1m
  }

  set bashrc $EXPECTSSH_PROFILE/.bashrc
  if {[file exists $bashrc]} {
    append mybashprefs "function _ES_bashrc() {\n"
    append mybashprefs [slurp_file $bashrc]
    append mybashprefs "}\n"
    append mybashprefs "export -f _ES_bashrc\n"
    append mybashprefs "_ES_bashrc\n"
  }
  # unset $c, set below
  append mybashprefs "unset c\n"
  # set EXPECT_SSH, this must be the last part of mybashprefs, as we paste the
  # value for EXPECT_SSH below in the send statement
  append mybashprefs "export EXPECT_SSH="
  set mybashprefs [strip_comments $mybashprefs]

  set mybashprefs_hash [compute_md5 $mybashprefs]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change. Md5 the result for shorter version of password.
  set pass [compute_md5 $MYBASHPREFS_PASSWORD-$mybashprefs_hash]
  send " c=\"\$(openssl enc -a -d -aes256 -in $EXPECTSSH_MYBASHPREFS)\" && eval \"\${c}$EXPECT_SSH\"\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file or directory).*$PROMPT" {
      if { $nest_level > 0 } {
        # do not get in recursive loop attempting to upload + write out bash prefs
        return "NOT OK"
      }
      # compress all the bash commands, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk ... but watch out if this base64 string exceeds 4096 bytes (1024
      # for mac) which seems to be the terminal driver limit
      # (http://expect.sourceforge.net/FAQ.html#q76) "terminal input queue"
      # "typeahead buffer" MAX_INPUT
      # "getconf -a|grep MAX_INPUT" may help determine this value
      send "TMP=\$(history|tail -1|awk '{print \$1}') && history -d \$TMP && history -d \$((\$TMP-1)) && HISTCONTROL=ignoreboth:erasedups && unset TMP\r"
      expect -re $PROMPT
      send " \[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }\r"
      expect -re $PROMPT
      #send_user "uploading $EXPECTSSH_MYBASHPREFS ...\n"
      # Note the leading space so it is not saved in bash history
      send " \[ ! -e $EXPECTSSH_MYBASHPREFS ] && { touch $EXPECTSSH_MYBASHPREFS; chmod 666 $EXPECTSSH_MYBASHPREFS; }\r"
      expect -re $PROMPT
      log_user 0
      send " exec 3< <(echo '$pass')\r"
      expect -re {(.*\r)}
      # Hide password from being displayed
      regsub {'(.*)'} $expect_out(1,string) '[regsub -all . $pass *]' echoline
      send_user $echoline\n
      log_user 1
      expect -re $PROMPT
      # Delimit the input with a space, and after each line is sent send \r so
      # the terminal does not scroll
      send " exec 4> >(openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out $EXPECTSSH_MYBASHPREFS)\r"
      send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&4; printf "\015"; done; exec 3<&- 4>&-}
      send \r
      expect -re \r\n$
      # split into manageable chunks that will not exceed terminal driver
      # buf size
      set n -1 
      log_user 0
      set mybashprefs_enc [exec "bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $mybashprefs]
      set c_len [string length $mybashprefs_enc]
      foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$mybashprefs_enc\n"] {
        send "[string trimright $line] "
        expect {
          # first time in this loop it could by \r\n
          -re "\r\n$" {}
          -re "\x0d$" {}
        }
        if { $n > -1 } { send_user \r }
        incr n [string length $line]
        set precision [string length $c_len]
        send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
      }
      send_user " ... DONE with upload\r\n"
      send ". "
      expect ". "
      log_user 1
      expect -re $PROMPT
      return [load_mybashprefs $EXPECT_SSH 1]
    }
    -re $PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT in proc load_mybashprefs"; return "NOT OK" }
  }
  #exp_internal -f /tmp/log 1

  set func_list ""
  set bootstrap_funcs ""
  foreach funcname [lsort [array names FUNCMAP -regexp {^\w+$}]] {
    append bootstrap_funcs "_ES_stub_fcn $funcname\n"
  }

  upload_and_source_script $bootstrap_funcs $FUNCMAP(:remote_file)
  return "OK"
}
### END of load_mybashprefs

proc upload_script_handler {decoded_args} {
  global PROMPT
  array set args $decoded_args
  set funcname $args(funcname)
  array set FUNCMAP [get_scripts]
  foreach dep $FUNCMAP($funcname,depends_on) {
    upload_and_source_script $FUNCMAP($dep,defn) $FUNCMAP($dep,remote_file)
    send " _ES_lf $dep\r"
    expect -re $PROMPT
  }
  upload_and_source_script $FUNCMAP($funcname,defn) $FUNCMAP($funcname,remote_file)
  send " _ES_lf $funcname \"$args(args)\"\r"
}

proc strip_comments {script} {
  return [regsub -all {(^|\n)\s*#[^\n]*\n} $script \n]
}

# Check if remote function file (i.e. bash script file) exists, and if not
# upload it. If it does exist, re-upload it if it fails md5 check.
proc upload_and_source_script { script remote_file } {
  global PROMPT MYBASHPREFS_PASSWORD EXPECT_SSH
  set script [strip_comments $script]
  set script_md5 [compute_md5 $script]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change. Md5 the result to make a shorter version of the
  # password.
  set pass [compute_md5 $MYBASHPREFS_PASSWORD-$script_md5]
  send " _ES_source_script $remote_file\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file).*$PROMPT" {
      # compress all file content, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk
      #send_user "uploading $remote_file ...\n"
      # Note the leading space so it is not saved in bash history
      send " _ES_rec_rem \"$remote_file\" \"$pass\"\r" 
      # Hide password from being displayed
      #regsub {'(.*)'} $expect_out(1,string) '[regsub -all . $pass *]' echoline
      #send_user $echoline\n
      #log_user 1
      
      expect -re \r\n$
      # split into manageable chunks that will not exceed terminal driver
      # buf size
      set n -1 
      log_user 0
      set remote_file_content_enc [exec "bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $script]
      set c_len [string length $remote_file_content_enc]
      foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$remote_file_content_enc\n"] {
        send "[string trimright $line] "
        expect {
          # first time in this loop it could by \r\n
          -re "\r\n$" {}
          -re "\x0d$" {}
        }
        if { $n > -1 } { send_user \r }
        incr n [string length $line]
        set precision [string length $c_len]
        send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
      }
      send_user " ... DONE with upload\r\n"
      send ". "
      expect ". "
      log_user 1
      expect -re $PROMPT
      return [upload_and_source_script $script $remote_file]
    }
    -re $PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT in proc upload_and_source_script:<$script>\n\r"; return "NOT OK" }
  }
}

# See if the custom prompt is in effect
proc check_prompt_marker {arr} {
  global is_marker_prompt EXPECTSSH_PS1_MARKER
  upvar $arr arr_ref
  set marker {*}$EXPECTSSH_PS1_MARKER
  if { [info exists arr_ref(2,string)]==1 && [string trim $arr_ref(2,string)]==$marker } {
    set is_marker_prompt 1
  } else {
    set is_marker_prompt 0
  }
  return $is_marker_prompt
}

proc main_prompt_checker {arr} {
  global stdin_buf interact_out expect_out load_mybashprefs_args PROMPT
  set stdin_buf ""
  if { [array size load_mybashprefs_args] > 0 } {
    if { [check_prompt_marker $arr] == 0 } {
      set rc [load_mybashprefs [expr $load_mybashprefs_args(EXPECT_SSH) + 1]]
      if { $rc == "OK" } {
        if { [info exists load_mybashprefs_args(EXPECTSSH_IN_SCREEN)] > 0 && $load_mybashprefs_args(EXPECTSSH_IN_SCREEN)==1 } {
          send " export EXPECTSSH_IN_SCREEN=1 && "
          send {printf "\033k${HOSTNAME}\033\134"}
          send \r
          expect -re $PROMPT
        }
        if { [info exists load_mybashprefs_args(CMD_ARRAY)] > 0
          && $load_mybashprefs_args(CMD_ARRAY) != "declare -a CMD_ARRAY='()'"
          && [string length $load_mybashprefs_args(CMD_ARRAY)]>0
          } {
          send " $load_mybashprefs_args(CMD_ARRAY) && "
          send {eval "${CMD_ARRAY[@]}"}
          send \r
        }
      }
    }
  }
  array unset load_mybashprefs_args
}

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env LOGFILE PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(EXPECT_SSH)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      # truncate the file first
      close [open $LOGFILE "w"]
      exp_internal -f $LOGFILE 0
      send_user "DEBUG MODE: sending output for this session to $LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } elseif { $stdin_buf == "~u" } {
    upload_file
    set stdin_buf ""
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

##
##
## END OF PROCS
##
##

#
# Register some core handlers
#
_ES_register_marker LOAD_MYBASHPREFS load_mybashprefs_handler
_ES_register_marker UPLOAD_SCRIPT upload_script_handler
_ES_register_marker DOWNLOAD_DEFAULT_FILE download_default_file_handler
_ES_register_marker DOWNLOAD_DATA download_data_handler

if {[file exists $rcfile]} {
  source $rcfile
}

foreach expfile [lsort [glob -directory $EXPECTSSH_PROFILE *.exp]] {
  source $expfile
}

set PROMPT "(?:"
append PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append PROMPT "|"
append PROMPT "([regsub -all {([\[])} $EXPECTSSH_PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT ")"

if {[info exists env(EXPECT_SSH)] == 1} {
  set env(EXPECT_SSH) [expr $env(EXPECT_SSH) + 1]
} else {
  set env(EXPECT_SSH) 0
}
#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set local_shell_only 0
set stdin_buf ""
set argv2 {}
foreach arg $argv {
  if { $arg == "-help" } {
    puts "This is ssh-expect, an ssh wrapper to make things"
    puts "easier when ssh-ing to multiple hosts, and sudo-ing"
    puts "to multiple users. Options:"
    puts "  -help   this help menu"
    puts "  -shell  don't ssh but instead run a local bash shell"
    puts "All other arguments are passed directly to ssh."
    puts "While inside any session, type these at a prompt:"
    puts "  ~d      toggle debug mode (writes to $LOGFILE)"
    puts "  ~i      load bash functions/preferences"
    puts "  ~k      kill expect: useful if running screen, and you"
    puts "          want to resume screen from another desktop"
    puts "Upon starting, Expect statements can be placed in"
    puts "$rcfile and they get sourced."
    exit
  }
  if { $arg == "-local_shell_only" || $arg == "-shell" } {
    set local_shell_only 1
  } elseif { $arg == "-debug" } {
    # truncate the file first
    close [open $LOGFILE "w"]
    exp_internal -f $LOGFILE 0
    send_user "DEBUG MODE: sending output for this session to $LOGFILE\n"
  } else {
    lappend argv2 "$arg"
  }
}

trap { resize_handler } WINCH

if { $local_shell_only == 1 } {
  eval [list spawn -noecho] /bin/bash
} else {
  eval [list spawn -noecho] /usr/bin/ssh $argv2
}
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)
# force-resize: needed if on Mac in terminal full screen mode
resize_handler
load_mybashprefs $env(EXPECT_SSH)
set marker_re (?:\x07|\n|\r)[get_marker]

interact {
  # "If two or more patterns can match the same output, only one action will
  # be executed. The action corresponds to the pattern that appears first in
  # the command."
  -re "." { process_keystroke $interact_out(0,string) }
  # "All the patterns before the -o apply to the user keystrokes. All the
  # patterns after the -o apply to the spawned process."
  -o
  -nobuffer -re $PROMPT { main_prompt_checker interact_out }
  -nobuffer -re $marker_re {
    set marker_idx $interact_out(1,string)
    _ES_run_marker_handler $marker_idx
  }
}
