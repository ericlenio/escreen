#!/usr/bin/expect
# vim:filetype=expect
# Drop in replacement script for ssh, with helpful integrations to use bash,
# sudo, screen, and vim more effectively. Run with -help to see arguments.
#
# apt-get install tcllib
package require md5

set env(EXPECTSSH_TMPDIR) /tmp/.expect-ssh-1.1
set EXPECTSSH_TMPDIR $env(EXPECTSSH_TMPDIR)
set EXPECTSSH_PROFILE [file dirname $argv0]/profile.lenio
# if stdin is not a terminal, or $EXPECT_SSH exists, then we just
# want to do regular ssh.
set overlay_test [exec bash -c {
  [ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }
  [ ! -t 0 -o -n "$EXPECT_SSH" ] && echo overlay_flag
  true
}]

if {[regexp {overlay_flag} $overlay_test]==1} {
  # overlay the expect process with ssh, effectively leaving this script
  eval overlay /usr/bin/ssh $argv
}

set spawn_out_slave_name 0
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*[m]}
set ANSI_RE_CURSOR_POSITIONING {\u001b\\\[\d+;\d+[Hf]}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}

# Certain bash functions will send patterns (markers) which expect picks up on
# to do further processing. The patterns are of the form of GENERIC_MARKER.  It
# is required that after the pattern is sent there will be a \n and then
# gzipped and base64 encoded data (optional), then a period (not optional).
set GENERIC_MARKER "~@(\[0-9]\[0-9]):"
array set MARKER {
  LOAD_MYBASHPREFS 01
  COPY_TO_CLIPBOARD 02
  DOWNLOAD_DEFAULT_FILE 03
  DOWNLOAD_DATA 04
  LDSUPPORT_PW 05
  UPLOAD_SCRIPT 07
}

proc get_marker {marker_type} {
  global GENERIC_MARKER MARKER
  return [regsub $GENERIC_MARKER ~@00: "~@$MARKER($marker_type):"]
}

set LOAD_MYBASHPREFS_MARKER [get_marker LOAD_MYBASHPREFS]
set COPY_TO_CLIPBOARD_MARKER [get_marker COPY_TO_CLIPBOARD]
set DOWNLOAD_DEFAULT_FILE_MARKER [get_marker DOWNLOAD_DEFAULT_FILE]
set DOWNLOAD_DATA_MARKER [get_marker DOWNLOAD_DATA]
set LDSUPPORT_PW_MARKER [get_marker LDSUPPORT_PW]
set UPLOAD_SCRIPT_MARKER [get_marker UPLOAD_SCRIPT]

# PS1_MARKER is a non-regexp marker in the normal PS1 prompt that we search for
# in certain situations to see if we need to load bash prefs. Watch that it
# works in regular bash, as well as inside a screen session because screen
# will translate many ANSI escape codes.
#
# TO DO: figure out why screen always translates "\033[9Xm" to
# "\033[3Xm\033[9Xm" for X=0..9. It won't hurt us here because the 
# marker is still in the PS1 string.
#set PS1_MARKER {:\033[7m$\033[0m }
set PS1_MARKER {:\033[7m\$\033[0m }
#set PROMPT "($ANSI_RE_TEXT_FORMATTING)*(?::(?:$ANSI_RE_TEXT_FORMATTING))*(#|\\\$)($ANSI_RE_TEXT_FORMATTING)* $"
set PROMPT "(?:"
append PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append PROMPT "|"
#append PROMPT "([regsub -all {([\$\[])} $PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT "([regsub -all {([\[])} $PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT ")"
set OS [exec uname -s]
set LD_SUPPORT_BASIC_AUTH secret

set configdir "$env(HOME)/.expect-ssh"
set rcfile "$configdir/config"
if {[file exists $rcfile]} {
  source $rcfile
}
set EXPECTSSH_FUNCTIONS_DIR "$configdir/functions.d"

if {[info exists env(EXPECT_SSH)] == 1} {
  set env(EXPECT_SSH) [expr $env(EXPECT_SSH) + 1]
} else {
  set env(EXPECT_SSH) 0
}

set CTRL_Z \032
set LOGFILE "/tmp/ssh.log"
match_max 10000

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

proc compute_md5 {s} {
  return [string tolower [md5::md5 -hex $s]]
}

proc slurp_file {f} {
  set fp [open $f r]
  set file_data [read $fp]
  close $fp
  return $file_data
}

#
# User custom functions
#
proc get_scripts {} {
  global EXPECTSSH_FUNCTIONS_DIR EXPECTSSH_TMPDIR EXPECTSSH_PROFILE env
  #global UPLOAD_SCRIPT_MARKER
  array unset FUNCMAP
  set FUNCMAP(:remote_file) $EXPECTSSH_TMPDIR/$env(USER).FUNCMAP
  set FUNCMAP(:remote_file_prefix) $EXPECTSSH_TMPDIR/$env(USER).f.
  foreach dir [list $EXPECTSSH_FUNCTIONS_DIR $EXPECTSSH_PROFILE] {
    if { [file isdirectory $dir]==1 } {
      foreach funcname [glob -directory $dir -tails *] {
        set func_def [slurp_file $dir/$funcname]
        set FUNCMAP($funcname) ""
        #set FUNCMAP($funcname,file) $dir/$funcname
        set FUNCMAP($funcname,md5) [compute_md5 $func_def]
        set FUNCMAP($funcname,defn) $func_def
        #set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname.$FUNCMAP($funcname,md5)
        set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
      }
    }
  }

  array set SYSFUNCMAP [get_system_functions]
  foreach funcname [array names SYSFUNCMAP] {
    set func_def $SYSFUNCMAP($funcname)
    set FUNCMAP($funcname) ""
    set FUNCMAP($funcname,md5) [compute_md5 $func_def]
    set FUNCMAP($funcname,defn) $func_def
    set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
  }

  #
  # Find dependencies
  #
  foreach funcname [lsort [array names FUNCMAP -regexp {^\w+$}]] {
    set FUNCMAP($funcname,depends_on) [get_dependencies $funcname [array get FUNCMAP]]
  }

  return [array get FUNCMAP]
}

proc get_dependencies {funcname FUNCMAP {depends_list ""}} {
  array set FUNCMAP2 $FUNCMAP
  set depends ""
  regexp -line {^#\s*depends:(.*)$} $FUNCMAP2($funcname,defn) - depends
  if {[string length $depends]>0} {
    foreach funcname2 [split $depends {,}] {
      set temp [get_dependencies $funcname2 [array get FUNCMAP2]]
      if {[string length $temp]>0} {
        lappend depends_list $temp
      }
      lappend depends_list $funcname2
    }
  }
  return $depends_list
}


#
# System level functions
#
proc get_system_functions {} {
  # EXPECTSSH_IN_SCREEN is a flag to know if current shell is (ultimately)
  # inside a screen session, and if so when ssh-ing to a new host we can update
  # the screen window title with the new hostname.
  set script {
  function signal_load_mybashprefs() {
    local marker="$(_ES_marker LOAD_MYBASHPREFS)"
    local in_screen=0
    if [ -n "$STY" -o -n "$EXPECTSSH_IN_SCREEN" ]; then in_screen=1; fi
    local CMD_ARRAY=("$@")
    local args=$(printf "EXPECT_SSH %s EXPECTSSH_IN_SCREEN {%s} CMD_ARRAY {%s}" $EXPECT_SSH "$in_screen" "$(declare -p CMD_ARRAY)" | gzip -9 -c | openssl enc -base64)
    # pass a \010 (backspace) character to erase last character of the pattern so
    # that expect-ssh only processes this signal 1 time ... else when inside
    # screen it would potentially get re-executed from a resumed session.
    printf "%s\010.\n%s.\n" "$marker" "$args"
  }
}
  set FUNCMAP(signal_load_mybashprefs) $script

  return [array get FUNCMAP]
}

proc _ES_register_marker { marker handler } {

}

proc _ES_run_marker_handler { marker_idx encoded_args } {
}

proc copy_to_clipboard {clipboard_data} {
  global PROMPT OS
  set max_clipboard_data_len 1000000
  set content {}
  set l 0
  log_user 1
  if { $OS == "Darwin" } {
    if {[catch {
      exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c | pbcopy" $clipboard_data
    }]} {
      send_error "ERROR: could not copy clipboard data"
    } else {
      set l [exec pbpaste | wc --bytes]
    }
  } elseif { $OS == "Linux" } {
    if {[catch {
      exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c | clipit" $clipboard_data
    }]} {
      send_error "ERROR: could not copy clipboard data"
    } else {
      set content [exec clipit -c]
      if { [string length $content] <= 255 } {
        # put smaller clipboards in the X windows primary selection for convenience
        exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c | xsel -i -p" $clipboard_data
      }
    }
    set l [string length $content]
  } else {
    send_error "copy_to_clipboard: need handling for $OS"
    return
  }
  send_user "DONE...$l bytes copied to the clipboard"
  return $l
}

proc get_download_filename {default_file_name} {
  global PROMPT OS spawn_id
  set default_outfile "/tmp/$default_file_name"
  set outfile ""
  set main_spawn_id $spawn_id
  set bashscript {function get_download_file() {
    read -e -p 'Save downloaded file to (leave blank to cancel): ' f
    if [ -z "$f" ]; then return; fi
    if [ -e "$f" -a ! -w "$f" ]; then echo "$f is not writable"; return; fi
    local dir=$(dirname "$f")
    if [ -z "$dir" ]; then dir=$(pwd); fi
    if [ ! -e "$f" -a ! -w "$dir" ]; then echo "Directory $dir is not writable"; return; fi
    echo "File will be downloaded to: $f"
    }
    get_download_file
  }
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  expect ": "
  send $default_outfile
  interact {
    -o -nobuffer -re "File will be downloaded to: (.*)\r" {
      set outfile $interact_out(1,string)
    }
  }
  set spawn_id $main_spawn_id
  return $outfile
}

#
# Upload a local file to the remote session.
#
proc upload_file {} {
  global PROMPT OS spawn_id
  set bashscript {function get_upload_file() {
    local f
    local yn
    read -e -p 'Choose a file to be uploaded: ' f
    # canonicalize f: must do tilde expansion
    f=${f/#~/$HOME}
    if [ ! -e "$f" ]; then
      echo "Error: no such file, or file is not readable: $f"
      return 1
    fi
    read -p "Confirm: upload \"$f\" (y/n, default y): " yn
    [ -z "$yn" ] && yn=y
    [ "$yn" != y ] && return
    echo "File to be uploaded: $f"
    local outfile=/tmp/$(basename "$f")
    echo "Will be uploaded to: $outfile"
    }
    # execute the function
    get_upload_file
  }
  set main_spawn_id $spawn_id
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  set upload_file ""
  interact {
    -o -nobuffer -re "File to be uploaded: (.*)\r\nWill be uploaded to: (.*)\r" {
      set upload_file $interact_out(1,string)
      set outfile $interact_out(2,string)
    }
  }
  set spawn_id $main_spawn_id
  if { [file exists $upload_file] == 0 } {
    return
  }
  # Delimit the input with a space, and after each line is sent send \r so
  # the terminal does not scroll
  send " \[ -e \"$outfile\" -a ! -w \"$outfile\" ] && echo '$outfile is not writable, aborting upload.'\r"
  expect {
    -re "\n.*aborting" {
      return
    }
    -re $PROMPT
  }
  send " exec 3> >(/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\")\r"
  send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&3; printf "\015"; done; exec 3>&-}
  send \r
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set upload_file_enc [exec "bash" "-c" "gzip -9 -c \"$upload_file\" | openssl enc -base64"]
  set c_len [string length $upload_file_enc]
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$upload_file_enc\n"] {
    send "[string trimright $line] "
    expect -re "\x0d$"
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    set precision [string length $c_len]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload to $outfile\r\n"
  send ". "
  expect ". "
  log_user 1
  expect -re $PROMPT
}

proc download {outfile encoded_data} {
  set l -1
  if { [catch {
    set chan [open "|/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\"" w]
    fconfigure $chan -translation binary -encoding binary
    puts $chan $encoded_data
    flush $chan
    close $chan
    set l [file size $outfile]
    send_user "DONE...downloaded to $outfile, $l bytes"
    } err] } {
    send_error "ERROR in proc download: $err"
  }
  return $l
}

proc load_mybashprefs {EXPECT_SSH {nest_level 0}} {
  global PROMPT ANSI_RE_TEXT_FORMATTING PS1_MARKER EXPECTSSH_TMPDIR MYBASHPREFS_PASSWORD
  global LOAD_MYBASHPREFS_MARKER COPY_TO_CLIPBOARD_MARKER DOWNLOAD_DEFAULT_FILE_MARKER DOWNLOAD_DATA_MARKER
  global LDSUPPORT_PW_MARKER UPLOAD_SCRIPT_MARKER
  global MARKER
  log_user 1
  # verify we are in bash
  #send " echo 'test for bash'\r"
  #expect {
    #-re "\ntest for bash\r.*$PROMPT" {}
    #timeout {
      #send_error "timeout in load_mybashprefs while testing for bash\n"
      #return
    #}
  #}
  set mybashprefs_file $EXPECTSSH_TMPDIR/.mybashprefs
  array set FUNCMAP [get_scripts]
  set mybashprefs "export EXPECTSSH_TMPDIR=$EXPECTSSH_TMPDIR\n"

  append mybashprefs "function _ES_marker() {\n"
  append mybashprefs "local MARKER\n"
  foreach marker_name [array names MARKER] {
    set marker [get_marker $marker_name]
    append mybashprefs "MARKER\[$marker_name]='$marker'\n"
  }
  append mybashprefs {echo ${MARKER[$1]}}
  append mybashprefs "\n}\n"
  append mybashprefs "export -f _ES_marker\n"

  append mybashprefs "export HISTCONTROL=ignoreboth:erasedups\n"
  # see if previous command in history was the line to decode bashprefs, and if so delete it from history
  append mybashprefs {history -p '!!'|grep -q ^' c=' && TMP=$(history|tail -1|awk '{print $1}') && history -d $TMP && unset TMP}
  append mybashprefs \n
  append mybashprefs "export MYBASHPREFS_FILE=$mybashprefs_file\n"
  append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  # NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  # otherwise the line spacing gets all weird when typing out long bash commands
  append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $PS1_MARKER [join { {\[} {\0} {\]} } {}]]
  append mybashprefs "'\n"

  append mybashprefs {function _ES_source_script() {
  local script=$1
  if [ ! -e "$script" ]; then
    echo "No such file"
    return
  fi
  local c
  c="$(openssl enc -a -d -aes256 -in $script)" && eval "$c"
}
export -f _ES_source_script

#
# Receive a file on the remote end
#
function _ES_rec_rem() {
  local remote_file="$1"
  local pass="$2"
  local l
  if [ ! -e $remote_file ]; then
    touch $remote_file
    chmod 666 $remote_file
  fi
  exec 3< <(echo "$pass")
  # Delimit the input with a space, and after each line is sent send \r so the
  # terminal does not scroll
  exec 4> >(openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out $remote_file)
  while true; do
    read -d' ' l
    [ "$l" = . ] && break
    printf "%s\n" $l >&4
    printf "\015"
  done
  exec 3<&- 4>&-
}
export -f _ES_rec_rem

#
# The first time a user custom function runs, it goes through this function
# because just before this is called, the real function was dynamically
# generated and now we need to run it.
#
function _ES_lf() {
  local funcname=$1
  echo "$EXPECTSSH_LOADED_FUNCS" | grep -q -w $funcname || {
    [ -n "$EXPECTSSH_LOADED_FUNCS" ] && EXPECTSSH_LOADED_FUNCS+=" "
    EXPECTSSH_LOADED_FUNCS+=$funcname
  }
  export EXPECTSSH_LOADED_FUNCS
  if [ -n "$2" ]; then
    local args
    eval "$(echo $2|openssl enc -d -base64|gzip -d -c)"
    $funcname "${args[@]}"
  fi
}
export -f _ES_lf

}
  #
  # _ES_stub_fcn generates a stub function for each user's custom function.
  #
  set stub_flag "_ES_stub_flag"
  append mybashprefs "function _ES_stub_fcn() { local stub_flag=$stub_flag; local marker=$UPLOAD_SCRIPT_MARKER\n"
  append mybashprefs {local funcname=$1
  if [ -z "$(declare -F $funcname)" ]; then
    local f="function $funcname() { local funcname=$funcname; local marker=$marker;"
    f+="local stub_flag=$stub_flag;"
    f+='local args=("$@");'
    f+='local args_enc="$(typeset -p args|gzip -9 -c|openssl enc -base64 -A)";'
    f+='local args2="$(echo funcname $funcname args {$args_enc}|gzip -9 -c|openssl enc -base64)";'
    f+='printf "%s\010.\n%s.\n" "$marker" "$args2";'
    f+='}'
    eval $f
    unalias $funcname 2>/dev/null
    echo "generated stub function: $funcname"
  else
    echo "skip generating stub for $funcname: function already exists"
  fi
}
  append mybashprefs "}; export -f _ES_stub_fcn\n"
  #
  # _ES_is_stub_fcn: detect if given funcname is a stub function
  #
  append mybashprefs "function _ES_is_stub_fcn() { local stub_flag=$stub_flag\n"
  append mybashprefs {local funcname=$1
    declare -f $funcname | grep -q $stub_flag && echo 1 || echo 0
  }
  append mybashprefs "}; export -f _ES_is_stub_fcn\n"

  # unset $c, set below
  append mybashprefs "unset c\n"
  # set EXPECT_SSH, this must be the last part of mybashprefs, as we paste the
  # value for EXPECT_SSH below in the send statement
  append mybashprefs "export EXPECT_SSH="

  #exp_internal -f /tmp/log 0

  #
  set mybashprefs_hash [compute_md5 $mybashprefs]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change. Md5 the result for shorter version of password.
  set pass [compute_md5 $MYBASHPREFS_PASSWORD-$mybashprefs_hash]
  send " c=\"\$(openssl enc -a -d -aes256 -in $mybashprefs_file)\" && eval \"\${c}$EXPECT_SSH\"\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file or directory).*$PROMPT" {
      if { $nest_level > 0 } {
        # do not get in recursive loop attempting to upload + write out bash prefs
        return "NOT OK"
      }
      # compress all the bash commands, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk ... but watch out if this base64 string exceeds 4096 bytes (1024
      # for mac) which seems to be the terminal driver limit
      # (http://expect.sourceforge.net/FAQ.html#q76) "terminal input queue"
      # "typeahead buffer" MAX_INPUT
      # "getconf -a|grep MAX_INPUT" may help determine this value
      send "TMP=\$(history|tail -1|awk '{print \$1}') && history -d \$TMP && history -d \$((\$TMP-1)) && HISTCONTROL=ignoreboth:erasedups && unset TMP\r"
      expect -re $PROMPT
      send " \[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }\r"
      expect -re $PROMPT
      #send_user "uploading $mybashprefs_file ...\n"
      # Note the leading space so it is not saved in bash history
      send " \[ ! -e $mybashprefs_file ] && { touch $mybashprefs_file; chmod 666 $mybashprefs_file; }\r"
      expect -re $PROMPT
      log_user 0
      send " exec 3< <(echo '$pass')\r"
      expect -re {(.*\r)}
      # Hide password from being displayed
      regsub {'(.*)'} $expect_out(1,string) '[regsub -all . $pass *]' echoline
      send_user $echoline\n
      log_user 1
      expect -re $PROMPT
      # Delimit the input with a space, and after each line is sent send \r so
      # the terminal does not scroll
      send " exec 4> >(openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out $mybashprefs_file)\r"
      send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&4; printf "\015"; done; exec 3<&- 4>&-}
      send \r
      expect -re \r\n$
      # split into manageable chunks that will not exceed terminal driver
      # buf size
      set n -1 
      log_user 0
      set mybashprefs_enc [exec "bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $mybashprefs]
      set c_len [string length $mybashprefs_enc]
      foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$mybashprefs_enc\n"] {
        send "[string trimright $line] "
        expect {
          # first time in this loop it could by \r\n
          -re "\r\n$" {}
          -re "\x0d$" {}
        }
        if { $n > -1 } { send_user \r }
        incr n [string length $line]
        set precision [string length $c_len]
        send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
      }
      send_user " ... DONE with upload\r\n"
      send ". "
      expect ". "
      log_user 1
      expect -re $PROMPT
      return [load_mybashprefs $EXPECT_SSH 1]
    }
    -re $PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT in proc load_mybashprefs"; return "NOT OK" }
  }
  #exp_internal -f /tmp/log 1

  set func_list ""
  set bootstrap_funcs ""
  foreach funcname [lsort [array names FUNCMAP -regexp {^\w+$}]] {
    #set depends_on $FUNCMAP($funcname,depends_on)
    #if {[string length $depends_on]==0} {
      #append bootstrap_funcs "_ES_stub_fcn $funcname\n"
    #} else {
      #append bootstrap_funcs "_ES_stub_fcn $funcname '[join $depends_on { }]'\n"
    #}
    append bootstrap_funcs "_ES_stub_fcn $funcname\n"
  }

  upload_and_source_script $bootstrap_funcs $FUNCMAP(:remote_file)
  return "OK"
}
### END of load_mybashprefs

# Check if remote function file (i.e. bash script file) exists, and if not
# upload it. If it does exist, re-upload it if it fails md5 check.
proc upload_and_source_script { script remote_file } {
  global PROMPT MYBASHPREFS_PASSWORD EXPECT_SSH
  set script_md5 [compute_md5 $script]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change. Md5 the result to make a shorter version of the
  # password.
  set pass [compute_md5 $MYBASHPREFS_PASSWORD-$script_md5]
  send " _ES_source_script $remote_file\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file).*$PROMPT" {
      # compress all file content, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk
      #send_user "uploading $remote_file ...\n"
      # Note the leading space so it is not saved in bash history
      send " _ES_rec_rem \"$remote_file\" \"$pass\"\r" 
      # Hide password from being displayed
      #regsub {'(.*)'} $expect_out(1,string) '[regsub -all . $pass *]' echoline
      #send_user $echoline\n
      #log_user 1
      
      expect -re \r\n$
      # split into manageable chunks that will not exceed terminal driver
      # buf size
      set n -1 
      log_user 0
      set remote_file_content_enc [exec "bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $script]
      set c_len [string length $remote_file_content_enc]
      foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$remote_file_content_enc\n"] {
        send "[string trimright $line] "
        expect {
          # first time in this loop it could by \r\n
          -re "\r\n$" {}
          -re "\x0d$" {}
        }
        if { $n > -1 } { send_user \r }
        incr n [string length $line]
        set precision [string length $c_len]
        send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
      }
      send_user " ... DONE with upload\r\n"
      send ". "
      expect ". "
      log_user 1
      expect -re $PROMPT
      return [upload_and_source_script $script $remote_file]
    }
    -re $PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT in proc upload_and_source_script"; return "NOT OK" }
  }
}

proc bootstrap_shell {EXPECT_SSH {nest_level 0}} {
  global PROMPT EXPECTSSH_TMPDIR
  send "TMP=\$(history|tail -1|awk '{print \$1}') && history -d \$TMP && history -d \$((\$TMP-1)) && HISTCONTROL=ignoreboth:erasedups && unset TMP\r"
  expect -re $PROMPT
  send " \[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }\r"
  expect -re $PROMPT
}

set is_marker_prompt 0
# See if the custom prompt is in effect
proc check_prompt_marker {arr} {
  global is_marker_prompt PS1_MARKER
  upvar $arr arr_ref
  set marker {*}$PS1_MARKER
  if { [info exists arr_ref(2,string)]==1 && [string trim $arr_ref(2,string)]==$marker } {
    set is_marker_prompt 1
  } else {
    set is_marker_prompt 0
  }
  return $is_marker_prompt
}

array set load_mybashprefs_args {}
proc main_prompt_checker {arr} {
  global stdin_buf interact_out expect_out load_mybashprefs_args PROMPT
  set stdin_buf ""
  if { [array size load_mybashprefs_args] > 0 } {
    if { [check_prompt_marker $arr] == 0 } {
      set rc [load_mybashprefs [expr $load_mybashprefs_args(EXPECT_SSH) + 1]]
      if { $rc == "OK" } {
        if { [info exists load_mybashprefs_args(EXPECTSSH_IN_SCREEN)] > 0 && $load_mybashprefs_args(EXPECTSSH_IN_SCREEN)==1 } {
          send " export EXPECTSSH_IN_SCREEN=1 && "
          send {printf "\033k${HOSTNAME}\033\134"}
          send \r
          expect -re $PROMPT
        }
        if { [info exists load_mybashprefs_args(CMD_ARRAY)] > 0
          && $load_mybashprefs_args(CMD_ARRAY) != "declare -a CMD_ARRAY='()'"
          && [string length $load_mybashprefs_args(CMD_ARRAY)]>0
          } {
          send " $load_mybashprefs_args(CMD_ARRAY) && eval \"\${CMD_ARRAY\[@]}\"\r"
        }
      }
    }
  }
  array unset load_mybashprefs_args
}

#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set local_shell_only 0
set stdin_buf ""
set argv2 {}
foreach arg $argv {
  if { $arg == "-help" } {
    puts "This is ssh-expect, an ssh wrapper to make things"
    puts "easier when ssh-ing to multiple hosts, and sudo-ing"
    puts "to multiple users. Options:"
    puts "  -help   this help menu"
    puts "  -shell  don't ssh but instead run a local bash shell"
    puts "All other arguments are passed directly to ssh."
    puts "While inside any session, type these at a prompt:"
    puts "  ~d      toggle debug mode (writes to $LOGFILE)"
    puts "  ~i      load bash functions/preferences"
    puts "  ~k      kill expect: useful if running screen, and you"
    puts "          want to resume screen from another desktop"
    puts "Upon starting, Expect statements can be placed in"
    puts "$rcfile and they get sourced."
    exit
  }
  if { $arg == "-local_shell_only" || $arg == "-shell" } {
    set local_shell_only 1
  } elseif { $arg == "-debug" } {
    # truncate the file first
    close [open $LOGFILE "w"]
    exp_internal -f $LOGFILE 0
    send_user "DEBUG MODE: sending output for this session to $LOGFILE\n"
  } else {
    lappend argv2 "$arg"
  }
}

trap {
  resize_handler
} WINCH

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env LOGFILE PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(EXPECT_SSH)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      # truncate the file first
      close [open $LOGFILE "w"]
      exp_internal -f $LOGFILE 0
      send_user "DEBUG MODE: sending output for this session to $LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } elseif { $stdin_buf == "~u" } {
    upload_file
    set stdin_buf ""
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

proc process_ldsupport_request {ld_url enc_pass} {
  global LD_SUPPORT_BASIC_AUTH PROMPT OS
  set url https://svn.lincware.com/lw/ldsupportpw
  catch {
    set ld_support_pw [exec curl -s -H "Authorization: Basic $LD_SUPPORT_BASIC_AUTH" --data "$enc_pass" $url]
  } ld_support_pw
  expect -re $PROMPT
  if { [regexp {^[-\w]+$} $ld_support_pw] } {
    send " echo password is: $ld_support_pw\r"
    expect -re $PROMPT
    if { "$OS" == "Linux" } {
      exec sh -c "printf '%s' \"\$0\" | clipit 2>&1" $ld_support_pw
      system xdg-open $ld_url >/dev/null &
    } elseif { "$OS" == "Darwin" } {
      exec sh -c "printf '%s' \"\$0\" | pbcopy 2>&1" $ld_support_pw
      system open $ld_url &
    }
  } else {
    send_error "ERROR: could not read ldsupport password: further info: $ld_support_pw"
  }
}

if { $local_shell_only == 1 } {
  eval [list spawn -noecho] /bin/bash
} else {
  eval [list spawn -noecho] /usr/bin/ssh $argv2
}
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)
# force-resize: needed if on Mac in terminal full screen mode
resize_handler
load_mybashprefs $env(EXPECT_SSH)

interact {
  # "If two or more patterns can match the same output, only one action will
  # be executed. The action corresponds to the pattern that appears first in
  # the command."
  -re "." { process_keystroke $interact_out(0,string) }
  # "All the patterns before the -o apply to the user keystrokes. All the
  # patterns after the -o apply to the spawned process."
  -o
  -nobuffer -re $PROMPT { main_prompt_checker interact_out }
  -nobuffer -re \[\n\r]$GENERIC_MARKER {
    set marker_type $interact_out(1,string)
    set encoded_args ""
    expect \n
    expect {
      -re "(\[^\\.]*)\\." {
	append encoded_args $expect_out(1,string)
      }
      -re "(\[^\\.]{1,255})" {
	append encoded_args $expect_out(1,string)
	exp_continue
      }
    }
    # convert all \015 back to \n
    regsub -all "\015" $encoded_args "\n" encoded_args
    # clean out any cursor movement sequences that sometimes get thrown in by screen
    regsub -all $ANSI_RE_GENERAL $encoded_args "" encoded_args
    if { $marker_type == $MARKER(LOAD_MYBASHPREFS) } {
      #
      # We have a request to load bash prefs into the current shell, but we
      # only do that under certain conditions below. For example, "ssh
      # localhost uname" should NOT trigger loading bash prefs, but "ssh
      # localhost" should.
      #
      array set load_mybashprefs_args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
    } elseif { $marker_type == $MARKER(COPY_TO_CLIPBOARD) } {
      copy_to_clipboard $encoded_args
    } elseif { $marker_type == $MARKER(DOWNLOAD_DEFAULT_FILE) } {
      array set args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
      set outfile [get_download_filename $args(default_file_name)]
      if { $outfile == "" } {
	# discontinue downloading
	send "NO\r"
      } else {
	send "y\r"
	expect -ex \n
      }
    } elseif { $marker_type == $MARKER(DOWNLOAD_DATA) } {
      download $outfile $encoded_args
    } elseif { $marker_type == $MARKER(LDSUPPORT_PW) } {
      if { [catch {
        array set args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
      } err] } {
        send_error "ERROR decoding: $err\n\r"
        send_error "encoded_args=$encoded_args\n\r"
      } else {
        process_ldsupport_request $args(ld_url) $args(enc_pass)
      }
    } elseif { $marker_type == $MARKER(UPLOAD_SCRIPT) } {
      #regsub {^(\w+).*} $decoded_args {\1} funcname
      if { [catch {
        array set args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
      } err] } {
        send_error "ERROR decoding: $err\n\r"
        send_error "encoded_args=$encoded_args\n\r"
      } else {
        set funcname $args(funcname)
        array set FUNCMAP [get_scripts]
        foreach dep $FUNCMAP($funcname,depends_on) {
          send " _ES_lf $dep\r"
          expect -re $PROMPT
        }
        upload_and_source_script $FUNCMAP($funcname,defn) $FUNCMAP($funcname,remote_file)
        send " _ES_lf $funcname $args(args)\r"
      }
    } else {
      _ES_run_marker_handler $marker_type $encoded_args
    }
  }
}
