#!/bin/bash
# vim:filetype=expect
# Drop in replacement script for ssh, with helpful integrations to use bash,
# sudo, screen, and vim more effectively. Run with -help to see arguments.

if [ ! -t 0 -o -n "$SSH_EXPECT" ]; then
  exec /usr/bin/ssh "$@"
fi

export EXPECTSSH_TMPDIR=/tmp/.expect-ssh
export EXP_FILE=$EXPECTSSH_TMPDIR/ssh.expect.$USER

[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }

cat > $EXP_FILE << 'EXPECT_EOF' && exec /usr/bin/expect -c "set EXEC $(basename $0)" -f $EXP_FILE -- "$@"
# apt-get install tcllib
package require md5

file delete $env(EXP_FILE)

#set mybashprefs "$env(HOME)/.remoteadmin/bashrc"
#send_error "Running $argv0\n"
set spawn_out_slave_name 0
#exp_internal -f /tmp/ssh.log 1
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*[m]}
set ANSI_RE_CURSOR_POSITIONING {\u001b\\\[\d+;\d+[Hf]}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}
set COPY_TO_CLIPBOARD_BEGIN_RE [join {\n ~ {copy_to_clipboard:([^:]+):} } "" ]
set LOAD_MYBASHPREFS_MARKER "~@01:"
#set LOAD_MYBASHPREFS_MARKER_RE [join [ list $LOAD_MYBASHPREFS_MARKER {:([^:]+):(\d+\.\d+):(\d+)} ] ""]
#set LOAD_MYBASHPREFS_MARKER_RE [join [ list $LOAD_MYBASHPREFS_MARKER {:\r\n([^:]+):} ] ""]
set DOWNLOAD_FILE_BEGIN_RE [join { ~ {DOWNLOAD_FILE\|([^\|]+)\|([^\|]+)\|} } "" ]
set EXPECTSSH_TMPDIR $env(EXPECTSSH_TMPDIR)
# PS1_MARKER is a non-regexp marker in the normal PS1 prompt that we search for
# in certain situations to see if we need to load bash prefs. Watch that it
# works in regular bash, as well as inside a screen session because screen
# will translate many ANSI escape codes.
#
# TO DO: figure out why screen always translates "\033[9Xm" to
# "\033[3Xm\033[9Xm" for X=0..9. It won't hurt us here because the 
# marker is still in the PS1 string.
#set PS1_MARKER {:\033[7m$\033[0m }
set PS1_MARKER {:\033[7m\$\033[0m }
#set PROMPT "($ANSI_RE_TEXT_FORMATTING)*(?::(?:$ANSI_RE_TEXT_FORMATTING))*(#|\\\$)($ANSI_RE_TEXT_FORMATTING)* $"
set PROMPT "(?:"
append PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append PROMPT "|"
#append PROMPT "([regsub -all {([\$\[])} $PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT "([regsub -all {([\[])} $PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT ")"
set OS [exec uname -s]
set LD_SUPPORT_BASIC_AUTH secret

set rcfile "$env(HOME)/.expect-ssh/config"
if {[file exists $rcfile]} {
  source $rcfile
}

if {[info exists env(SSH_EXPECT)] == 1} {
  set env(SSH_EXPECT) [expr $env(SSH_EXPECT) + 1]
} else {
  set env(SSH_EXPECT) 0
}

set CTRL_Z \032
set LOGFILE "/tmp/ssh.log"
match_max 10000

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

array set clipboard_processed {}
proc copy_to_clipboard {time_of_day} {
  global PROMPT OS ANSI_RE_GENERAL clipboard_processed
  if { [info exists clipboard_processed($time_of_day)] == 1 } {
    return
  }
  set clipboard_processed($time_of_day) 1
  set clipboard_data ""
  set max_clipboard_data_len 1000000
  log_user 1
  expect {
    -re [join {"(.*)(?:\[\\r\\n](?:$ANSI_RE_GENERAL)*|^)" ~ copy_to_clipboard_EOF} ""] {
      append clipboard_data $expect_out(1,string)
      #regsub -all \000 $clipboard_data "\n" clipboard_data
      #regsub -all {\033\[\d+C} $clipboard_data "" clipboard_data
      if { $OS == "Darwin" } {
        exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c | pbcopy" $clipboard_data
      } elseif { $OS == "Linux" } {
        exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c | clipit" $clipboard_data
      } else {
        send_user "copy_to_clipboard: need handling for $OS"
        return
      }
      set l [string length $clipboard_data]
      return $l
    }
    -re "(.{1,255})" {
      append clipboard_data $expect_out(1,string)
      if { [string length $clipboard_data] > $max_clipboard_data_len } {
        # safety net: probably something is wrong
        send_user "MAX LENGTH EXCEEDED ($max_clipboard_data_len) for copy_to_clipboard"
      } else {
        exp_continue
      }
    }
    timeout { send_error "copy_to_clipboard: timeout waiting for file" }
  }
  log_user 1
}

proc get_download_filename {default_file_name} {
  global PROMPT OS
  set default_outfile "/tmp/$default_file_name"
  spawn /bin/bash
  set outfile ""
  expect -re $PROMPT
  if { "$OS" == "Linux" } {
    send " read -e -i '$default_outfile' -p 'Save downloaded file to: ' ans && echo ans=\$ans\r"
  } elseif { "$OS" == "Darwin" } {
    send " read -e -p 'Save downloaded file to: ' ans && echo ans=\$ans\r"
    expect -ex :
    send $default_outfile
  }
  interact {
    -o
    -re "\\nans=(\[^\\r\\n]*).*$PROMPT" {
      set outfile $interact_out(1,string)
      send "exit\r"
    }
  }
  return $outfile
}

array set download_processed {}
proc download {default_file_name time_of_day} {
  global PROMPT OS ANSI_RE_GENERAL download_processed
  if { [info exists download_processed($time_of_day)] == 1} {
    # This download request was already processed
    return
  }
  set download_processed($time_of_day) 1
  set outfile [get_download_filename $default_file_name]
  if { $outfile == "" } {
    # discontinue downloading
    send "NO\r"
    return
  } else {
    send "y\r"
    expect -ex \n
  }

  set data ""
  set max_clipboard_data_len 1000000
  log_user 1
  expect {
    -re "(.*)(?:\[\\r\\n](?:$ANSI_RE_GENERAL)*|^)~DOWNLOAD_FILE_EOF" {
      append data $expect_out(1,string)
      exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c > $outfile && chmod 600 $outfile" $data
      set l [file size $outfile]
      puts "downloaded to $outfile, $l bytes"
      return $l
    }
    -re "(.{1,255})" {
      append data $expect_out(1,string)
      if { [string length $data] > $max_clipboard_data_len } {
        # safety net: probably something is wrong
        send_user "MAX LENGTH EXCEEDED ($max_clipboard_data_len) for download"
      } else {
        exp_continue
      }
    }
    timeout { send_user "download: timeout waiting for file!!" }
  }
  log_user 1
}

proc paste_from_clipboard_in_vim {} {
  global OS PROMPT ANSI_RE_SHOW_CURSOR
  send ":shell\r"
  expect -re $PROMPT
  # encode the clipboard data and send it across the wire, decoding it on the
  # other end, and store it in the VIM_CLIPBOARD file.
  # Leading space before cat so as to not save it to history
  send " cat << EOF | /usr/bin/openssl enc -base64 -d | gzip -d -c > \$VIM_CLIPBOARD\r"
  expect -re "> $"
  if { "$OS" == "Linux" } {
    set buf [exec clipit -c | gzip -9 -c | /usr/bin/openssl enc -base64]
  } elseif { "$OS" == "Darwin" } {
    set buf [exec pbpaste | gzip -9 -c | /usr/bin/openssl enc -base64]
  }
  foreach line [split $buf] {
    send $line\r
    expect -re "> $"
  }
  send "EOF\r"
  expect -re $PROMPT
  send "exit\r"
  expect {
    -re $ANSI_RE_SHOW_CURSOR {}
    timeout {send_error "TIMEOUT during paste, aborting"; return}
  }
  # read the file and put it in the unnamed register
  send {:let @"=join(readfile($VIM_CLIPBOARD,"b"),"\n")}
  send "\r"
  expect {
    -re $ANSI_RE_SHOW_CURSOR {}
    timeout {send_error "TIMEOUT #2 during paste, aborting"; return}
  }
  # paste contents of unnamed register
  send "P"
}

proc load_mybashprefs {SSH_EXPECT {nest_level 0}} {
  global PROMPT ANSI_RE_TEXT_FORMATTING PS1_MARKER LOAD_MYBASHPREFS_MARKER ANSI_RE_GENERAL EXPECTSSH_TMPDIR MYBASHPREFS_PASSWORD
  log_user 1
  # verify we are in bash
  #send " echo 'test for bash'\r"
  #expect {
    #-re "\ntest for bash\r.*$PROMPT" {}
    #timeout {
      #send_error "timeout in load_mybashprefs while testing for bash\n"
      #return
    #}
  #}
  set mybashprefs_file $EXPECTSSH_TMPDIR/.mybashprefs
  set mybashprefs "export EXPECTSSH_TMPDIR=$EXPECTSSH_TMPDIR\n"
  append mybashprefs "export MYBASHPREFS_FILE=$mybashprefs_file\n"
  append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  # NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  # otherwise the line spacing gets all weird when typing out long bash commands
  append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $PS1_MARKER [join { {\[} {\0} {\]} } {}]]
  append mybashprefs "'\n"
  append mybashprefs "export LOAD_MYBASHPREFS_MARKER='" $LOAD_MYBASHPREFS_MARKER "'\n"
  append mybashprefs {unset PROMPT_COMMAND
export HISTIGNORE=' *'
export VIM_CLIPBOARD=$EXPECTSSH_TMPDIR/vim.clipboard.$USER
touch $VIM_CLIPBOARD
chmod 600 $VIM_CLIPBOARD || {
  echo "WARNING: could not chmod on $VIM_CLIPBOARD, halting."
  return
}

export VIMINIT='map <c-v> :echon "~" "paste_from_clipboard_in_vim"<cr>|vnoremap <C-c> y:call writefile(split(@","\n","b"),$VIM_CLIPBOARD)<cr>:!copy_to_clipboard $VIM_CLIPBOARD<cr>|colorscheme elflord|syntax enable|set noswapfile number hlsearch incsearch sw=2 ignorecase wrap nocompatible ruler ai showmatch modeline modelines=5 nobackup nowritebackup textwidth=0 expandtab formatoptions=croql wildignore=*.class path=.,,**|autocmd Filetype java setlocal omnifunc=javacomplete#Complete'
export EDITOR=/usr/bin/vim
export FCEDIT=$EDITOR

function copy_to_clipboard() {
  local file_to_copy="$1"
  # boundary for expect-ssh to pick up the file:
  printf "%s:%s:" "~copy_to_clipboard" $(get_time_with_millis)
  if [ -z "$file_to_copy" ]; then
    # copy stdin to clipboard
    file_to_copy="-"
  fi
  # use perl to remove the last \n on the last line, and minimally set a hyphen
  # character in the stream so as to not pass 0 bytes to clipit (which causes
  # it to block)
  perl -pe 'BEGIN{$n=0;}END{print "-" if $n==0}$n+=length($_);chomp if eof' -- "$file_to_copy" | gzip -9 -c | openssl enc -base64
  # ending boundary
  printf "~%s\n" "copy_to_clipboard_EOF"
}
export -f copy_to_clipboard

function download() {
  local file="$1"
  # boundary for expect-ssh to pick up the file:
  if [ ! -e "$file" ]; then
    echo "Error: no such file: $file"
    return
  fi
  printf "%s|%s|%s|" "~DOWNLOAD_FILE" $(basename $file) $(get_time_with_millis)
  local ans
  # Only continue if a valid download filename was picked in get_download_filename
  read -p "Continue? " ans
  if [ "$ans" != y ]; then
    return
  fi
  gzip -9 -c $file | openssl enc -base64
  # ending boundary
  printf "~%s:%s\n" "DOWNLOAD_FILE_EOF" $file
}
export -f download

function openssl_show_cert() {
  local cert=$1
  if [ -z "$cert" ]; then
    # assume stdin
    cert="-"
  fi
  openssl x509 -in $cert -noout -text
}
export -f openssl_show_cert

function openssl_s_client_showcerts() {
  local hostport="$1"
  local host=${hostport%%:[0-9]*}
  local port=${hostport##*:}
  if [ "$host" = "$hostport" -o "$port" = "$hostport" ]; then
    echo "Usage: ${FUNCNAME[0]} host.example.com:port"
    return
  fi
  echo | openssl s_client -showcerts -connect $host:$port
}
export -f openssl_s_client_showcerts

function pathadd() {
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="${PATH:+"$PATH:"}$1"
  fi
}

function l() {
  local os=$(uname -s)
  if [ $os = Darwin ]; then
    ls -laF "$@"
  else
    ls -laF --time-style=+'%D %H:%M:%S' "$@"
  fi
}
unalias l 2>/dev/null
export -f l

function vimf() {
  local patt="$1"
  if [ -z "$patt" ]; then
    patt="*"
  else
    patt="*$patt*"
  fi
  vim $(find . ! -type d ! -wholename '*/.svn*' ! -iregex '.*\.\(jar\|pdf\|swp\|png\|class\|jpg\|gif\)' -name "$patt")
}
export -f vimf

function pg_version() {
  # Note: just gets the major.minor version number
  sudo -u postgres psql -tAc "select version()" 2>/dev/null | perl -pe 's{^\w+\s(\d+\.\d+).*}{$1}'
}
export -f pg_version

function pg_activity() {
  local version=$(pg_version)
  local query="SELECT datname,usename,pid,client_addr,waiting,query_start,query FROM pg_stat_activity order by datname,usename,query_start"
  perl -e "exit ( $version <= 9.2 ? 0 : 1 )" && \
    query="SELECT datname,usename,procpid,client_addr,waiting,query_start,current_query FROM pg_stat_activity order by datname,usename,query_start"
  sudo -u postgres psql -c "$query"
}
export -f pg_activity

function pg_cancel_backend() {
  local procpid="$1"
  if [ -z "$procpid" ]; then
    echo "Usage: pg_cancel_backend procpid"
    return 1
  fi
  printf "select pg_cancel_backend($procpid);" | sudo -u postgres psql
}
export -f pg_cancel_backend

function pg_terminate_backend() {
  local procpid="$1"
  if [ -z "$procpid" ]; then
    echo "Usage: pg_terminate_backend procpid"
    return 1
  fi
  printf "select pg_terminate_backend($procpid);" | sudo -u postgres psql
}
export -f pg_terminate_backend

function get_time_with_millis() {
  # Mac does not support %N in date command, so use perl
  local time=$(perl -MTime::HiRes -e "printf(qq(%.3f\n),Time::HiRes::time())")
  echo -n $time
}
export -f get_time_with_millis

function signal_load_mybashprefs() {
  local time_of_day=$(get_time_with_millis)
  # Do an expression that is easily evaluated to a TCL array for args
  local args=$(printf "remote_hostname %s time_of_day %s SSH_EXPECT_CURR %s PROMPT_COMMAND {%s}" \
    $(hostname) $time_of_day $SSH_EXPECT "$PROMPT_COMMAND" | gzip -9 -c | openssl enc -base64)
  printf "%s\n%s:\n" $LOAD_MYBASHPREFS_MARKER "$args" > $(tty)
}
export -f signal_load_mybashprefs

function jargrep() {
  for f in $(find . -name '*.jar'); do
    local output=$(jar tvf $f | grep "$@")
    if [ "$output" ]; then
      echo "$f: $output"
    fi
  done
}
export -f jargrep

function rgrep() {
  find . -type f ! -wholename './build/*' ! -wholename '*/.svn*' ! -wholename '*.class' ! -wholename '*.jar' ! -wholename '*.swp' | xargs grep "$@" 2>/dev/null
}
export -f rgrep

function tomcatlog() {
  local OPTS=$(getopt -o 23ecx -- "$@")
  eval set -- "$OPTS"
  local flag=$1
  local logfile=/var/log/tomcat7/catalina.out
  local tomcat_user=tomcat7
  local op
  while true ; do
    case "$1" in
      -2) logfile=/var/log/lincdoc/catalina.out
        tomcat_user=tomcat
        shift
        ;;
      -3) logfile=/var/log/lincdoc/catalina.log
        tomcat_user=tomcat
        shift
        ;;
      -e) op=edit; shift;;
      -c) op=clear; shift;;
      -x) op=exceptions; shift;;
      --) shift ; break ;;
    esac
  done
  if [ "$op" = "edit" ]; then
    signal_load_mybashprefs
    sudo -E -H -u $tomcat_user -- /bin/bash -c "unset DISPLAY && vim -n -i NONE $logfile"
  elif [ "$op" = "clear" ]; then
    sudo truncate --no-create --size 0 $logfile
    echo "$logfile was truncated."
  elif [ "$op" = "exceptions" ]; then
    sudo -u $tomcat_user grep Exception $logfile | less
  else
    sudo -E -H -u $tomcat_user multitail -f -c $logfile
  fi
}
export -f tomcatlog

function screen() {
  local shell=$EXPECTSSH_TMPDIR/.bash.screen.$USER
  #printf 'exec /bin/bash --norc --noprofile "$@"\n' > $shell
  # why exec bash via perl here? because Mac OSX bash will munge PS1 otherwise
  printf '#!/usr/bin/perl\n' > $shell
  printf 'exec qw(/bin/bash --norc --noprofile),@ARGV;\n' >> $shell
  chmod 755 $shell
  local SCREENRC=$EXPECTSSH_TMPDIR/.screenrc.$USER
  # Set up a little macro so that ^a% will dump the current screen to a file,
  # then edit it in vim.
  local printscreen_macro=/tmp/.screenrc.$USER.printscreen
  local hardcopy_file=/tmp/.screenrc.$USER.hardcopy
  touch $SCREENRC
  export SCREENRC
  cat > $SCREENRC << 'EOF'
startup_message off
bind " " windowlist -b
vbell on
vbell_msg DING
#shelltitle "$ |bash:"
bindkey "\032" stuff "\032"
caption always "%{= kw}%-w%{= BW}%n%t%{-}%+w %-= @%H %m/%d %c"
shelltitle "$ |:"
defmonitor on
setenv PROMPT_COMMAND 'screen_prompt'
#shell $shell
#screen rm $SCREENRC
EOF
  cat >> $SCREENRC << EOF
bind % source $printscreen_macro
EOF
  cat > $printscreen_macro << EOF
hardcopy_append off
hardcopy $hardcopy_file
screen vim $hardcopy_file
EOF

  local esc='^Ee'
  if [ "$SSH_EXPECT" = 0 ]; then
    esc='^Aa'
  fi
  /usr/bin/screen -e$esc -s $shell "$@"
}
export -f screen

function s() {
  local user=$1
  if [ "$user" = "" ]; then
    user=root
  fi
  id -u "$user" >/dev/null 2>&1 || { echo "No such user \"$user\"."; return; }
  signal_load_mybashprefs
  sudo -H -u $user -- /bin/bash
}
export -f s

function screen_prompt() {
  # use printf instead of echo: works on macs
  printf "\033k${HOSTNAME}\033\134"
}
export -f screen_prompt

function get_ldsupport_pw() {
  local app_context=$1
  if [ -z "$app_context" ]; then
    app_context=lincdoc
  fi
  if [ -d /etc/lincware/lwsa ]; then
    # 3.1 or higher
    local ld_url="http://remoteadmin.lincware.com:$(sudo cat /var/run/lwsa-remoteadmin.http_port)/$app_context/login/_/system"
    #local url=https://svn.lincware.com/lw/ldsupportpw
    local cmd="$(sudo lwsa --get_psql_connect $app_context --silent) -tAc \"select config from ld_admin.ld_config_map where key = 'ldsupport-crypt-pw'\""
    #if [ "$db" ]; then
      #cmd="sudo -u postgres psql $db -tAc \"select config from ld_admin.ld_config_map where key = 'ldsupport-crypt-pw'\""
    #fi
    if [[ "$cmd" != *psql* ]]; then
      if [ -n "$app_context" ]; then
        echo "ERROR: no such app context: $app_context"
        echo "Available contexts:"
        sudo lwsa --list_app_context_ids
      else
        echo "ERROR: could not read lwsa configuration to get psql connect string."
      fi
      return
    fi
    echo $ld_url
    local enc_pass="$(eval $cmd)"
    # echo a string for expect to pick up and launch a browser session
    printf "~%s|%s|%s|%s|\n" LAUNCH_LDSUPPORT_LOGIN "$ld_url" "$enc_pass" $(get_time_with_millis)
    echo
  else
    local version=$(show-version)
    if [[ "$version" = 3* ]]; then
      local pid=$(pgrep -U remoteadmin ssh)
      if [ -n "$pid" ]; then
        ps --no-headers ww $pid | perl -pe 's{.*?\b(\d+):localhost:80\b.*}{http://remoteadmin.lincware.com:$1}'
      fi
      generate-build-properties -get lincdoc.user.ldsupport.password
    else
      # version 2.x
      local pid=$(pgrep -U sshtunnel ssh)
      if [ -n "$pid" ]; then
        ps --no-headers -ww -o user:12,pid,args $pid | perl -pe 's{.*?\b(\d+):localhost:80\b.*}{http://remoteadmin.lincware.com:$1}'
      fi
      echo "lincdoc/$(generate-build-properties -get lincdoc.ldap.password)"
    fi
  fi
}
export -f get_ldsupport_pw

function ldu() {
  perl -e'%h=map{/.\s/;99**(ord$&&7)-$`,$_}`sudo du -h`;print@h{sort%h}'
}
export -f ldu

function update_gpg_key() {
  local apt_keyring=/etc/apt/trusted.gpg
  # the old key expired 04/28/2014
  local old_key="Lincware Repository"
  local apt_lincware_key_file=/etc/apt/trusted.gpg.d/apt.lincware.com.gpg
  # To do: set http_proxy environment var if customer uses a proxy
  local new_key_url=http://apt.lincware.com/apt.lincware.com.gpg
  echo "Attempting to fetch $new_key_url now"
  local new_key_base64="$(curl --silent $new_key_url)"
  sudo -H bash -s << EOSUDO
    gpg --no-default-keyring --with-colons --list-keys --keyring $apt_keyring "$old_key" >/dev/null 2>&1 && {
      # delete old gpg key that expired on 04/28/2014
      gpg --no-default-keyring --keyring $apt_keyring --yes --batch --delete-key "$old_key"
    }
    echo "$new_key_base64" | gpg --no-default-keyring --keyring $apt_lincware_key_file --import
EOSUDO
}
export -f update_gpg_key

OLD_LD_BIN=/opt/lincdoc/trunk/product/bin
if [ -d $OLD_LD_BIN ]; then
  pathadd $OLD_LD_BIN
fi
unset OLD_LD_BIN

function ssh() {
  signal_load_mybashprefs
  /usr/bin/ssh "$@"
  return $?
}
export -f ssh

}

  # unset $c, set below
  append mybashprefs "unset c\n"
  # set SSH_EXPECT, this must be the last part of mybashprefs, as we paste the
  # value for SSH_EXPECT below in the send statement
  append mybashprefs "export SSH_EXPECT="

  #exp_internal -f /tmp/log 0

  #
  set mybashprefs_hash [string tolower [md5::md5 -hex $mybashprefs]]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change.
  set pass "$MYBASHPREFS_PASSWORD-$mybashprefs_hash"
  send " c=\"\$(openssl enc -a -d -aes256 -in $mybashprefs_file)\" && eval \"\${c}$SSH_EXPECT\"\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file or directory).*$PROMPT" {
      if { $nest_level > 0 } {
        # do not get in recursive loop attempting to upload + write out bash prefs
        return "NOT OK"
      }
      # compress all the bash commands, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk ... but watch out if this base64 string exceeds 4096 bytes (1024
      # for mac) which seems to be the terminal driver limit
      # (http://expect.sourceforge.net/FAQ.html#q76) "terminal input queue"
      # "typeahead buffer" MAX_INPUT
      # "getconf -a|grep MAX_INPUT" may help determine this value
      send "TMP=\$(history|tail -1|awk '{print \$1}') && history -d \$TMP && HISTCONTROL=ignoreboth && export HISTIGNORE=' *' && unset TMP\r"
      expect -re $PROMPT
      send " \[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }\r"
      expect -re $PROMPT
      #send_user "uploading $mybashprefs_file ...\n"
      # Note the leading space so it is not saved in bash history
      send " \[ ! -e $mybashprefs_file ] && { touch $mybashprefs_file; chmod 666 $mybashprefs_file; }\r"
      expect -re $PROMPT
      send " openssl enc -d -base64 << EOF | gzip -d -c | openssl enc -a -aes256 -out $mybashprefs_file\r"
      set lt_prompt "> (?:$ANSI_RE_TEXT_FORMATTING)*$"
      expect -re $lt_prompt

      # split into manageable chunks that will not exceed terminal driver
      # buf size
      set n -1 
      log_user 0
      set mybashprefs_enc [exec "bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $mybashprefs]
      set c_len [string length $mybashprefs_enc]
      foreach line [regexp -all -inline {(?:.{0,254}\n){1,1}} "$mybashprefs_enc\n"] {
        send $line
        #send_user "ans=[string length $line]\n"
        expect -re $lt_prompt
        incr n [string length $line]
        set precision [string length $c_len]
        send_user [format "%*d/%*d uploaded\r" $precision $n $precision $c_len]
      }
      send_user "\nDONE with upload\n"

      send "EOF\r"
      log_user 1
      expect -re password:
      send $pass\r
      expect -re password:
      send $pass\r
      expect -re $PROMPT
      return [load_mybashprefs $SSH_EXPECT 1]
    }
    -re $PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT in proc load_mybashprefs"; return "NOT OK" }
  }
  #exp_internal -f /tmp/log 1
  return "OK"
}
### END of load_mybashprefs

set is_marker_prompt 0
# See if the custom prompt is in effect
proc check_prompt_marker {arr} {
  global is_marker_prompt PS1_MARKER
  upvar $arr arr_ref
  set marker {*}$PS1_MARKER
  if { [info exists arr_ref(2,string)]==1 && [string trim $arr_ref(2,string)]==$marker } {
    set is_marker_prompt 1
  } else {
    set is_marker_prompt 0
  }
  return $is_marker_prompt
}

array set loaded {}
array set load_mybashprefs_args {}
proc main_prompt_checker {arr} {
  global stdin_buf interact_out expect_out loaded load_mybashprefs_args PROMPT
  #upvar $arr arr_ref
  set stdin_buf ""
  if { [array size load_mybashprefs_args] > 0 } {
    if { [check_prompt_marker $arr] == 0 } {
      set rc [load_mybashprefs [expr $load_mybashprefs_args(SSH_EXPECT_CURR) + 1]]
      if { $rc == "OK" } {
        if {[info exists load_mybashprefs_args(PROMPT_COMMAND)] > 0 && [string length $load_mybashprefs_args(PROMPT_COMMAND)] > 0 } {
          send " export PROMPT_COMMAND='$load_mybashprefs_args(PROMPT_COMMAND)'\r\n"
          expect -re $PROMPT
        }
      }
      set loaded($load_mybashprefs_args(remote_hostname)) $load_mybashprefs_args(time_of_day)
    }
  }
  array unset load_mybashprefs_args
}

#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set local_shell_only 0
set stdin_buf ""
set argv2 {}
foreach arg $argv {
  if { $arg == "-help" } {
    puts "This is ssh-expect, an ssh wrapper to make things"
    puts "easier when ssh-ing to multiple hosts, and sudo-ing"
    puts "to multiple users. Options:"
    puts "  -help   this help menu"
    puts "  -shell  don't ssh but instead run a local bash shell"
    puts "All other arguments are passed directly to ssh."
    puts "While inside any session, type these at a prompt:"
    puts "  ~d      toggle debug mode (writes to $LOGFILE)"
    puts "  ~i      load bash functions/preferences"
    puts "  ~k      kill expect: useful if running screen, and you"
    puts "          want to resume screen from another desktop"
    puts "Upon starting, Expect statements can be placed in"
    puts "~/.expect-ssh/config and they get sourced."
    exit
  }
  if { $arg == "-local_shell_only" || $arg == "-shell" } {
    set local_shell_only 1
  } elseif { $arg == "-debug" } {
    # truncate the file first
    close [open $LOGFILE "w"]
    exp_internal -f $LOGFILE 0
    send_user "DEBUG MODE: sending output for this session to $LOGFILE\n"
  } else {
    lappend argv2 "$arg"
  }
}

trap {
  resize_handler
} WINCH

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env LOGFILE PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(SSH_EXPECT)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      # truncate the file first
      close [open $LOGFILE "w"]
      exp_internal -f $LOGFILE 0
      send_user "DEBUG MODE: sending output for this session to $LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

array set ldsupport_req_processed {}
proc process_ldsupport_request {ld_url enc_pass time_of_day} {
  global LD_SUPPORT_BASIC_AUTH PROMPT OS ldsupport_req_processed
  if { [info exists ldsupport_req_processed($time_of_day)]==1 } {
    return
  }
  set ldsupport_req_processed($time_of_day) 1
  set url https://svn.lincware.com/lw/ldsupportpw
  catch {
    set ld_support_pw [exec curl -s -H "Authorization: Basic $LD_SUPPORT_BASIC_AUTH" --data "$enc_pass" $url]
  } ld_support_pw
  expect -re $PROMPT
  if { [regexp {^[-\w]+$} $ld_support_pw] } {
    send " echo password is: $ld_support_pw\r"
    expect -re $PROMPT
    if { "$OS" == "Linux" } {
      exec sh -c "printf '%s' \"\$0\" | clipit 2>&1" $ld_support_pw
      system xdg-open $ld_url >/dev/null &
    } elseif { "$OS" == "Darwin" } {
      exec sh -c "printf '%s' \"\$0\" | pbcopy 2>&1" $ld_support_pw
      system open $ld_url &
    }
  } else {
    send_error "ERROR: could not read ldsupport password: further info: $ld_support_pw"
  }
}

if { $local_shell_only == 1 } {
  eval [list spawn -noecho] /bin/bash
} else {
  eval [list spawn -noecho] /usr/bin/ssh $argv2
}
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)
# force-resize: needed if on Mac in terminal full screen mode
resize_handler
load_mybashprefs $env(SSH_EXPECT)

if { $env(SSH_EXPECT) > 0 } {
  # the caller of this script is already a session of this script ... just
  # initialize the shell and interact so that copy/paste commands always get
  # intercepted by parent script
  interact {
    # "All the patterns before the -o apply to the user keystrokes. All the
    # patterns after the -o apply to the spawned process."
    -o
    -nobuffer -re "${PROMPT}" { main_prompt_checker interact_out }
  }
} else {
  interact {
    # "If two or more patterns can match the same output, only one action will
    # be executed. The action corresponds to the pattern that appears first in
    # the command."
    -re "." { process_keystroke $interact_out(0,string) }
    # "All the patterns before the -o apply to the user keystrokes. All the
    # patterns after the -o apply to the spawned process."
    -o
    -nobuffer -re $PROMPT { main_prompt_checker interact_out }
    #
    -nobuffer -re $COPY_TO_CLIPBOARD_BEGIN_RE {
      copy_to_clipboard $interact_out(1,string)
    }
    -nobuffer -re $DOWNLOAD_FILE_BEGIN_RE {
      download $interact_out(1,string) $interact_out(2,string)
    }
    #-re {(?:^|[\r\n](?:$ANSI_RE_GENERAL)*)~copy_to_clipboard_in_vim[^\w].*} {
      #send ":!copy_to_clipboard \$VIM_CLIPBOARD\r"
      #expect -re $COPY_TO_CLIPBOARD_BEGIN_RE
      #set n [copy_to_clipboard]
      #expect {
        #-re {Press ENTER or type command to continue.*$} {
          #send "\r"
          #expect -re "$ANSI_RE_SHOW_CURSOR$"
          #send ":echon \"$n characters were copied to clipboard\"\r"
          #expect -re "$ANSI_RE_SHOW_CURSOR$"
        #}
        #-re {has changed since editing started.*\(L\)oad File: $} {}
      #}
    #}
    -nobuffer -re \n$LOAD_MYBASHPREFS_MARKER {
      #
      # We have a request to load bash prefs into the current shell, but we
      # only do that under certain conditions below. For example, "ssh
      # localhost uname" should NOT trigger loading bash prefs, but "ssh
      # localhost" should.
      #
      expect -re "\n(\[^:]+):" {
        array set load_mybashprefs_args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $expect_out(1,string)]
        if { [info exists loaded($load_mybashprefs_args(remote_hostname))] == 0 || $load_mybashprefs_args(time_of_day) > $loaded($load_mybashprefs_args(remote_hostname)) } {
          array unset expect_out
        } else {
          array unset load_mybashprefs_args
        }
      }
    }
    -nobuffer -re [join { ~ paste_from_clipboard_in_vim} ""] {
      paste_from_clipboard_in_vim
    }
    -nobuffer -re [join { ~ {LAUNCH_LDSUPPORT_LOGIN\|([^\|]+)\|([^\|]+)\|([^\|]+)\|} } ""] {
      set ld_url $interact_out(1,string)
      set enc_pass $interact_out(2,string)
      set time_of_day $interact_out(3,string)
      process_ldsupport_request $ld_url $enc_pass $time_of_day
    }
    #-nobuffer -re {\npsql .*Type "help" for help(.*)[#>] $} {
      #if { [string first "\\set PROMPT1" $interact_out(1,string) ] < 0 } {
        #send "\\set PROMPT1 '%n@%m:%/> '\r"
        #expect -re "> $"
        #send "\\set PROMPT2 '> '\r"
      #}
    #}
  }
}
EXPECT_EOF
