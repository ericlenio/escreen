#!/usr/bin/expect
# vim:filetype=expect
#
# Drop in replacement script for ssh, with helpful integrations to use bash,
# sudo, screen, and vim more effectively. Run with -help to see arguments.
#
# apt-get install tcllib
package require cmdline
package require md5

regsub -- {.*origin/([\d\.]+).*} [exec bash -c "cd [file dirname $argv0] && git status --porcelain -b|grep '^##'"] {\1} GIT_BRANCH

if {[string length $GIT_BRANCH]==0} {
  puts "Unable to parse git branch, stop."
  exit 1
}
set env(EXPECTSSH_TMPDIR) /tmp/.expect-ssh-$GIT_BRANCH
set EXPECTSSH_TMPDIR $env(EXPECTSSH_TMPDIR)
set EXPECTSSH_MYBASHPREFS $EXPECTSSH_TMPDIR/mybashprefs.$env(USER)
# TO DO: make the profile a command line parameter
set EXPECTSSH_PROFILE [file dirname $argv0]/profile.lenio
# if stdin is not a terminal, or $EXPECTSSH_SHLVL exists, then we just
# want to do regular ssh.
set overlay_test [exec bash -c {
  [ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }
  [ ! -t 0 -o -n "$EXPECTSSH_SHLVL" ] && echo overlay_flag
  true
}]

if {[regexp {overlay_flag} $overlay_test]==1} {
  # overlay the expect process with ssh, effectively leaving this script
  eval overlay /usr/bin/ssh $argv
}

set spawn_out_slave_name 0
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*[m]}
set ANSI_RE_CURSOR_POSITIONING {\u001b\\\[\d+;\d+[Hf]}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}

array set MARKER {}

set OS [exec uname -s]
set LOGFILE $EXPECTSSH_TMPDIR/$env(USER).log
match_max 10000
set configdir "$env(HOME)/.expect-ssh"
set rcfile "$configdir/config"
set EXPECTSSH_FUNCTIONS_DIR "$configdir/functions.d"
set is_marker_prompt 0
array set load_mybashprefs_args {}

##
##
## DEFINE ALL PROCS
##
##

#
# Optional arg is an index number, if not given then just return the regex of a
# generic marker.
proc get_marker {{idx ""}} {
  # Certain bash functions will send patterns (markers) which expect picks up
  # on to do further processing. The patterns are of the form of
  # GENERIC_MARKER.  It is required that after the pattern is sent there will
  # be a \n and then gzipped and base64 encoded data (optional), then a period
  # (not optional).
  set precision 2
  set GENERIC_MARKER_RE "~@(\[0-9]{$precision}):"
  if {[string length $idx]==0} { return $GENERIC_MARKER_RE }
  set marker [join [list ~@ [format "%0*d" $precision $idx] :] {}]
  return $marker
}

proc _ES_register_marker { marker_key handler } {
  global MARKER
  set idx [llength [array names MARKER -regexp {^(\w+)$}]]
  set MARKER($marker_key) [get_marker $idx]
  set MARKER($marker_key,idx) $idx
  set MARKER($marker_key,handler) $handler
  #puts "_ES_register_marker: registered new marker $marker_key with handler: $handler idx=$idx"
}

proc _ES_run_marker_handler { marker_idx } {
  global MARKER ANSI_RE_GENERAL
  set encoded_args ""
  set decoded_args ""
  expect \n
  expect {
    -re {([^\.]*)\.} {
      append encoded_args $expect_out(1,string)
    }
    -re {([^\.]{1,255})} {
      append encoded_args $expect_out(1,string)
      exp_continue
    }
  }
  # convert all \015 back to \n
  regsub -all "\015" $encoded_args "\n" encoded_args
  # clean out any cursor movement sequences that sometimes get thrown in by screen
  regsub -all $ANSI_RE_GENERAL $encoded_args "" encoded_args

  if {[string length [string trim $encoded_args]]>0} {
    if {[catch {
      set decoded_args [exec sh -c "printf '%s' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
    } err]} {
      send_error "ERROR decoding args: $err\r\n"
      return
    }
  }

  # find the handler and run it
  foreach key [array names MARKER -regexp {^(\w+)$}] {
    if {$marker_idx == $MARKER($key,idx)} {
      set handler $MARKER($key,handler)
      catch {
        eval [list $handler $decoded_args]
      } err
      if {[string length $err]>0} {
        send_error "ERROR invoking handler $handler: $err\r\n"
      }
      return
    }
  }
  send_error "ERROR in _ES_run_marker_handler: no handler found for idx=$marker_idx\r\n"
}

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

proc compute_md5 {s} {
  return [string tolower [md5::md5 -hex $s]]
}

proc compute_pw {s} {
  global MYBASHPREFS_PASSWORD
  set script_md5 [compute_md5 $s]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change. Md5 the result to make a shorter version of the
  # password.
  set pass [format "%.8s" [compute_md5 $MYBASHPREFS_PASSWORD-$script_md5]]
  return $pass
}

proc slurp_file {f} {
  set fp [open $f r]
  set file_data [read $fp]
  close $fp
  return $file_data
}

#
# User custom functions
#
proc get_scripts {} {
  global EXPECTSSH_FUNCTIONS_DIR EXPECTSSH_TMPDIR EXPECTSSH_PROFILE env
  array unset FUNCMAP
  set FUNCMAP(:remote_file) $EXPECTSSH_TMPDIR/$env(USER).FUNCMAP
  set FUNCMAP(:remote_file_prefix) $EXPECTSSH_TMPDIR/$env(USER).f.
  foreach dir [list $EXPECTSSH_FUNCTIONS_DIR $EXPECTSSH_PROFILE] {
    if { [file isdirectory $dir]==1 } {
      foreach funcname [glob -directory $dir -tails *] {
        if { $funcname eq "README" } { continue }
        set func_def [slurp_file $dir/$funcname]
        set FUNCMAP($funcname) ""
        #set FUNCMAP($funcname,file) $dir/$funcname
        #set FUNCMAP($funcname,md5) [compute_md5 $func_def]
        set FUNCMAP($funcname,defn) $func_def
        #set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname.$FUNCMAP($funcname,md5)
        set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
      }
    }
  }

  array set SYSFUNCMAP [get_system_functions]
  foreach funcname [array names SYSFUNCMAP] {
    set func_def $SYSFUNCMAP($funcname)
    set FUNCMAP($funcname) ""
    #set FUNCMAP($funcname,md5) [compute_md5 $func_def]
    set FUNCMAP($funcname,defn) $func_def
    set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
  }

  #
  # Find dependencies, then strip all comments
  #
  foreach funcname [lsort [array names FUNCMAP -regexp {^\w+$}]] {
    set FUNCMAP($funcname,depends_on) [get_dependencies $funcname [array get FUNCMAP]]
    set FUNCMAP($funcname,defn) [strip_comments $FUNCMAP($funcname,defn)]
  }

  return [array get FUNCMAP]
}

proc get_dependencies {funcname FUNCMAP {depends_list ""}} {
  array set FUNCMAP2 $FUNCMAP
  set depends ""
  regexp -line {^\s*#\s*depends:(.*)$} $FUNCMAP2($funcname,defn) - depends
  if {[string length $depends]>0} {
    foreach funcname2 [split $depends {,}] {
      set temp [get_dependencies $funcname2 [array get FUNCMAP2]]
      if {[string length $temp]>0} {
        lappend depends_list $temp
      }
      lappend depends_list $funcname2
    }
  }
  return $depends_list
}


#
# System level functions
#
proc get_system_functions {} {
  global MARKER
  # EXPECTSSH_IN_SCREEN is a flag to know if current shell is (ultimately)
  # inside a screen session, and if so when ssh-ing to a new host we can update
  # the screen window title with the new hostname.
  set script ""
  append script "function signal_load_mybashprefs() {\n"
  # We do NOT use _ES_marker or _ES_send_marker here because we cannot
  # assume they exist in the shell
  append script "local marker=\"$MARKER(LOAD_MYBASHPREFS)\"\n"
  append script {
    local in_screen=0
    if [ -n "$STY" -o -n "$EXPECTSSH_IN_SCREEN" ]; then in_screen=1; fi
    local CMD_ARRAY=("$@")
    local args=$(printf "EXPECTSSH_SHLVL %s EXPECTSSH_IN_SCREEN {%s} CMD_ARRAY {%s}" $EXPECTSSH_SHLVL "$in_screen" "$(declare -p CMD_ARRAY)")
  }
  append script {_ES_send_marker "$marker" "$args"}
  append script "\n"
  append script "}; export -f signal_load_mybashprefs\n"
  set FUNCMAP(signal_load_mybashprefs) $script

  set script {
  # depends:signal_load_mybashprefs
  function ssh() {
    if [ -t 1 ]; then
      signal_load_mybashprefs
      /usr/bin/ssh "$@"
      local rc=$?
      if [ "$EXPECTSSH_IN_SCREEN" = 1 -o -n "$STY" ]; then
        printf "\033k${HOSTNAME}\033\134"
      fi
      return $rc
    else
      # we are in a pipeline
      /usr/bin/ssh "$@"
    fi
  }
  export -f ssh
  }
  set FUNCMAP(ssh) $script

  return [array get FUNCMAP]
}

# FIXME
proc download_default_file_handler {decoded_args} {
  array set args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
  set outfile [get_download_filename $args(default_file_name)]
  if { $outfile == "" } {
    # discontinue downloading
    send "NO\r"
  } else {
    send "y\r"
    expect -ex \n
  }
}

proc get_download_filename {default_file_name} {
  global PROMPT OS spawn_id
  set default_outfile "/tmp/$default_file_name"
  set outfile ""
  set main_spawn_id $spawn_id
  set bashscript {function get_download_file() {
    read -e -p 'Save downloaded file to (leave blank to cancel): ' f
    if [ -z "$f" ]; then return; fi
    if [ -e "$f" -a ! -w "$f" ]; then echo "$f is not writable"; return; fi
    local dir=$(dirname "$f")
    if [ -z "$dir" ]; then dir=$(pwd); fi
    if [ ! -e "$f" -a ! -w "$dir" ]; then echo "Directory $dir is not writable"; return; fi
    echo "File will be downloaded to: $f"
    }
    get_download_file
  }
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  expect ": "
  send $default_outfile
  interact {
    -o -nobuffer -re "File will be downloaded to: (.*)\r" {
      set outfile $interact_out(1,string)
    }
  }
  set spawn_id $main_spawn_id
  return $outfile
}

#
# Upload a local file to the remote session.
#
proc upload_file {} {
  global PROMPT OS spawn_id
  set bashscript {function get_upload_file() {
    local f
    local yn
    read -e -p 'Choose a file to be uploaded: ' f
    # canonicalize f: must do tilde expansion
    f=${f/#~/$HOME}
    if [ ! -e "$f" ]; then
      echo "Error: no such file, or file is not readable: $f"
      return 1
    fi
    read -p "Confirm: upload \"$f\" (y/n, default y): " yn
    [ -z "$yn" ] && yn=y
    [ "$yn" != y ] && return
    echo "File to be uploaded: $f"
    local outfile=/tmp/$(basename "$f")
    echo "Will be uploaded to: $outfile"
    }
    # execute the function
    get_upload_file
  }
  set main_spawn_id $spawn_id
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  set upload_file ""
  interact {
    -o -nobuffer -re "File to be uploaded: (.*)\r\nWill be uploaded to: (.*)\r" {
      set upload_file $interact_out(1,string)
      set outfile $interact_out(2,string)
    }
  }
  set spawn_id $main_spawn_id
  if { [file exists $upload_file] == 0 } {
    return
  }
  # Delimit the input with a space, and after each line is sent send \r so
  # the terminal does not scroll
  send " \[ -e \"$outfile\" -a ! -w \"$outfile\" ] && echo '$outfile is not writable, aborting upload.'\r"
  expect {
    -re "\n.*aborting" {
      return
    }
    -re $PROMPT
  }
  send " exec 3> >(/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\")\r"
  send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&3; printf "\015"; done; exec 3>&-}
  send \r
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set upload_file_enc [exec "/bin/bash" "-c" "gzip -9 -c \"$upload_file\" | openssl enc -base64"]
  set c_len [string length $upload_file_enc]
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$upload_file_enc\n"] {
    send "[string trimright $line] "
    expect -re "\x0d$"
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    set precision [string length $c_len]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload to $outfile\r\n"
  send ". "
  expect ". "
  log_user 1
  expect -re $PROMPT
}

proc download_data_handler {outfile encoded_data} {
  set l -1
  if { [catch {
    set chan [open "|/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\"" w]
    fconfigure $chan -translation binary -encoding binary
    puts $chan $encoded_data
    flush $chan
    close $chan
    set l [file size $outfile]
    send_user "DONE...downloaded to $outfile, $l bytes"
    } err] } {
    send_error "ERROR in proc download: $err"
  }
  return $l
}

proc load_mybashprefs_handler {decoded_args} {
  global load_mybashprefs_args
  #
  # We have a request to load bash prefs into the current shell, but we
  # only do that under certain conditions below. For example, "ssh
  # localhost uname" should NOT trigger loading bash prefs, but "ssh
  # localhost" should.
  #
  array set load_mybashprefs_args $decoded_args
}

proc load_mybashprefs {EXPECTSSH_SHLVL {nest_level 0}} {
  global PROMPT ANSI_RE_TEXT_FORMATTING EXPECTSSH_PS1_MARKER EXPECTSSH_TMPDIR MYBASHPREFS_PASSWORD
  global MARKER EXPECTSSH_MYBASHPREFS EXPECTSSH_PROFILE
  log_user 1
  # TO DO: verify we are in bash
  #send " echo 'test for bash'\r"
  #expect {
    #-re "\ntest for bash\r.*$PROMPT" {}
    #timeout {
      #send_error "timeout in load_mybashprefs while testing for bash\n"
      #return
    #}
  #}
  array set FUNCMAP [get_scripts]

  set mybashprefs ""

  # 
  # Everything is wrapped in function _ES_core
  #
  append mybashprefs "function _ES_core() {\n"
  append mybashprefs "export _ES_FCN_PREFIX=$FUNCMAP(:remote_file_prefix)\n"
  append mybashprefs "export EXPECTSSH_SHLVL=\$1\n"
  append mybashprefs "export EXPECTSSH_TMPDIR=$EXPECTSSH_TMPDIR\n"
  append mybashprefs "export EXPECTSSH_PS1_MARKER='$EXPECTSSH_PS1_MARKER'\n"
  append mybashprefs "export EXPECTSSH_PROFILE=$EXPECTSSH_PROFILE\n"

  append mybashprefs "function _ES_marker() {\n"
  append mybashprefs "local MARKER\n"
  append mybashprefs "declare -A MARKER=("
  foreach marker_name [array names MARKER -regexp {^(\w+)$}] {
    append mybashprefs "\[$marker_name]=$MARKER($marker_name) "
  }
  append mybashprefs ")\n"
  append mybashprefs {echo ${MARKER[$1]}}
  append mybashprefs "\n}\n"
  append mybashprefs "export -f _ES_marker\n"

  ## see if previous command in history was the line to decode bashprefs, and if so delete it from history
  #append mybashprefs {history -p '!!'|grep -q ^' c=' && TMP=$(history|tail -1|awk '{print $1}') && history -d $TMP && unset TMP}
  #append mybashprefs \n
  #append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  ## NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  ## otherwise the line spacing gets all weird when typing out long bash commands
  #append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $EXPECTSSH_PS1_MARKER [join { {\[} {\0} {\]} } {}]]
  #append mybashprefs "'\n"

  append mybashprefs {function _ES_source_script() {
  local script=$1
  if [ ! -e "$script" ]; then
    echo "No such file"
    return
  fi
  local c
  c="$(openssl enc -a -d -aes256 -in $script)" && eval "$c"
}
export -f _ES_source_script

function _ES_rec_rem() {
  # v is the name of variable we are going to set so caller can
  # get the function
  local v=$1
  local l
  # Delimit the input with a space, and after each line is sent send \r so the
  # terminal does not scroll
  local _s
  while true; do
    read -d ' ' l
    [ "$l" = . ] && break
    _s+=$l$'\n'
    printf "\015"
  done
  eval $v='$(echo "$_s"|openssl enc -d -base64|gzip -d -c)'
}
export -f _ES_rec_rem

function _ES_send_marker() {
  local marker="$1"
  local args=$(echo -n "$2"|gzip -9 -c|openssl enc -base64)
  local l
  # pass a \010 (backspace) character to erase last character of the pattern so
  # that expect-ssh only processes this signal 1 time ... else when inside
  # screen it would potentially get re-executed from a resumed session.
  printf "%s\010.\n" "$marker"
  printf "$args" | {
    while IFS=$'\n' read -r l || [ -n "$l" ]; do
      printf "%s\015" $l
    done
  }
  # send terminating period for the pattern to match
  printf ".\n"
}
export -f _ES_send_marker

}
  #
  # _ES_gen_stub generates a stub function for each user's custom function.
  #
  append mybashprefs "function _ES_gen_stub() {\n"
  append mybashprefs "local marker=\$(_ES_marker UPLOAD_SCRIPT)\n"
  append mybashprefs {local funcname=$1
  if [ -z "$(declare -F $funcname)" ]; then
    local f="function $funcname() { "
    f+='_ES_bootstrap '$funcname' "$@";'
    f+='}'
    eval $f
    export -f $funcname
    unalias $funcname 2>/dev/null
    #echo "generated stub function: $funcname"
  #else
    #echo "skip generating stub for $funcname: function already exists"
  fi
}
  append mybashprefs "}; export -f _ES_gen_stub\n"
  #
  # _ES_show_func: decrypt and show cached script file
  #
  append mybashprefs "function _ES_show_func() {\n"
  append mybashprefs "local marker=\$(_ES_marker GET_SCRIPT_PW)\n"
  append mybashprefs {local funcname=$1
    local f=$_ES_FCN_PREFIX$funcname
    _ES_send_marker "$marker" $funcname
    openssl enc -d -a -aes256 -in $f|gzip -d -c
  }
  append mybashprefs "}; export -f _ES_show_func\n"

  append mybashprefs {
    function _ES_set_loaded() {
      local funcname=$1
      echo "$EXPECTSSH_LOADED_FUNCS" | grep -q -w $funcname || {
        [ -n "$EXPECTSSH_LOADED_FUNCS" ] && EXPECTSSH_LOADED_FUNCS+=" "
        EXPECTSSH_LOADED_FUNCS+=$funcname
      }
      export EXPECTSSH_LOADED_FUNCS
    }
    export -f _ES_set_loaded
  }
  #
  # _ES_bootstrap bootstraps a function
  #
  append mybashprefs "function _ES_bootstrap() {\n"
  append mybashprefs "local pwmarker=\$(_ES_marker GET_SCRIPT_PW)\n"
  append mybashprefs "local upmarker=\$(_ES_marker UPLOAD_SCRIPT)\n"
  append mybashprefs {
    local funcname=$1
    local f=$_ES_FCN_PREFIX$funcname
    local h s l pw
    local import
    # Associative array will have funcname, pw, script
    declare -A import
    if [ -f $f ]; then
      _ES_send_marker "$pwmarker" $funcname
      s="$(openssl enc -d -a -aes256 -in $f|gzip -d -c)" && {
        eval "$s" && _ES_set_loaded $funcname && "$@"
        return
      }
      # fall through to below, re-upload and cache the script
    fi

    _ES_send_marker "$upmarker" $funcname
    _ES_rec_rem s
    echo "$s" | {
      while IFS=$'\n' read -r l || [ -n "$l" ]; do
        eval "$l"
        f=$_ES_FCN_PREFIX${import[funcname]}
        [ ! -f $f ] && touch $f && chmod 666 $f
        echo "${import[script]}" > $f
        eval "$(echo "${import[script]}"|pw="${import[pw]}" openssl enc -d -a -aes256 -pass env:pw|gzip -d -c)" && _ES_set_loaded ${import[funcname]}
      done
    }
    "$@"
  }
  append mybashprefs "}; export -f _ES_bootstrap\n"
  #
  # escape the regex for the PS1 marker
  append mybashprefs {function _ES_eps1m() {
    echo "$EXPECTSSH_PS1_MARKER"|perl -pe 's{(\\033\[[^a-zA-Z]*[a-zA-Z])}{\\[$1\\]}g'
    }
    export -f _ES_eps1m
  }


  set bashrc $EXPECTSSH_PROFILE/.bashrc
  if {[file exists $bashrc]} {
    set n 1
    foreach funcname [lsort [array names FUNCMAP -regexp {^\w+$}]] {
      append mybashprefs "_ES_gen_stub $funcname\n"
      incr n
    }
    append mybashprefs [slurp_file $bashrc]
  }

  # unset $c, set below
  append mybashprefs "unset c\n"
  #
  # Finally: END of function _ES_core
  #
  append mybashprefs "}\n"
  append mybashprefs "export -f _ES_core\n"
  #append mybashprefs "_ES_core\n"
  set mybashprefs [strip_comments $mybashprefs]

  set pass [compute_pw $mybashprefs]
  send " f=$EXPECTSSH_MYBASHPREFS; c=\"\$(openssl enc -a -d -aes256 -in \$f)\" && eval \"\${c}\" && _ES_core $EXPECTSSH_SHLVL\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file or directory).*$PROMPT" {
      if { $nest_level > 0 } {
        # do not get in recursive loop attempting to upload + write out bash prefs
        return "NOT OK"
      }
      # compress all the bash commands, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk ... but watch out if this base64 string exceeds 4096 bytes (1024
      # for mac) which seems to be the terminal driver limit
      # (http://expect.sourceforge.net/FAQ.html#q76) "terminal input queue"
      # "typeahead buffer" MAX_INPUT
      # "getconf -a|grep MAX_INPUT" may help determine this value
      send "c=\$(history|tail -1|awk '{print \$1}') && history -d \$c && history -d \$((\$c-1)) && HISTCONTROL=ignoreboth:erasedups\r"
      expect -re $PROMPT
      send " d=$EXPECTSSH_TMPDIR; \[ ! -d \$d ] && { mkdir \$d; chmod 1777 \$d; }\r"
      expect -re $PROMPT
      #send_user "uploading $EXPECTSSH_MYBASHPREFS ...\n"
      # Note the leading space so it is not saved in bash history
      send " touch \$f; chmod 666 \$f\r"
      expect -re $PROMPT
      log_user 0
      send " exec 3< <(echo '$pass')\r"
      expect -re {(.*\r)}
      # Hide password from being displayed
      regsub {'(.*)'} $expect_out(1,string) '[regsub -all . $pass *]' echoline
      send_user $echoline\n
      log_user 1
      expect -re $PROMPT
      # Delimit the input with a space, and after each line is sent send \r so
      # the terminal does not scroll
      send " exec 4> >(openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out \$f)\r"
      send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&4; printf "\015"; done; exec 3<&- 4>&-}
      send \r
      expect -re \r\n$
      send_script $mybashprefs 
      expect -re $PROMPT
      return [load_mybashprefs $EXPECTSSH_SHLVL 1]
    }
    -re $PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT in proc load_mybashprefs"; return "NOT OK" }
  }
  #exp_internal -f /tmp/log 1

  #upload_and_source_script $bootstrap_funcs $FUNCMAP(:remote_file)
  return "OK"
}
### END of load_mybashprefs

proc get_encrypted_func {funcname script} {
  set pw [compute_pw $script]
  set enc_script [exec /bin/bash -c {echo "$0"|gzip -9 -c|pw="$1" openssl enc -aes256 -a -pass env:pw} $script $pw]
  regsub -all "\n" $enc_script {\n} enc_script
  return [format {import[funcname]=%s;import[pw]='%s';import[script]=$'%s'} $funcname $pw $enc_script]
}

proc upload_script_handler {decoded_args} {
  set funcname $decoded_args
  array set FUNCMAP [get_scripts]
  set script ""
  foreach dep $FUNCMAP($funcname,depends_on) {
    append script "[get_encrypted_func $dep $FUNCMAP($dep,defn)]\n"
  }
  append script "[get_encrypted_func $funcname $FUNCMAP($funcname,defn)]\n"
  send_script $script
  return ""
}

proc script_password_handler {decoded_args} {
  set funcname $decoded_args
  array set FUNCMAP [get_scripts]
  set pw [compute_pw $FUNCMAP($funcname,defn)]
  expect -re "password:$"
  send "$pw\r"
  send_user "$funcname:$pw\r\n"
}

proc strip_comments {script} {
  # use negative lookahead so that comments beginning with 2 consecutive pound
  # signs will not get stripped
  return [regsub -all {(^|\n)\s*#(?!#)[^\n]*\n} $script {\1}]
}

proc send_script { script } {
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set remote_file_content_enc [exec "/bin/bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $script]
  set c_len [string length $remote_file_content_enc]
  set precision [string length $c_len]
  set delim " "
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$remote_file_content_enc\n"] {
    send "[string trimright $line]$delim"
    expect {
      # first time in this loop it could by \r\n
      -re "\r\n$" {}
      -re "\x0d$" {}
    }
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload\r\n"
  send ".$delim"
  expect ".$delim"
  log_user 1
}

# See if the custom prompt is in effect
proc check_prompt_marker {arr} {
  global is_marker_prompt EXPECTSSH_PS1_MARKER
  upvar $arr arr_ref
  set marker {*}$EXPECTSSH_PS1_MARKER
  if { [info exists arr_ref(2,string)]==1 && [string trim $arr_ref(2,string)]==$marker } {
    set is_marker_prompt 1
  } else {
    set is_marker_prompt 0
  }
  return $is_marker_prompt
}

proc main_prompt_checker {arr} {
  global stdin_buf interact_out expect_out load_mybashprefs_args PROMPT
  set stdin_buf ""
  if { [array size load_mybashprefs_args] > 0 } {
    if { [check_prompt_marker $arr] == 0 } {
      set rc [load_mybashprefs [expr $load_mybashprefs_args(EXPECTSSH_SHLVL) + 1]]
      if { $rc == "OK" } {
        if { [info exists load_mybashprefs_args(EXPECTSSH_IN_SCREEN)] > 0 && $load_mybashprefs_args(EXPECTSSH_IN_SCREEN)==1 } {
          send " export EXPECTSSH_IN_SCREEN=1 && "
          send {printf "\033k${HOSTNAME}\033\134"}
          send \r
          expect -re $PROMPT
        }
        if { [info exists load_mybashprefs_args(CMD_ARRAY)] > 0
          && $load_mybashprefs_args(CMD_ARRAY) != "declare -a CMD_ARRAY='()'"
          && [string length $load_mybashprefs_args(CMD_ARRAY)]>0
          } {
          send " $load_mybashprefs_args(CMD_ARRAY) && "
          send {eval "${CMD_ARRAY[@]}"}
          send \r
        }
      }
    }
  }
  array unset load_mybashprefs_args
}

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env LOGFILE PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(EXPECTSSH_SHLVL)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      # truncate the file first
      close [open $LOGFILE "w"]
      exp_internal -f $LOGFILE 0
      send_user "DEBUG MODE: sending output for this session to $LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } elseif { $stdin_buf == "~u" } {
    upload_file
    set stdin_buf ""
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

##
##
## END OF PROCS
##
##

#
# Register some core handlers
#
_ES_register_marker LOAD_MYBASHPREFS load_mybashprefs_handler
_ES_register_marker UPLOAD_SCRIPT upload_script_handler
_ES_register_marker DOWNLOAD_DEFAULT_FILE download_default_file_handler
_ES_register_marker DOWNLOAD_DATA download_data_handler
_ES_register_marker GET_SCRIPT_PW script_password_handler

if {[file exists $rcfile]} {
  source $rcfile
}

foreach expfile [lsort [glob -directory $EXPECTSSH_PROFILE *.exp]] {
  source $expfile
}

set PROMPT "(?:"
append PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append PROMPT "|"
append PROMPT "([regsub -all {([\[])} $EXPECTSSH_PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT ")"

if {[info exists env(EXPECTSSH_SHLVL)] == 1} {
  set env(EXPECTSSH_SHLVL) [expr $env(EXPECTSSH_SHLVL) + 1]
} else {
  set env(EXPECTSSH_SHLVL) 0
}
#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set local_shell_only 0
set stdin_buf ""

set options {
  { debug "" "turn on debug mode" }
  { shell "" "don't ssh but instead run a local bash shell" }
  { timeout.arg 10 "expect pattern timeout value" }
}

set usage "expect-ssh: an ssh wrapper/replacement tool.\n"
append usage "All arguments other than the ones below are passed directly to ssh.\n"
append usage "While inside any session, type these at a prompt:\n"
append usage "  ~d      toggle debug mode (writes to $LOGFILE)\n"
append usage "  ~i      load bash functions/preferences\n"
append usage "  ~k      kill expect: useful if running screen, and you\n"
append usage "          want to resume screen from another desktop\n"
append usage "Upon starting, Expect statements can be placed in\n"
append usage "$rcfile and they get sourced. Options:\n"

array set opts [::cmdline::getKnownOptions argv $options $usage]
set def_timeout $timeout
set timeout $opts(timeout)
#set send_slow {1 .1}
#set send_human {.1 .3 1 .05 2}

if { $def_timeout != $timeout } {
  send_user "Timeout set to: $timeout\n"
}

if { $opts(shell) == 1 } {
  set local_shell_only 1
}
if { $opts(debug) == 1 } {
  # truncate the file first
  close [open $LOGFILE "w"]
  exp_internal -f $LOGFILE 0
  send_user "DEBUG MODE: sending output for this session to $LOGFILE\n"
}

trap { resize_handler } WINCH

if { $local_shell_only == 1 } {
  eval [list spawn -noecho] /bin/bash
} else {
  eval [list spawn -noecho] /usr/bin/ssh $argv
}
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)
# force-resize: needed if on Mac in terminal full screen mode
resize_handler
load_mybashprefs $env(EXPECTSSH_SHLVL)
set marker_re (?:^|\x07|\n|\r)[get_marker]

interact {
  # "If two or more patterns can match the same output, only one action will
  # be executed. The action corresponds to the pattern that appears first in
  # the command."
  -re "." { process_keystroke $interact_out(0,string) }
  # "All the patterns before the -o apply to the user keystrokes. All the
  # patterns after the -o apply to the spawned process."
  -o
  -nobuffer -re $PROMPT { main_prompt_checker interact_out }
  -nobuffer -re $marker_re {
    set marker_idx $interact_out(1,string)
    _ES_run_marker_handler $marker_idx
  }
}
