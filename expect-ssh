#!/usr/bin/expect
# vim:filetype=expect
#
# fork, and in parent make it become the event handler server, and 
# the child becomes the normal expect-ssh process.
# trap SIGCHLD in parent, to force exit when expect-ssh ends.
# need a way to get open port if ssh-ing to another host.
# port 0: http://wiki.tcl.tk/2230
# When initializing a function:
# function l() {
# }
#
# launch expect-ssh, command server listens on port 1313
# start screen
# ssh -R35343:localhost:1313 clouda
# ssh -R24388:localhost:1313 cloudw1
# go home
# launch expect-ssh, command server listens on port 2389
# ssh back to work: -R34306:localhost:2389
# kill old expect-ssh
# resume original gnu screen: screen -d -r
# set up netcat relay:
#   mkfifo backpipe
#   nc -l -p 1313 0<backpipe | nc localhost -p 2389 1>backpipe
#   
#
# apt-get install tcllib
package require cmdline
package require md5
package require uuid


# if stdin is not a terminal, or $EXPECTSSH_SHLVL exists, then we just
# want to do regular ssh.
#set overlay_test [exec bash -c {
  #[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }
  #[ ! -t 0 -o -n "$EXPECTSSH_SHLVL" ] && echo overlay_flag
  #true
#}]

#if {[regexp {overlay_flag} $overlay_test]==1} {
  ## overlay the expect process with ssh, effectively leaving this script
  #eval overlay /usr/bin/ssh $argv
#}


##
##
## DEFINE ALL PROCS
##
##

# shenanigans to figure out what dir the git checkout is
proc get_expectssh_home {} {
  set originalPath [pwd]
  set scriptPath   $::argv0
  set workingPath  [file dirname $::argv0]
  while {![catch {file readlink $scriptPath} result]} {
    cd $workingPath
    set scriptPath  [file join [pwd] $result]
    set workingPath [file dirname $scriptPath]
  }
  cd [file dirname $scriptPath]
  set scriptPath [pwd]
  cd $originalPath
  return $scriptPath
}

proc get_git_branch {} {
  regsub -- {^## ([\d\.]+\d).*} [exec bash -c "cd [get_expectssh_home] && git status --porcelain -b|grep '^##'"] {\1} GIT_BRANCH
  if {[string length $GIT_BRANCH]==0} {
    puts "Unable to parse git branch, stop."
    exit 1
  }
  return $GIT_BRANCH
}

proc cleanup_and_exit {} {
  global EXPECTSSH_TMPDIR opts command_server_pid
  exec kill $command_server_pid
  send_error "Killed command server: $command_server_pid\n"
  if {$opts(tmpdir)==1} {
    set tmpdir $EXPECTSSH_TMPDIR
    if {[catch {
      file delete -force $tmpdir
      puts "expect-ssh: $tmpdir was deleted."
    } err]} {
      puts "Error while deleting $tmpdir: $err"
    }
  }
  exit
}

proc init_tmpdir {opts_tmpdir} {
  set GIT_BRANCH [get_git_branch]
  set suffix [expr {$opts_tmpdir==1 ? "-[pid]" : ""}]
  set tmpdir /tmp/.expect-ssh-$GIT_BRANCH$suffix
  if {$opts_tmpdir==1} {
    puts "Using temp dir: $tmpdir"
  }
  exec bash -c {
    [ ! -d $0 ] && { mkdir $0; chmod 1777 $0; }
    true
  } $tmpdir
  return $tmpdir
}

proc open_logfile {} {
  global EXPECTSSH_LOGFILE
  # truncate the file first
  close [open $EXPECTSSH_LOGFILE "w"]
  file attributes $EXPECTSSH_LOGFILE -permissions 0600
  exp_internal -f $EXPECTSSH_LOGFILE 0
}

proc run_tests {} {
  global EXPECTSSH_HOME env EXPECTSSH_PROMPT
  set env(EXPECTSSH_SHLVL) ""
  send_error "START test framework\n"
  eval [list spawn -noecho] $EXPECTSSH_HOME/expect-ssh -tmpdir
  expect -re $EXPECTSSH_PROMPT {
    if { [check_prompt_marker [array get expect_out]] == 0 } {
      exp_continue
    }
  }
  send uname\r
  expect -re $EXPECTSSH_PROMPT
  send exit\r
  send_error "END test framework\n"
}

#
# Optional arg is an index number, if not given then just return the regex of a
# generic marker.
proc get_marker {{idx ""}} {
  # Certain bash functions will send patterns (markers) which expect picks up
  # on to do further processing. The patterns are of the form of
  # GENERIC_MARKER.  It is required that after the pattern is sent there will
  # be a \n and then gzipped and base64 encoded data (optional), then a period
  # (not optional).
  set precision 2
  set GENERIC_MARKER_RE "~@(\[0-9]{$precision}):"
  if {[string length $idx]==0} { return $GENERIC_MARKER_RE }
  set marker [join [list ~@ [format "%0*d" $precision $idx] :] {}]
  return $marker
}

proc get_marker_word {idx} {
  global MARKER
  foreach key [array names MARKER -regexp {^(\w+)$}] {
    if {$MARKER($key,idx)==$idx} {
      return $key
    }
  }
  return "?"
}

proc _ES_register_marker {marker_key handler} {
  global MARKER
  set idx [llength [array names MARKER -regexp {^(\w+)$}]]
  #set MARKER($marker_key) [get_marker $idx]
  set MARKER($marker_key) [format "%02d" $idx]
  set MARKER($marker_key,idx) $idx
  set MARKER($marker_key,handler) $handler
  #puts "_ES_register_marker: registered new marker $marker_key with handler: $handler idx=$idx"
}

proc erase_line {} {
  send_user "\033\[2K"
}

proc clean_xmitted_string {s} {
  global ANSI_RE_GENERAL ANSI_RE_TEXT_FORMATTING ANSI_RE_CURSOR_POSITIONING
  # if gnu screen active, sometimes the status line changes and so we remove that
  regsub -all $ANSI_RE_CURSOR_POSITIONING.*$ANSI_RE_TEXT_FORMATTING $s "" s
  # clean out any other cursor movement sequences that sometimes get thrown in
  # by screen
  regsub -all $ANSI_RE_GENERAL $s "" s
  # convert all \015 back to \n
  regsub -all "\015" $s "\n" s
  return $s
}

proc read_from_pipe {chan LOG_var BYTES_READ_var decoded_args_var status_var} {
  upvar $LOG_var LOG
  upvar $BYTES_READ_var BYTES_READ
  upvar $decoded_args_var decoded_args
  upvar $status_var STATUS
  catch {
    set l [gets $chan]
    return
  } err
  if {[string length $err]>0} {
    send_error "read_from_pipe: channel $chan: $err\r\n"
send_log $LOG
    return
  }
  append decoded_args $l
  incr BYTES_READ [string length $l]
  append LOG "R:[string length $l]:$BYTES_READ\n"
  if {[eof $chan]} {
    set b [fblocked $chan]
    append LOG "read_from_pipe:EOF detected in $chan, fblocked=$b\r\n"
    if {$b==1} {
      send_error "read_from_pipe:EOF detected in $chan, but fblocked==1\r\n"
    } else {
      close $chan
      set STATUS DONE
      append LOG "read_from_pipe:CLOSE:$chan\n"
    }
    return
  }
  # unlikely to be blocked, but perhaps
  if {[fblocked $chan]==0 && [string length $l]>0} {
    append decoded_args \n
  }
}

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

proc compute_md5 {s} {
  return [string tolower [md5::md5 -hex $s]]
}

proc compute_pw {s} {
  global MYBASHPREFS_PASSWORD
  set script_md5 [compute_md5 $s]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change. Md5 the result to make a shorter version of the
  # password. Update: take only first 8 chars for even shorter password, making
  # the chance for a collision more likely but willing to accept that risk.
  set pass [format "%.8s" [compute_md5 $MYBASHPREFS_PASSWORD-$script_md5]]
  return $pass
}

proc slurp_file {f} {
  set fp [open $f r]
  set file_data [read $fp]
  close $fp
  return $file_data
}

#
# User custom functions
#
proc get_scripts {} {
  global EXPECTSSH_PROFILE_OVERRIDES EXPECTSSH_TMPDIR EXPECTSSH_PROFILE EXPECTSSH_CORE env
  global EXPECTSSH_CORE_FCN_PREFIX
  array unset FUNCMAP
  set FUNCMAP(:remote_file) $EXPECTSSH_TMPDIR/$env(USER).FUNCMAP
  set FUNCMAP(:remote_file_prefix) $EXPECTSSH_TMPDIR/$env(USER).f.
  foreach dir [list $EXPECTSSH_CORE $EXPECTSSH_PROFILE $EXPECTSSH_PROFILE_OVERRIDES] {
    if { [file isdirectory $dir]==1 } {
      foreach funcname [glob -nocomplain -directory $dir -tails *] {
        if { $funcname eq "README" } { continue }
        if {[regexp "^$EXPECTSSH_CORE_FCN_PREFIX" $funcname]==1} { continue }
        if {[regexp {^\w+$} $funcname]==0} { continue }
        set func_def [slurp_file $dir/$funcname]
        set FUNCMAP($funcname) ""
        set FUNCMAP($funcname,defn) $func_def
        set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
      }
    }
  }
  set flist [lsort [array names FUNCMAP -regexp {^\w+$}]]
  #
  # Strip all comments
  #
  foreach funcname $flist {
    set FUNCMAP($funcname,defn) [strip_comments $FUNCMAP($funcname,defn)]
  }
  # note the extra \n at the end: so that md5 computes properly
  set FUNCMAP(:fcnlist) [join [lsort [array names FUNCMAP -regexp {^\w+$}]] "\n"]\n
  return [array get FUNCMAP]
}
#
# Upload a local file to the remote session.
#
proc upload_file {} {
  global EXPECTSSH_PROMPT OS spawn_id
  set bashscript {function get_upload_file() {
    local f
    local yn
    read -e -p 'Choose a file to be uploaded: ' f
    # canonicalize f: must do tilde expansion
    f=${f/#~/$HOME}
    if [ ! -e "$f" ]; then
      echo "Error: no such file, or file is not readable: $f"
      return 1
    fi
    read -p "Confirm: upload \"$f\" (y/n, default y): " yn
    [ -z "$yn" ] && yn=y
    [ "$yn" != y ] && return
    echo "File to be uploaded: $f"
    local outfile=/tmp/$(basename "$f")
    echo "Will be uploaded to: $outfile"
    }
    # execute the function
    get_upload_file
  }
  set main_spawn_id $spawn_id
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  set upload_file ""
  interact {
    -o -nobuffer -re "File to be uploaded: (.*)\r\nWill be uploaded to: (.*)\r" {
      set upload_file $interact_out(1,string)
      set outfile $interact_out(2,string)
    }
  }
  set spawn_id $main_spawn_id
  if { [file exists $upload_file] == 0 } {
    return
  }
  # Delimit the input with a space, and after each line is sent send \r so
  # the terminal does not scroll
  send " \[ -e \"$outfile\" -a ! -w \"$outfile\" ] && echo '$outfile is not writable, aborting upload.'\r"
  expect {
    -re "\n.*aborting" {
      return
    }
    -re $EXPECTSSH_PROMPT
  }
  send " exec 3> >(/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\")\r"
  send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&3; printf "\015"; done; exec 3>&-}
  send \r
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set upload_file_enc [exec "/bin/bash" "-c" "gzip -9 -c \"$upload_file\" | openssl enc -base64"]
  set c_len [string length $upload_file_enc]
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$upload_file_enc\n"] {
    send "[string trimright $line] "
    expect -re "\x0d$"
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    set precision [string length $c_len]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload to $outfile\r\n"
  send ". "
  expect ". "
  log_user 1
  expect -re $EXPECTSSH_PROMPT
}

proc load_mybashprefs_handler {client_sock decoded_args} {
  global load_mybashprefs_args
  #
  # We have a request to load bash prefs into the current shell, but we
  # only do that under certain conditions below. For example, "ssh
  # localhost uname" should NOT trigger loading bash prefs, but "ssh
  # localhost" should.
  #
  array set load_mybashprefs_args $decoded_args
}

#
# Escape the non-printing elements of PS1 marker, as per bash man page: see
# where it discusses "begin a sequence of non-printing characters, which could
# be used to embed a terminal control sequence into the prompt"
#
proc escape_ps1_marker {ps1_marker} {
  return [regsub -all {(\\033\[[^a-zA-Z]*[a-zA-Z])} $ps1_marker {\\[\1\\]}]
}

#
# Make a regexp out of the PS1 tail: basically, escape all left square brackets
# and handle bash's treatment of \$, which will render a dollar sign in the
# prompt except when root is in effect (then bash renders a pound sign).
proc ps1_tail_regexp {} {
  global EXPECTSSH_PS1_TAIL
  # handle left square bracket
  set ps1_tail_regexp [regsub -all {\x5b} $EXPECTSSH_PS1_TAIL {\\\0}]
  # handle \$
  return [regsub -all {\\\$} $ps1_tail_regexp {[\$#]}]
}

proc load_mybashprefs {EXPECTSSH_SHLVL {nest_level 0}} {
  global EXPECTSSH_PROMPT ANSI_RE_TEXT_FORMATTING EXPECTSSH_PS1_TAIL EXPECTSSH_TMPDIR MYBASHPREFS_PASSWORD
  global MARKER EXPECTSSH_MYBASHPREFS EXPECTSSH_PROFILE EXPECTSSH_FCN_LIST
  global EXPECTSSH_CORE EXPECTSSH_CORE_FCN_PREFIX MARKER_RE
  log_user 1
  send " echo \$BASH-\r"
  expect {
    -re "\n-.*$EXPECTSSH_PROMPT" { send_user "not a bash shell"; return }
    -re "\n/.*$EXPECTSSH_PROMPT" {}
    timeout {
      send_error "timeout in load_mybashprefs while testing for bash\n"
      return
    }
  }
  array set FUNCMAP [get_scripts]
  # Take just first 8 of the md5: to minimize characters sent over the wire
  set fcnlist_md5 [format "%.8s" [compute_md5 $FUNCMAP(:fcnlist)]]

  set mybashprefs ""

  # 
  # Everything is wrapped in function _ES_core
  #
  append mybashprefs "function _ES_core() {\n"
  append mybashprefs "export _ES_FCN_PREFIX=$FUNCMAP(:remote_file_prefix)\n"
  append mybashprefs "export EXPECTSSH_SHLVL=\$1\n"
  append mybashprefs "export fcnlist_md5=\$2\n"
  append mybashprefs "export EXPECTSSH_TMPDIR=$EXPECTSSH_TMPDIR\n"
  append mybashprefs "export EXPECTSSH_FCN_LIST=$EXPECTSSH_FCN_LIST\n"
  append mybashprefs "export EXPECTSSH_PS1_TAIL='[escape_ps1_marker $EXPECTSSH_PS1_TAIL]'\n"
  append mybashprefs "export EXPECTSSH_PROFILE=$EXPECTSSH_PROFILE\n"

  append mybashprefs "function _ES_marker() {\n"
  foreach marker_name [array names MARKER -regexp {^(\w+)$}] {
    append mybashprefs "$marker_name=$MARKER($marker_name)\n"
  }
  append mybashprefs {eval "echo \$$1"}
  append mybashprefs "\n}\n"
  append mybashprefs "export -f _ES_marker\n"

  ## see if previous command in history was the line to decode bashprefs, and if so delete it from history
  #append mybashprefs {history -p '!!'|grep -q ^' c=' && TMP=$(history|tail -1|awk '{print $1}') && history -d $TMP && unset TMP}
  #append mybashprefs \n
  #append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  ## NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  ## otherwise the line spacing gets all weird when typing out long bash commands
  #append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $EXPECTSSH_PS1_TAIL [join { {\[} {\0} {\]} } {}]]
  #append mybashprefs "'\n"

  foreach funcname [glob -nocomplain -directory $EXPECTSSH_CORE -tails *] {
    if {[regexp "^$EXPECTSSH_CORE_FCN_PREFIX" $funcname]==0} { continue }
    if {[regexp {^\w+$} $funcname]==0} { continue }
    append mybashprefs [slurp_file $EXPECTSSH_CORE/$funcname]
  }

  append mybashprefs "_ES_gen_stubs \$fcnlist_md5\n"

  set bashrc $EXPECTSSH_PROFILE/.bashrc
  if {[file exists $bashrc]} {
    append mybashprefs [slurp_file $bashrc]
  }

  # unset $c, set below
  append mybashprefs "unset c\n"
  #
  # END of function _ES_core
  #
  append mybashprefs "}\n"
  append mybashprefs "export -f _ES_core\n"
  set mybashprefs [strip_comments $mybashprefs]

  set pass [compute_pw $mybashprefs]
  send " f=$EXPECTSSH_MYBASHPREFS; c=\"\$(openssl enc -a -d -aes256 -in \$f)\" && eval \"\${c}\" && _ES_core $EXPECTSSH_SHLVL $fcnlist_md5\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file or directory).*$EXPECTSSH_PROMPT" {
      if { $nest_level > 0 } {
        # do not get in recursive loop attempting to upload + write out bash prefs
        return "NOT OK"
      }
      # compress all the bash commands, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk ... but watch out if this base64 string exceeds 4096 bytes (1024
      # for mac) which seems to be the terminal driver limit
      # (http://expect.sourceforge.net/FAQ.html#q76) "terminal input queue"
      # "typeahead buffer" MAX_INPUT
      # "getconf -a|grep MAX_INPUT" may help determine this value
      send "c=\$(history|tail -1|awk '{print \$1}') && history -d \$c && history -d \$((\$c-1)) && HISTCONTROL=ignoreboth:erasedups\r"
      expect -re $EXPECTSSH_PROMPT
      send " d=$EXPECTSSH_TMPDIR; \[ ! -d \$d ] && { mkdir \$d; chmod 1777 \$d; }\r"
      expect -re $EXPECTSSH_PROMPT
      #send_user "uploading $EXPECTSSH_MYBASHPREFS ...\n"
      # Note the leading space so it is not saved in bash history
      send " touch \$f; chmod 666 \$f\r"
      expect -re $EXPECTSSH_PROMPT
      log_user 0
      send " exec 3< <(echo '$pass')\r"
      expect -re {(.*\r)}
      # Hide password from being displayed
      regsub {'(.*)'} $expect_out(1,string) '[regsub -all . $pass *]' echoline
      send_user $echoline\n
      log_user 1
      expect -re $EXPECTSSH_PROMPT
      # Delimit the input with a space, and after each line is sent send \r so
      # the terminal does not scroll
      send " exec 4> >(openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out \$f)\r"
      send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&4; printf "\015"; done; exec 3<&- 4>&-}
      send \r
      expect {
        -re \r\n$ {}
        timeout {
          send_error "TIMEOUT in proc load_mybashprefs\r\n"
        }
      }
      send_script $mybashprefs 
      expect -re $EXPECTSSH_PROMPT
      return [load_mybashprefs $EXPECTSSH_SHLVL 1]
    }
    -re $EXPECTSSH_PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT2 in proc load_mybashprefs\r\n"; return "NOT OK" }
  }
  expect_before
  return "OK"
}

proc get_encrypted_func {funcname script} {
  set pw [compute_pw $script]
  set enc_script [exec /bin/bash -c {echo "$0"|gzip -9 -c|pw="$1" openssl enc -aes256 -a -pass env:pw} $script $pw]
  #regsub -all "\n" $enc_script {\n} enc_script
  #return [format {fname=%s;pw='%s';script=$'%s'} $funcname $pw $enc_script]
  return $enc_script
}

proc upload_script_handler {client_sock decoded_args} {
  set funcname $decoded_args
  array set FUNCMAP [get_scripts]
  set script ""
  append script "[get_encrypted_func $funcname $FUNCMAP($funcname,defn)]"
  puts $client_sock $script
  return ""
}

proc function_list_handler {client_sock -} {
  array set FUNCMAP [get_scripts]
  puts $client_sock $FUNCMAP(:fcnlist)
  return ""
}

proc script_password_handler {client_sock decoded_args} {
  set funcname $decoded_args
  array set FUNCMAP [get_scripts]
  set pw [compute_pw $FUNCMAP($funcname,defn)]
  puts -nonewline $client_sock $pw
  return
}

proc strip_comments {script} {
  # use negative lookahead so that comments beginning with 2 consecutive pound
  # signs will not get stripped
  return [regsub -all {(^|\n)\s*#(?!#)[^\n]*\n} $script {\1}]
}

proc send_script {script} {
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set remote_file_content_enc [exec "/bin/bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $script]
  set c_len [string length $remote_file_content_enc]
  set precision [string length $c_len]
  set delim " "
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$remote_file_content_enc\n"] {
    send "[string trimright $line]$delim"
    expect {
      # first time in this loop it could by \r\n
      -re "\r\n$" {}
      -re "\x0d$" {}
      timeout {
        send_error "TIMEOUT in send_script\r\n"
      }
    }
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  log_user 1
  send ".$delim"
  expect ".$delim"
  #send_user "\015"
}

# See if the custom prompt is in effect
proc check_prompt_marker {prompt_output_list} {
  array set prompt_output $prompt_output_list
  set ps1_tail_regexp [ps1_tail_regexp]
  if {[info exists prompt_output(1,string)]==1 && [string length $prompt_output(1,string)]>0} {
    return 1
  }
  return 0
}

proc main_prompt_checker {prompt_output_list} {
  global stdin_buf load_mybashprefs_args EXPECTSSH_PROMPT
  set stdin_buf ""
  if { [array size load_mybashprefs_args] > 0 } {
    if { [check_prompt_marker $prompt_output_list] == 0 } {
      set rc [load_mybashprefs [expr $load_mybashprefs_args(EXPECTSSH_SHLVL) + 1]]
      if { $rc == "OK" } {
        if { [info exists load_mybashprefs_args(EXPECTSSH_IN_SCREEN)] > 0 && $load_mybashprefs_args(EXPECTSSH_IN_SCREEN)==1 } {
          send " export EXPECTSSH_IN_SCREEN=1 && "
          send {printf "\033k${HOSTNAME}\033\134"}
          send \r
          expect -re $EXPECTSSH_PROMPT
        }
        if {[info exists load_mybashprefs_args(CMD_ARRAY)] > 0
          && $load_mybashprefs_args(CMD_ARRAY) != "declare -a CMD_ARRAY='()'"
          && [string length $load_mybashprefs_args(CMD_ARRAY)]>0
          } {
          send " $load_mybashprefs_args(CMD_ARRAY) && "
          send {eval "${CMD_ARRAY[@]}"}
          send \r
        }
      }
    }
  }
  array unset load_mybashprefs_args
}

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env EXPECTSSH_LOGFILE EXPECTSSH_PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(EXPECTSSH_SHLVL)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { cleanup_and_exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$EXPECTSSH_LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      open_logfile
      send_user "DEBUG MODE: sending output for this session to $EXPECTSSH_LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } elseif { $stdin_buf == "~u" } {
    upload_file
    set stdin_buf ""
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

##
##
## END OF PROCS
##
##
set EXPECTSSH_CONFIGDIR "$env(HOME)/.expect-ssh"
set rcfile "$EXPECTSSH_CONFIGDIR/config"

set options {
  { debug "turn on debug mode" }
  { profile.arg profile.lenio "choose which profile to use for custom functions/markers/handlers" }
  { timeout.arg 10 "expect pattern timeout value" }
  { test "run test cases (for devs only)" }
  { tmpdir "create a new temp directory for temp space; auto-delete when expect-ssh finishes" }
  { logfile.arg "" "write log to this file" }
}
append options "{killfile.arg /tmp/expect-ssh-kill-$env(USER) \"small script to kill an errant expect-ssh session\"}"

set usage "expect-ssh: a bash/screen/ssh utility tool.\n"
append usage "While inside any session, type these at a prompt:\n"
append usage "  ~d toggle debug mode\n"
append usage "  ~i force reload bash functions/preferences\n"
append usage "  ~u upload file (to ssh session)\n"
append usage "  ~k kill expect: useful if running screen, and you\n"
append usage "     want to resume screen from another desktop\n"
append usage "Upon starting, Expect statements can be placed in\n"
append usage "$rcfile and they get sourced. Options:\n"

if {[catch {array set opts [::cmdline::getKnownOptions argv $options $usage]} usage_msg]} {
  puts $usage_msg
  exit
}
set def_timeout $timeout
set timeout $opts(timeout)
#set send_slow {1 .1}
#set send_human {.1 .3 1 .05 2}

if { $def_timeout != $timeout } {
  send_user "Timeout set to: $timeout\n"
}
set spawn_out_slave_name 0
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*m}
set ANSI_RE_CURSOR_POSITIONING {\u001b\[(?:\d+;\d+[Hf]|\d+[ABCD])}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}
array set MARKER {}
set OS [exec uname -s]
array set load_mybashprefs_args {}
set EXPECTSSH_HOME [get_expectssh_home]
set env(EXPECTSSH_TMPDIR) [init_tmpdir $opts(tmpdir)]
set EXPECTSSH_TMPDIR $env(EXPECTSSH_TMPDIR)
set EXPECTSSH_MYBASHPREFS $EXPECTSSH_TMPDIR/mybashprefs.$env(USER)
if {[string length $opts(logfile)]>0} {
  set EXPECTSSH_LOGFILE $opts(logfile)
  puts "Log file set to: $opts(logfile)"
} else {
  set EXPECTSSH_LOGFILE $EXPECTSSH_TMPDIR/$env(USER).log
}
set EXPECTSSH_PROFILE $EXPECTSSH_HOME/$opts(profile)
set EXPECTSSH_PROFILE_OVERRIDES $EXPECTSSH_CONFIGDIR/$opts(profile)
set EXPECTSSH_CORE_FCN_PREFIX _ES_
set EXPECTSSH_CORE $EXPECTSSH_HOME/core
set EXPECTSSH_FCN_LIST $EXPECTSSH_TMPDIR/$env(USER).fcnlist
#set MARKER_RE (?:^|\x07|\n|\r|$ANSI_RE_GENERAL)[get_marker]\x08\.\[\r\n]
set MARKER_RE (?:^|\x07|\n|\r|$ANSI_RE_GENERAL)[get_marker]\x08\.\r(?:$ANSI_RE_CURSOR_POSITIONING)*\n
#
# Register core handlers
#
_ES_register_marker LOAD_MYBASHPREFS load_mybashprefs_handler
_ES_register_marker UPLOAD_SCRIPT upload_script_handler
_ES_register_marker GET_SCRIPT_PW script_password_handler
_ES_register_marker GET_FUNCTION_LIST function_list_handler

if {[file exists $rcfile]} {
  source $rcfile
}
# 
# Source core .exp files
#
foreach expfile [lsort [glob -nocomplain -directory $EXPECTSSH_CORE *.exp]] {
  source $expfile
}
#
# Source profile .exp files
#
foreach expfile [lsort [glob -nocomplain -directory $EXPECTSSH_PROFILE *.exp]] {
  source $expfile
}
#
# Source user's personal .exp files
#
if {[file isdirectory $EXPECTSSH_PROFILE_OVERRIDES]==1} {
  foreach expfile [lsort [glob -nocomplain -directory $EXPECTSSH_PROFILE_OVERRIDES *.exp]] {
    source $expfile
  }
}
# note: check_prompt_marker has logic that depends on the parenthesized
# patterns in EXPECTSSH_PROMPT: namely, the first grouped expression is
# indicative that the preferred PS1 prompt has been loaded.
set EXPECTSSH_PROMPT "(?:"
append EXPECTSSH_PROMPT "("
append EXPECTSSH_PROMPT [ps1_tail_regexp]
append EXPECTSSH_PROMPT ")(?:$ANSI_RE_GENERAL)*$"
append EXPECTSSH_PROMPT "|"
append EXPECTSSH_PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append EXPECTSSH_PROMPT ")"

if {[info exists env(EXPECTSSH_SHLVL)] == 1} {
  set env(EXPECTSSH_SHLVL) [expr $env(EXPECTSSH_SHLVL) + 1]
} else {
  set env(EXPECTSSH_SHLVL) 0
}
#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set stdin_buf ""

if { $opts(test) == 1 } {
  run_tests
  exit
}
if { $opts(debug) == 1 } {
  open_logfile
  send_user "DEBUG MODE: sending output for this session to $EXPECTSSH_LOGFILE\n"
}

set named_pipe $EXPECTSSH_TMPDIR/$env(USER).pipe
if {[file exists $named_pipe]==0} {
  exec mkfifo -m 600 $named_pipe
}
set command_server_pid [fork]
switch $command_server_pid {
  -1 { send_error "Fork attempt failed\n"
    exit
  }
  0 {
    # child: run server
    set sock [socket -server Command_Server -myaddr localhost 0]
    # -sockname returns address, hostname, and port number
    set port [lindex [fconfigure $sock -sockname] 2]
    send_error "Server is listening on port: $port\n"
    # tell parent what the port number is
    set chan [open $named_pipe w]
    puts $chan $port
    close $chan
    vwait forever
    exit
  }
}

if {[string length $opts(killfile)]>0} {
  set chan [open $opts(killfile) w]
  puts $chan "kill -KILL [pid] $command_server_pid"
  puts $chan "echo 'just killed processes [pid], $command_server_pid'"
  close $chan
  file attributes $opts(killfile) -permissions 0700
}

trap {resize_handler} WINCH
set chan [open $named_pipe r]
gets $chan EXPECTSSH_PORT
close $chan
send_error EXPECTSSH_PORT=$EXPECTSSH_PORT\n
set env(EXPECTSSH_PORT) $EXPECTSSH_PORT

spawn -noecho /bin/bash

match_max 10000
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)
# force-resize: needed if on Mac in terminal full screen mode
resize_handler
expect -re $EXPECTSSH_PROMPT
load_mybashprefs $env(EXPECTSSH_SHLVL)

if {[catch {
  interact {
    # "If two or more patterns can match the same output, only one action will
    # be executed. The action corresponds to the pattern that appears first in
    # the command."
    -re "." { process_keystroke $interact_out(0,string) }
    # "All the patterns before the -o apply to the user keystrokes. All the
    # patterns after the -o apply to the spawned process."
    -o
    -nobuffer -re $EXPECTSSH_PROMPT {main_prompt_checker [array get interact_out]}
  }
} err]} {
  send_error $::errorInfo\n
}

cleanup_and_exit
