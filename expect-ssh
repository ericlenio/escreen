#!/usr/bin/expect
# vim:filetype=expect
#
# Drop in replacement script for ssh, with helpful integrations to use bash,
# sudo, screen, and vim more effectively. Run with -help to see arguments.
#
# apt-get install tcllib
package require cmdline
package require md5

regsub -- {.*origin/([\d\.]+).*} [exec bash -c "cd [file dirname $argv0] && git status --porcelain -b|grep '^##'"] {\1} GIT_BRANCH

if {[string length $GIT_BRANCH]==0} {
  puts "Unable to parse git branch, stop."
  exit 1
}
set env(EXPECTSSH_TMPDIR) /tmp/.expect-ssh-$GIT_BRANCH
set EXPECTSSH_TMPDIR $env(EXPECTSSH_TMPDIR)
set EXPECTSSH_MYBASHPREFS $EXPECTSSH_TMPDIR/mybashprefs.$env(USER)
# if stdin is not a terminal, or $EXPECTSSH_SHLVL exists, then we just
# want to do regular ssh.
set overlay_test [exec bash -c {
  [ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }
  [ ! -t 0 -o -n "$EXPECTSSH_SHLVL" ] && echo overlay_flag
  true
}]

if {[regexp {overlay_flag} $overlay_test]==1} {
  # overlay the expect process with ssh, effectively leaving this script
  eval overlay /usr/bin/ssh $argv
}

set spawn_out_slave_name 0
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*[m]}
set ANSI_RE_CURSOR_POSITIONING {\u001b\\\[\d+;\d+[Hf]}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}

array set MARKER {}

set OS [exec uname -s]
set LOGFILE $EXPECTSSH_TMPDIR/$env(USER).log
match_max 10000
set EXPECTSSH_CONFIGDIR "$env(HOME)/.expect-ssh"
set rcfile "$EXPECTSSH_CONFIGDIR/config"
set is_marker_prompt 0
array set load_mybashprefs_args {}

##
##
## DEFINE ALL PROCS
##
##

#
# Optional arg is an index number, if not given then just return the regex of a
# generic marker.
proc get_marker {{idx ""}} {
  # Certain bash functions will send patterns (markers) which expect picks up
  # on to do further processing. The patterns are of the form of
  # GENERIC_MARKER.  It is required that after the pattern is sent there will
  # be a \n and then gzipped and base64 encoded data (optional), then a period
  # (not optional).
  set precision 2
  set GENERIC_MARKER_RE "~@(\[0-9]{$precision}):"
  if {[string length $idx]==0} { return $GENERIC_MARKER_RE }
  set marker [join [list ~@ [format "%0*d" $precision $idx] :] {}]
  return $marker
}

proc _ES_register_marker { marker_key handler } {
  global MARKER
  set idx [llength [array names MARKER -regexp {^(\w+)$}]]
  set MARKER($marker_key) [get_marker $idx]
  set MARKER($marker_key,idx) $idx
  set MARKER($marker_key,handler) $handler
  #puts "_ES_register_marker: registered new marker $marker_key with handler: $handler idx=$idx"
}

proc _ES_run_marker_handler { marker_idx } {
  global MARKER ANSI_RE_GENERAL
  set encoded_args ""
  set decoded_args ""
  expect \n
  expect {
    -re {([^\.]*)\.} {
      append encoded_args $expect_out(1,string)
    }
    -re {([^\.]{1,255})} {
      append encoded_args $expect_out(1,string)
      exp_continue
    }
  }
  # convert all \015 back to \n
  regsub -all "\015" $encoded_args "\n" encoded_args
  # clean out any cursor movement sequences that sometimes get thrown in by screen
  regsub -all $ANSI_RE_GENERAL $encoded_args "" encoded_args

  if {[string length [string trim $encoded_args]]>0} {
    if {[catch {
      set decoded_args [exec sh -c "printf '%s' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
    } err]} {
      send_error "ERROR decoding args: $err\r\n"
      return
    }
  }

  # find the handler and run it
  foreach key [array names MARKER -regexp {^(\w+)$}] {
    if {$marker_idx == $MARKER($key,idx)} {
      set handler $MARKER($key,handler)
      catch {
        eval [list $handler $decoded_args]
      } err
      if {[string length $err]>0} {
        send_error "ERROR invoking handler $handler: $err\r\n"
      }
      return
    }
  }
  send_error "ERROR in _ES_run_marker_handler: no handler found for idx=$marker_idx\r\n"
}

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

proc compute_md5 {s} {
  return [string tolower [md5::md5 -hex $s]]
}

proc compute_pw {s} {
  global MYBASHPREFS_PASSWORD
  set script_md5 [compute_md5 $s]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change. Md5 the result to make a shorter version of the
  # password.
  set pass [format "%.8s" [compute_md5 $MYBASHPREFS_PASSWORD-$script_md5]]
  return $pass
}

proc slurp_file {f} {
  set fp [open $f r]
  set file_data [read $fp]
  close $fp
  return $file_data
}

#
# User custom functions
#
proc get_scripts {} {
  global EXPECTSSH_PROFILE_OVERRIDES EXPECTSSH_TMPDIR EXPECTSSH_PROFILE EXPECTSSH_CORE env
  global EXPECTSSH_CORE_FCN_PREFIX
  array unset FUNCMAP
  set FUNCMAP(:remote_file) $EXPECTSSH_TMPDIR/$env(USER).FUNCMAP
  set FUNCMAP(:remote_file_prefix) $EXPECTSSH_TMPDIR/$env(USER).f.
  foreach dir [list $EXPECTSSH_CORE $EXPECTSSH_PROFILE $EXPECTSSH_PROFILE_OVERRIDES] {
    if { [file isdirectory $dir]==1 } {
      foreach funcname [glob -nocomplain -directory $dir -tails *] {
        if { $funcname eq "README" } { continue }
        if {[regexp "^$EXPECTSSH_CORE_FCN_PREFIX" $funcname]==1} { continue }
        if {[regexp {^\w+$} $funcname]==0} { continue }
        set func_def [slurp_file $dir/$funcname]
        set FUNCMAP($funcname) ""
        set FUNCMAP($funcname,defn) $func_def
        set FUNCMAP($funcname,remote_file) $FUNCMAP(:remote_file_prefix)$funcname
      }
    }
  }
  set flist [lsort [array names FUNCMAP -regexp {^\w+$}]]
  #
  # Strip all comments
  #
  foreach funcname $flist {
    set FUNCMAP($funcname,defn) [strip_comments $FUNCMAP($funcname,defn)]
  }
  set FUNCMAP(:fcnlist) [join [lsort [array names FUNCMAP -regexp {^\w+$}]] "\n"]
  return [array get FUNCMAP]
}

proc download_default_file_handler {decoded_args} {
  array set args $decoded_args
  set outfile [get_download_filename $args(default_file_name)]
  if { $outfile == "" } {
    # discontinue downloading
    send "\r"
  } else {
    send "$outfile\r"
    expect -ex \n
  }
}

proc get_download_filename {default_file_name} {
  global EXPECTSSH_PROMPT OS spawn_id
  set default_outfile "/tmp/$default_file_name"
  set outfile ""
  set main_spawn_id $spawn_id
  set bashscript {function get_download_file() {
    read -e -p 'Save downloaded file to (leave blank to cancel): ' f
    if [ -z "$f" ]; then return; fi
    if [ -e "$f" -a ! -w "$f" ]; then echo "$f is not writable"; return; fi
    local dir=$(dirname "$f")
    if [ -z "$dir" ]; then dir=$(pwd); fi
    if [ ! -e "$f" -a ! -w "$dir" ]; then echo "Directory $dir is not writable"; return; fi
    echo "File will be downloaded to: $f"
    }
    get_download_file
  }
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  expect ": "
  send $default_outfile
  interact {
    -o -nobuffer -re "File will be downloaded to: (.*)\r" {
      set outfile $interact_out(1,string)
    }
  }
  set spawn_id $main_spawn_id
  return $outfile
}

proc download_data_handler {decoded_args} {
  array set args $decoded_args
  set outfile $args(outfile)
  set l -1
  if { [catch {
    set chan [open "|/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\"" w]
    fconfigure $chan -translation binary -encoding binary
    puts $chan $args(content)
    flush $chan
    close $chan
    set l [file size $outfile]
    send_user "DONE...downloaded to $outfile, $l bytes"
    } err] } {
    send_error "ERROR in proc download: $err\r\n"
  }
  return $l
}

#
# Upload a local file to the remote session.
#
proc upload_file {} {
  global EXPECTSSH_PROMPT OS spawn_id
  set bashscript {function get_upload_file() {
    local f
    local yn
    read -e -p 'Choose a file to be uploaded: ' f
    # canonicalize f: must do tilde expansion
    f=${f/#~/$HOME}
    if [ ! -e "$f" ]; then
      echo "Error: no such file, or file is not readable: $f"
      return 1
    fi
    read -p "Confirm: upload \"$f\" (y/n, default y): " yn
    [ -z "$yn" ] && yn=y
    [ "$yn" != y ] && return
    echo "File to be uploaded: $f"
    local outfile=/tmp/$(basename "$f")
    echo "Will be uploaded to: $outfile"
    }
    # execute the function
    get_upload_file
  }
  set main_spawn_id $spawn_id
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  set upload_file ""
  interact {
    -o -nobuffer -re "File to be uploaded: (.*)\r\nWill be uploaded to: (.*)\r" {
      set upload_file $interact_out(1,string)
      set outfile $interact_out(2,string)
    }
  }
  set spawn_id $main_spawn_id
  if { [file exists $upload_file] == 0 } {
    return
  }
  # Delimit the input with a space, and after each line is sent send \r so
  # the terminal does not scroll
  send " \[ -e \"$outfile\" -a ! -w \"$outfile\" ] && echo '$outfile is not writable, aborting upload.'\r"
  expect {
    -re "\n.*aborting" {
      return
    }
    -re $EXPECTSSH_PROMPT
  }
  send " exec 3> >(/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\")\r"
  send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&3; printf "\015"; done; exec 3>&-}
  send \r
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set upload_file_enc [exec "/bin/bash" "-c" "gzip -9 -c \"$upload_file\" | openssl enc -base64"]
  set c_len [string length $upload_file_enc]
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$upload_file_enc\n"] {
    send "[string trimright $line] "
    expect -re "\x0d$"
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    set precision [string length $c_len]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload to $outfile\r\n"
  send ". "
  expect ". "
  log_user 1
  expect -re $EXPECTSSH_PROMPT
}

proc load_mybashprefs_handler {decoded_args} {
  global load_mybashprefs_args
  #
  # We have a request to load bash prefs into the current shell, but we
  # only do that under certain conditions below. For example, "ssh
  # localhost uname" should NOT trigger loading bash prefs, but "ssh
  # localhost" should.
  #
  array set load_mybashprefs_args $decoded_args
}

#
# Escape the non-printing elements of PS1 marker, as per bash man page: see
# where it discusses "begin a sequence of non-printing characters, which could
# be used to embed a terminal control sequence into the prompt"
#
proc escape_ps1_marker {ps1_marker} {
  return [regsub -all {(\\033\[[^a-zA-Z]*[a-zA-Z])} $ps1_marker {\\[\1\\]}]
}

proc load_mybashprefs {EXPECTSSH_SHLVL {nest_level 0}} {
  global EXPECTSSH_PROMPT ANSI_RE_TEXT_FORMATTING EXPECTSSH_PS1_TAIL EXPECTSSH_TMPDIR MYBASHPREFS_PASSWORD
  global MARKER EXPECTSSH_MYBASHPREFS EXPECTSSH_PROFILE EXPECTSSH_FCN_LIST
  global EXPECTSSH_CORE EXPECTSSH_CORE_FCN_PREFIX
  log_user 1
  # TO DO: verify we are in bash
  send " echo \$BASH-\r"
  expect {
    -ex "\n-" { send_user "not a bash shell"; return }
    -ex "\n/" {}
    timeout {
      send_error "timeout in load_mybashprefs while testing for bash\n"
      return
    }
  }
  array set FUNCMAP [get_scripts]
  set fcnlist_md5 [format "%.8s" [compute_md5 $FUNCMAP(:fcnlist)]]

  set mybashprefs ""

  # 
  # Everything is wrapped in function _ES_core
  #
  append mybashprefs "function _ES_core() {\n"
  append mybashprefs "export _ES_FCN_PREFIX=$FUNCMAP(:remote_file_prefix)\n"
  append mybashprefs "export EXPECTSSH_SHLVL=\$1\n"
  append mybashprefs "export fcnlist_md5=\$2\n"
  append mybashprefs "export EXPECTSSH_TMPDIR=$EXPECTSSH_TMPDIR\n"
  append mybashprefs "export EXPECTSSH_FCN_LIST=$EXPECTSSH_FCN_LIST\n"
  append mybashprefs "export EXPECTSSH_PS1_TAIL='[escape_ps1_marker $EXPECTSSH_PS1_TAIL]'\n"
  append mybashprefs "export EXPECTSSH_PROFILE=$EXPECTSSH_PROFILE\n"

  append mybashprefs "function _ES_marker() {\n"
  append mybashprefs "local MARKER\n"
  append mybashprefs "declare -A MARKER=("
  foreach marker_name [array names MARKER -regexp {^(\w+)$}] {
    append mybashprefs "\[$marker_name]=$MARKER($marker_name) "
  }
  append mybashprefs ")\n"
  append mybashprefs {echo ${MARKER[$1]}}
  append mybashprefs "\n}\n"
  append mybashprefs "export -f _ES_marker\n"

  ## see if previous command in history was the line to decode bashprefs, and if so delete it from history
  #append mybashprefs {history -p '!!'|grep -q ^' c=' && TMP=$(history|tail -1|awk '{print $1}') && history -d $TMP && unset TMP}
  #append mybashprefs \n
  #append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  ## NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  ## otherwise the line spacing gets all weird when typing out long bash commands
  #append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $EXPECTSSH_PS1_TAIL [join { {\[} {\0} {\]} } {}]]
  #append mybashprefs "'\n"

  foreach funcname [glob -nocomplain -directory $EXPECTSSH_CORE -tails *] {
    if {[regexp "^$EXPECTSSH_CORE_FCN_PREFIX" $funcname]==0} { continue }
    if {[regexp {^\w+$} $funcname]==0} { continue }
    append mybashprefs [slurp_file $EXPECTSSH_CORE/$funcname]
  }

  append mybashprefs "_ES_gen_stubs \$fcnlist_md5\n"

  set bashrc $EXPECTSSH_PROFILE/.bashrc
  if {[file exists $bashrc]} {
    append mybashprefs [slurp_file $bashrc]
  }

  # unset $c, set below
  append mybashprefs "unset c\n"
  #
  # END of function _ES_core
  #
  append mybashprefs "}\n"
  append mybashprefs "export -f _ES_core\n"
  set mybashprefs [strip_comments $mybashprefs]

  set pass [compute_pw $mybashprefs]
  #send " f=$EXPECTSSH_MYBASHPREFS; c=\"\$(openssl enc -a -d -aes256 -in \$f)\" && eval \"\${c}\" && _ES_core $EXPECTSSH_SHLVL $fcnlist_md5\r"
  send " f=$EXPECTSSH_MYBASHPREFS; c=\"\$(openssl enc -a -d -aes256 -in \$f)\" && eval \"\${c}\"\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file or directory).*$EXPECTSSH_PROMPT" {
      if { $nest_level > 0 } {
        # do not get in recursive loop attempting to upload + write out bash prefs
        return "NOT OK"
      }
      # compress all the bash commands, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk ... but watch out if this base64 string exceeds 4096 bytes (1024
      # for mac) which seems to be the terminal driver limit
      # (http://expect.sourceforge.net/FAQ.html#q76) "terminal input queue"
      # "typeahead buffer" MAX_INPUT
      # "getconf -a|grep MAX_INPUT" may help determine this value
      send "c=\$(history|tail -1|awk '{print \$1}') && history -d \$c && history -d \$((\$c-1)) && HISTCONTROL=ignoreboth:erasedups\r"
      expect -re $EXPECTSSH_PROMPT
      send " d=$EXPECTSSH_TMPDIR; \[ ! -d \$d ] && { mkdir \$d; chmod 1777 \$d; }\r"
      expect -re $EXPECTSSH_PROMPT
      #send_user "uploading $EXPECTSSH_MYBASHPREFS ...\n"
      # Note the leading space so it is not saved in bash history
      send " touch \$f; chmod 666 \$f\r"
      expect -re $EXPECTSSH_PROMPT
      log_user 0
      send " exec 3< <(echo '$pass')\r"
      expect -re {(.*\r)}
      # Hide password from being displayed
      regsub {'(.*)'} $expect_out(1,string) '[regsub -all . $pass *]' echoline
      send_user $echoline\n
      log_user 1
      expect -re $EXPECTSSH_PROMPT
      # Delimit the input with a space, and after each line is sent send \r so
      # the terminal does not scroll
      send " exec 4> >(openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out \$f)\r"
      send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l >&4; printf "\015"; done; exec 3<&- 4>&-}
      send \r
      expect -re \r\n$
      send_script $mybashprefs 
      expect -re $EXPECTSSH_PROMPT
      return [load_mybashprefs $EXPECTSSH_SHLVL 1]
    }
    -re $EXPECTSSH_PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
      send " _ES_core $EXPECTSSH_SHLVL $fcnlist_md5\r"
      # do NOT wait for prompt here, _ES_core may emit 1 or more markers for handling,
      # which will only be caught by the interact loop
      #expect -re $EXPECTSSH_PROMPT
    }
    timeout { send_error "TIMEOUT in proc load_mybashprefs\r\n"; return "NOT OK" }
  }
  #exp_internal -f /tmp/log 1

  #upload_and_source_script $bootstrap_funcs $FUNCMAP(:remote_file)
  return "OK"
}
### END of load_mybashprefs

proc get_encrypted_func {funcname script} {
  set pw [compute_pw $script]
  set enc_script [exec /bin/bash -c {echo "$0"|gzip -9 -c|pw="$1" openssl enc -aes256 -a -pass env:pw} $script $pw]
  regsub -all "\n" $enc_script {\n} enc_script
  return [format {import[funcname]=%s;import[pw]='%s';import[script]=$'%s'} $funcname $pw $enc_script]
}

proc upload_script_handler {decoded_args} {
  set funcname $decoded_args
  array set FUNCMAP [get_scripts]
  set script ""
  append script "[get_encrypted_func $funcname $FUNCMAP($funcname,defn)]\n"
  send_script $script
  return ""
}

proc function_list_handler {-} {
  array set FUNCMAP [get_scripts]
  send_script $FUNCMAP(:fcnlist)
  return ""
}

proc script_password_handler {decoded_args} {
  set funcname $decoded_args
  array set FUNCMAP [get_scripts]
  set pw [compute_pw $FUNCMAP($funcname,defn)]
  expect -re "password:$"
  send "$pw\r"
  send_user "($funcname)\r\n"
}

proc strip_comments {script} {
  # use negative lookahead so that comments beginning with 2 consecutive pound
  # signs will not get stripped
  return [regsub -all {(^|\n)\s*#(?!#)[^\n]*\n} $script {\1}]
}

proc send_script {script} {
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 0
  set remote_file_content_enc [exec "/bin/bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $script]
  set c_len [string length $remote_file_content_enc]
  set precision [string length $c_len]
  set delim " "
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$remote_file_content_enc\n"] {
    send "[string trimright $line]$delim"
    expect {
      # first time in this loop it could by \r\n
      -re "\r\n$" {}
      -re "\x0d$" {}
    }
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload\r\n"
  send ".$delim"
  expect ".$delim"
  log_user 1
}

# See if the custom prompt is in effect
proc check_prompt_marker {arr} {
  global is_marker_prompt EXPECTSSH_PS1_TAIL
  upvar $arr arr_ref
  set marker {*}$EXPECTSSH_PS1_TAIL
  if { [info exists arr_ref(2,string)]==1 && [string trim $arr_ref(2,string)]==$marker } {
    set is_marker_prompt 1
  } else {
    set is_marker_prompt 0
  }
  return $is_marker_prompt
}

proc main_prompt_checker {arr} {
  global stdin_buf interact_out expect_out load_mybashprefs_args EXPECTSSH_PROMPT
  set stdin_buf ""
  if { [array size load_mybashprefs_args] > 0 } {
    if { [check_prompt_marker $arr] == 0 } {
      set rc [load_mybashprefs [expr $load_mybashprefs_args(EXPECTSSH_SHLVL) + 1]]
      if { $rc == "OK" } {
        if { [info exists load_mybashprefs_args(EXPECTSSH_IN_SCREEN)] > 0 && $load_mybashprefs_args(EXPECTSSH_IN_SCREEN)==1 } {
          send " export EXPECTSSH_IN_SCREEN=1 && "
          send {printf "\033k${HOSTNAME}\033\134"}
          send \r
          expect -re $EXPECTSSH_PROMPT
        }
        if { [info exists load_mybashprefs_args(CMD_ARRAY)] > 0
          && $load_mybashprefs_args(CMD_ARRAY) != "declare -a CMD_ARRAY='()'"
          && [string length $load_mybashprefs_args(CMD_ARRAY)]>0
          } {
          send " $load_mybashprefs_args(CMD_ARRAY) && "
          send {eval "${CMD_ARRAY[@]}"}
          send \r
        }
      }
    }
  }
  array unset load_mybashprefs_args
}

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env LOGFILE EXPECTSSH_PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(EXPECTSSH_SHLVL)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      # truncate the file first
      close [open $LOGFILE "w"]
      exp_internal -f $LOGFILE 0
      send_user "DEBUG MODE: sending output for this session to $LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } elseif { $stdin_buf == "~u" } {
    upload_file
    set stdin_buf ""
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

##
##
## END OF PROCS
##
##

set options {
  { debug "" "turn on debug mode" }
  { shell "" "don't ssh but instead just run a bash shell" }
  { profile.arg profile.lenio "choose which profile to use for custom functions/markers/handlers" }
  { timeout.arg 10 "expect pattern timeout value" }
}

set usage "expect-ssh: an ssh wrapper/replacement tool.\n"
append usage "All arguments other than the ones below are passed directly to ssh.\n"
append usage "While inside any session, type these at a prompt:\n"
append usage "  ~d      toggle debug mode (writes to $LOGFILE)\n"
append usage "  ~i      force reload bash functions/preferences\n"
append usage "  ~u      upload file (to ssh session)\n"
append usage "  ~k      kill expect: useful if running screen, and you\n"
append usage "          want to resume screen from another desktop\n"
append usage "Upon starting, Expect statements can be placed in\n"
append usage "$rcfile and they get sourced. Options:\n"

array set opts [::cmdline::getKnownOptions argv $options $usage]
set def_timeout $timeout
set timeout $opts(timeout)
#set send_slow {1 .1}
#set send_human {.1 .3 1 .05 2}

if { $def_timeout != $timeout } {
  send_user "Timeout set to: $timeout\n"
}
set EXPECTSSH_PROFILE [file dirname $argv0]/$opts(profile)
set EXPECTSSH_PROFILE_OVERRIDES $EXPECTSSH_CONFIGDIR/$opts(profile)
set EXPECTSSH_CORE_FCN_PREFIX _ES_
set EXPECTSSH_CORE [file dirname $argv0]/core
set EXPECTSSH_FCN_LIST $EXPECTSSH_TMPDIR/fcnlist.$env(USER)

#
# Register some core handlers
#
_ES_register_marker LOAD_MYBASHPREFS load_mybashprefs_handler
_ES_register_marker UPLOAD_SCRIPT upload_script_handler
_ES_register_marker DOWNLOAD_DEFAULT_FILE download_default_file_handler
_ES_register_marker DOWNLOAD_DATA download_data_handler
_ES_register_marker GET_SCRIPT_PW script_password_handler
_ES_register_marker GET_FUNCTION_LIST function_list_handler

if {[file exists $rcfile]} {
  source $rcfile
}

# 
# Source core .exp files
#
foreach expfile [lsort [glob -nocomplain -directory $EXPECTSSH_CORE *.exp]] {
  source $expfile
}
#
# Source profile .exp files
#
foreach expfile [lsort [glob -nocomplain -directory $EXPECTSSH_PROFILE *.exp]] {
  source $expfile
}
#
# Source user's personal .exp files
#
if {[file isdirectory $EXPECTSSH_PROFILE_OVERRIDES]==1} {
  foreach expfile [lsort [glob -nocomplain -directory $EXPECTSSH_PROFILE_OVERRIDES *.exp]] {
    source $expfile
  }
}

set EXPECTSSH_PROMPT "(?:"
append EXPECTSSH_PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append EXPECTSSH_PROMPT "|"
append EXPECTSSH_PROMPT "([regsub -all {([\[])} $EXPECTSSH_PS1_TAIL [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append EXPECTSSH_PROMPT ")"

if {[info exists env(EXPECTSSH_SHLVL)] == 1} {
  set env(EXPECTSSH_SHLVL) [expr $env(EXPECTSSH_SHLVL) + 1]
} else {
  set env(EXPECTSSH_SHLVL) 0
}
#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set local_shell_only 0
set stdin_buf ""

if { $opts(shell) == 1 } {
  set local_shell_only 1
}
if { $opts(debug) == 1 } {
  # truncate the file first
  close [open $LOGFILE "w"]
  exp_internal -f $LOGFILE 0
  send_user "DEBUG MODE: sending output for this session to $LOGFILE\n"
}

trap { resize_handler } WINCH

if { $local_shell_only == 1 } {
  eval [list spawn -noecho] /bin/bash
} else {
  eval [list spawn -noecho] /usr/bin/ssh $argv
}
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)
# force-resize: needed if on Mac in terminal full screen mode
resize_handler
load_mybashprefs $env(EXPECTSSH_SHLVL)
set marker_re (?:^|\x07|\n|\r)[get_marker]

interact {
  # "If two or more patterns can match the same output, only one action will
  # be executed. The action corresponds to the pattern that appears first in
  # the command."
  -re "." { process_keystroke $interact_out(0,string) }
  # "All the patterns before the -o apply to the user keystrokes. All the
  # patterns after the -o apply to the spawned process."
  -o
  -nobuffer -re $EXPECTSSH_PROMPT {main_prompt_checker interact_out}
  -nobuffer -re $marker_re {
    set marker_idx $interact_out(1,string)
    _ES_run_marker_handler $marker_idx
  }
}
