#!/bin/bash
# vim:filetype=expect
#
# Drop in replacement script for ssh. Run with -help to see arguments.

if [ ! -t 0 ]; then
  exec /usr/bin/ssh "$@"
fi

export EXP_FILE=/tmp/ssh.expect.$USER
cat > $EXP_FILE << 'EXPECT_EOF' && exec /usr/bin/expect -c "set EXEC $(basename $0)" -f $EXP_FILE -- "$@"
# apt-get install tcllib
package require md5

file delete $env(EXP_FILE)

#set mybashprefs "$env(HOME)/.remoteadmin/bashrc"
#send_error "Running $argv0\n"
set spawn_out_slave_name 0
#exp_internal -f /tmp/ssh.log 1
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*[m]}
set ANSI_RE_CURSOR_POSITIONING {\u001b\\\[\d+;\d+[Hf]}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}
set COPY_TO_CLIPBOARD_BEGIN_RE [join {\n ~ {copy_to_clipboard:([^:]+):} } "" ]
set LOAD_MYBASHPREFS_MARKER "LOAD_MYBASHPREFS_MARKER"
set LOAD_MYBASHPREFS_MARKER_RE [join [ list $LOAD_MYBASHPREFS_MARKER {:([^:]+):(\d+\.\d+):(\d+)} ] ""]
set DOWNLOAD_FILE_BEGIN_RE [join { ~ {DOWNLOAD_FILE\|([^\|]+)\|([^\|]+)\|} } "" ]
set HAS_BASH 0
# PS1_MARKER is a non-regexp marker in the normal PS1 prompt that we search for
# in certain situations to see if we need to load bash prefs. Watch that it
# works in regular bash, as well as inside a screen session because screen
# will translate many ANSI escape codes.
#
# TO DO: figure out why screen always translates "\033[9Xm" to
# "\033[3Xm\033[9Xm" for X=0..9. It won't hurt us here because the 
# marker is still in the PS1 string.
#set PS1_MARKER {\033[32m:\033[7m$\033[0m }
set PS1_MARKER {:\033[7m$\033[0m }
#set PROMPT "($ANSI_RE_TEXT_FORMATTING)*(?::(?:$ANSI_RE_TEXT_FORMATTING))*(#|\\\$)($ANSI_RE_TEXT_FORMATTING)* $"
set PROMPT "(?:"
append PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append PROMPT "|"
append PROMPT "([regsub -all {([\$\[])} $PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT ")"
set OS [exec uname -s]
set LD_SUPPORT_BASIC_AUTH secret

set rcfile "$env(HOME)/.expect-ssh/config"
if {[file exists $rcfile]} {
  source $rcfile
}

if {[info exists env(SSH_EXPECT)] == 1} {
  set env(SSH_EXPECT) [expr $env(SSH_EXPECT) + 1]
} else {
  set env(SSH_EXPECT) 0
}

set IS_INITIALIZED 0
set CTRL_Z \032
set LOGFILE "/tmp/ssh.log"
match_max 10000

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

array set clipboard_processed {}
proc copy_to_clipboard {time_of_day} {
  global PROMPT OS ANSI_RE_GENERAL clipboard_processed
  if { [info exists clipboard_processed($time_of_day)] == 1 } {
    return
  }
  set clipboard_processed($time_of_day) 1
  set clipboard_data ""
  set max_clipboard_data_len 1000000
  log_user 1
  expect {
    -re [join {"(.*)(?:\[\\r\\n](?:$ANSI_RE_GENERAL)*|^)" ~ copy_to_clipboard_EOF} ""] {
      append clipboard_data $expect_out(1,string)
      #regsub -all \000 $clipboard_data "\n" clipboard_data
      #regsub -all {\033\[\d+C} $clipboard_data "" clipboard_data
      if { $OS == "Darwin" } {
        exec sh -c "printf '%s\n' \"\$0\" | openssl enc -base64 -d | gzip -d -c | pbcopy" $clipboard_data
      } elseif { $OS == "Linux" } {
        exec sh -c "printf '%s\n' \"\$0\" | openssl enc -base64 -d | gzip -d -c | clipit" $clipboard_data
      } else {
        send_user "copy_to_clipboard: need handling for $OS"
        return
      }
      set l [string length $clipboard_data]
      return $l
    }
    -re "(.{1,255})" {
      append clipboard_data $expect_out(1,string)
      if { [string length $clipboard_data] > $max_clipboard_data_len } {
        # safety net: probably something is wrong
        send_user "MAX LENGTH EXCEEDED ($max_clipboard_data_len) for copy_to_clipboard"
      } else {
        exp_continue
      }
    }
    timeout { send_error "copy_to_clipboard: timeout waiting for file" }
  }
  log_user 1
}

proc get_download_filename {default_file_name} {
  global PROMPT
  set default_outfile "/tmp/$default_file_name"
  spawn /bin/bash
  set outfile ""
  expect -re $PROMPT
  send " read -e -i '$default_outfile' -p 'Save downloaded file to: ' ans && echo ans=\$ans\r"
  interact {
    -o
    -re "\\nans=(\[^\\r\\n]*).*$PROMPT" {
      set outfile $interact_out(1,string)
      send "exit\r"
    }
  }
  return $outfile
}

array set download_processed {}
proc download {default_file_name time_of_day} {
  global PROMPT OS ANSI_RE_GENERAL download_processed
  if { [info exists download_processed($time_of_day)] == 1} {
    # This download request was already processed
    return
  }
  set download_processed($time_of_day) 1
  set outfile [get_download_filename $default_file_name]
  if { $outfile == "" } {
    # discontinue downloading
    send "NO\r"
    return
  } else {
    send "y\r"
    expect -ex \n
  }

  set data ""
  set max_clipboard_data_len 1000000
  log_user 1
  expect {
    -re "(.*)(?:\[\\r\\n](?:$ANSI_RE_GENERAL)*|^)~DOWNLOAD_FILE_EOF" {
      append data $expect_out(1,string)
      exec sh -c "printf '%s\n' \"\$0\" | openssl enc -base64 -d | gzip -d -c > $outfile && chmod 600 $outfile" $data
      set l [file size $outfile]
      puts "downloaded to $outfile, $l bytes"
      return $l
    }
    -re "(.{1,255})" {
      append data $expect_out(1,string)
      if { [string length $data] > $max_clipboard_data_len } {
        # safety net: probably something is wrong
        send_user "MAX LENGTH EXCEEDED ($max_clipboard_data_len) for download"
      } else {
        exp_continue
      }
    }
    timeout { send_user "download: timeout waiting for file!!" }
  }
  log_user 1
}

proc paste_from_clipboard_in_vim {} {
  global OS PROMPT ANSI_RE_SHOW_CURSOR
  send ":shell\r"
  expect -re $PROMPT
  # encode the clipboard data and send it across the wire, decoding it on the
  # other end, and store it in the VIM_CLIPBOARD file.
  # Leading space before cat so as to not save it to history
  send " cat << EOF | openssl enc -base64 -d | gzip -d -c > \$VIM_CLIPBOARD\r"
  expect -re "> $"
  if { "$OS" == "Linux" } {
    set buf [exec clipit -c | gzip -9 -c | openssl enc -base64]
  } elseif { "$OS" == "Darwin" } {
    set buf [exec pbpaste | gzip -9 -c | openssl enc -base64]
  }
  foreach line [split $buf] {
    send $line\r
    expect -re "> $"
  }
  send "EOF\r"
  expect -re $PROMPT
  send "exit\r"
  expect {
    -re $ANSI_RE_SHOW_CURSOR {}
    timeout {send_error "TIMEOUT during paste, aborting"; return}
  }
  # read the file and put it in the unnamed register
  send {:let @"=join(readfile($VIM_CLIPBOARD),"\n")}
  send "\r"
  expect {
    -re $ANSI_RE_SHOW_CURSOR {}
    timeout {send_error "TIMEOUT #2 during paste, aborting"; return}
  }
  # paste contents of unnamed register
  send "P"
}

proc load_mybashprefs {SSH_EXPECT} {
  global PROMPT HAS_BASH ANSI_RE_TEXT_FORMATTING PS1_MARKER LOAD_MYBASHPREFS_MARKER ANSI_RE_GENERAL
  if { $HAS_BASH == 0 } {
    send_user "not a bash shell"
    return
  }
  log_user 0
  # verify we are in bash
  send " echo 'test for bash'\r"
  expect {
    -re "\\r\\ntest for bash\\r\\n.*$PROMPT" {}
    timeout {
      send_error "timeout in load_mybashprefs while testing for bash\n"
      return
    }
  }
  set mybashprefs_file /tmp/.mybashprefs
  set mybashprefs "export MYBASHPREFS_FILE=$mybashprefs_file\n"
  append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  # NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  # otherwise the line spacing gets all weird when typing out long bash commands
  append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $PS1_MARKER [join { {\[} {\0} {\]} } {}]]
  append mybashprefs "'\n"
  append mybashprefs "export LOAD_MYBASHPREFS_MARKER='" $LOAD_MYBASHPREFS_MARKER "'\n"
  append mybashprefs {
unset PROMPT_COMMAND
export VIM_CLIPBOARD=/tmp/vim.clipboard.$USER
touch $VIM_CLIPBOARD
chmod 600 $VIM_CLIPBOARD || {
  echo "WARNING: could not chmod on $VIM_CLIPBOARD, halting."
  return
}

export VIMINIT='map <c-v> :echon "~" "paste_from_clipboard_in_vim"<cr>|vnoremap <C-c> y:call writefile(split(@","\n","b"),$VIM_CLIPBOARD)<cr>:!copy_to_clipboard $VIM_CLIPBOARD<cr>|colorscheme elflord|syntax enable|set noswapfile number hlsearch incsearch sw=2 ignorecase wrap nocompatible ruler ai showmatch modeline modelines=5 nobackup nowritebackup textwidth=0 expandtab formatoptions=croql wildignore=*.class path=.,,**|autocmd Filetype java setlocal omnifunc=javacomplete#Complete'
export EDITOR=/usr/bin/vim
export FCEDIT=$EDITOR

function copy_to_clipboard() {
  local file_to_copy="$1"
  # boundary for expect-ssh to pick up the file:
  printf "%s:%s:" "~copy_to_clipboard" $(get_time_with_millis)
  if [ -z "$file_to_copy" ]; then
    # copy stdin to clipboard
    file_to_copy="-"
  fi
  # use perl to remove the last \n on the last line, and minimally set a hyphen
  # character in the stream so as to not pass 0 bytes to clipit (which causes
  # it to block)
  perl -pe 'BEGIN{$n=0;}END{print "-" if $n==0}$n+=length($_);chomp if eof' -- "$file_to_copy" | gzip -9 -c | openssl enc -base64
  # ending boundary
  printf "~%s\n" "copy_to_clipboard_EOF"
}
export -f copy_to_clipboard

function download() {
  local file="$1"
  # boundary for expect-ssh to pick up the file:
  if [ ! -e "$file" ]; then
    echo "Error: no such file: $file"
    return
  fi
  printf "%s|%s|%s|" "~DOWNLOAD_FILE" $(basename $file) $(get_time_with_millis)
  local ans
  # Only continue if a valid download filename was picked in get_download_filename
  read -p "Continue? " ans
  if [ "$ans" != y ]; then
    return
  fi
  gzip -9 -c $file | openssl enc -base64
  # ending boundary
  printf "~%s:%s\n" "DOWNLOAD_FILE_EOF" $file
}
export -f download

function openssl_show_cert() {
  local cert=$1
  if [ -z "$cert" ]; then
    # assume stdin
    cert="-"
  fi
  openssl x509 -in $cert -noout -text
}
export -f openssl_show_cert

function openssl_s_client_showcerts() {
  local hostport="$1"
  local host=${hostport%%:[0-9]*}
  local port=${hostport##*:}
  if [ "$host" = "$hostport" -o "$port" = "$hostport" ]; then
    echo "Usage: ${FUNCNAME[0]} host.example.com:port"
    return
  fi
  echo | openssl s_client -showcerts -connect $host:$port
}
export -f openssl_s_client_showcerts

function pathadd() {
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="${PATH:+"$PATH:"}$1"
  fi
}

function l() {
  local os=$(uname -s)
  if [ $os = Darwin ]; then
    ls -laF "$@"
  else
    ls -laF --time-style=+'%D %H:%M:%S' "$@"
  fi
}
unalias l 2>/dev/null
export -f l

function vimf() {
  local patt="$1"
  if [ -z "$patt" ]; then
    patt="*"
  else
    patt="*$patt*"
  fi
  vim $(find . ! -type d ! -wholename '*/.svn*' ! -iregex '.*\.\(jar\|pdf\|swp\|png\|class\|jpg\|gif\)' -name "$patt")
}
export -f vimf

function pg_version() {
  # Note: just gets the major.minor version number
  sudo -u postgres psql -tAc "select version()" 2>/dev/null | perl -pe 's{^\w+\s(\d+\.\d+).*}{$1}'
}
export -f pg_version

function pg_activity() {
  local version=$(pg_version)
  local query="SELECT datname,usename,pid,client_addr,waiting,query_start,query FROM pg_stat_activity order by datname,usename,query_start"
  perl -e "exit ( $version <= 9.2 ? 0 : 1 )" && \
    query="SELECT datname,usename,procpid,client_addr,waiting,query_start,current_query FROM pg_stat_activity order by datname,usename,query_start"
  sudo -u postgres psql -c "$query"
}
export -f pg_activity

function pg_cancel_backend() {
  local procpid="$1"
  if [ -z "$procpid" ]; then
    echo "Usage: pg_cancel_backend procpid"
    return 1
  fi
  printf "select pg_cancel_backend($procpid);" | sudo -u postgres psql
}
export -f pg_cancel_backend

function pg_terminate_backend() {
  local procpid="$1"
  if [ -z "$procpid" ]; then
    echo "Usage: pg_terminate_backend procpid"
    return 1
  fi
  printf "select pg_terminate_backend($procpid);" | sudo -u postgres psql
}
export -f pg_terminate_backend

function get_time_with_millis() {
  local time=$(perl -MTime::HiRes -e "printf(qq(%.3f\n),Time::HiRes::time())")
  echo -n $time
}
export -f get_time_with_millis

function signal_load_mybashprefs() {
  # Mac does not support %N in date command, so use perl
  local time=$(get_time_with_millis)
  printf "$LOAD_MYBASHPREFS_MARKER:$(hostname):$time:$SSH_EXPECT" > $(tty)
}
export -f signal_load_mybashprefs

function jargrep() {
  for f in $(find . -name '*.jar'); do
    local output=$(jar tvf $f | grep "$@")
    if [ "$output" ]; then
      echo "$f: $output"
    fi
  done
}
export -f jargrep

function rgrep() {
  find . -type f ! -wholename './build/*' ! -wholename '*/.svn*' ! -wholename '*.class' ! -wholename '*.jar' ! -wholename '*.swp' | xargs grep "$@" 2>/dev/null
}
export -f rgrep

function tomcatlog() {
  local OPTS=$(getopt -o 23ecx -- "$@")
  eval set -- "$OPTS"
  local flag=$1
  local logfile=/var/log/tomcat7/catalina.out
  local tomcat_user=tomcat7
  local op
  while true ; do
    case "$1" in
      -2) logfile=/var/log/lincdoc/catalina.out
        tomcat_user=tomcat
        shift
        ;;
      -3) logfile=/var/log/lincdoc/catalina.log
        tomcat_user=tomcat
        shift
        ;;
      -e) op=edit; shift;;
      -c) op=clear; shift;;
      -x) op=exceptions; shift;;
      --) shift ; break ;;
    esac
  done
  if [ "$op" = "edit" ]; then
    # old sudo construct
    #sudo -E -H -u $tomcat_user -- /bin/bash -c 'false
#eval "$(base64 --decode << EOF
#'"$(declare -f vim |base64)"'
#EOF
#)"

    # unset DISPLAY to avoid "No protocol specified" warning from vim
    sudo -E -H -u $tomcat_user -- /bin/bash -c "source $MYBASHPREFS_FILE && unset DISPLAY && vim -n -i NONE $logfile"
  elif [ "$op" = "clear" ]; then
    sudo truncate --no-create --size 0 $logfile
    echo "$logfile was truncated."
  elif [ "$op" = "exceptions" ]; then
    sudo -u $tomcat_user grep Exception $logfile | less
  else
    sudo -E -H -u $tomcat_user multitail -f -c $logfile
  fi
}
export -f tomcatlog

function screen() {
  local shell=/tmp/.bash.screen.$USER
  #printf 'exec /bin/bash --norc --noprofile "$@"\n' > $shell
  # why exec bash via perl here? because Mac OSX bash will munge PS1 otherwise
  printf '#!/usr/bin/perl\n' > $shell
  printf 'exec qw(/bin/bash --norc --noprofile),@ARGV;\n' >> $shell
  chmod 755 $shell
  local SCREENRC=/tmp/.screenrc.$USER
  # Set up a little macro so that ^a% will dump the current screen to a file,
  # then edit it in vim.
  local printscreen_macro=/tmp/.screenrc.$USER.printscreen
  local hardcopy_file=/tmp/.screenrc.$USER.hardcopy
  touch $SCREENRC
  export SCREENRC
  cat > $SCREENRC << 'EOF'
startup_message off
escape ^ee
bind " " windowlist -b
vbell on
vbell_msg DING
#shelltitle "$ |bash:"
bindkey "\032" stuff "\032"
#caption always "%{= kw}%-w%{= BW}%n %t%{-}%+w %-= @%H - %LD %d %LM - %c:%s"
caption always "%{= kw}%-w%{= BW}%n%t%{-}%+w %-= @%H %m/%d %c"
shelltitle "$ |:"
# use printf instead of echo: works on macs
setenv PROMPT_COMMAND 'printf "\033k${HOSTNAME}\033\134"'
#shell $shell
#screen rm $SCREENRC
EOF
  cat >> $SCREENRC << EOF
bind % source $printscreen_macro
EOF
  cat > $printscreen_macro << EOF
hardcopy_append off
hardcopy $hardcopy_file
screen vim $hardcopy_file
EOF

  /usr/bin/screen -s $shell "$@"
}
export -f screen

function s() {
  local user=$1
  if [ "$user" = "" ]; then
    user=root
  fi
  id -u "$user" >/dev/null 2>&1 || { echo "No such user \"$user\"."; return; }
  signal_load_mybashprefs
  sudo -H -u $user -- /bin/bash
}
export -f s

function get_ldsupport_pw() {
  local app_context=$1
  if [ -d /etc/lincware/lwsa ]; then
    # 3.1 or higher
    local ld_url="http://remoteadmin.lincware.com:$(sudo cat /var/run/lwsa-remoteadmin.http_port)/lincdoc/login/_/system"
    #local url=https://svn.lincware.com/lw/ldsupportpw
    local cmd="$(sudo lwsa --get_psql_connect $app_context --silent) -tAc \"select config from ld_admin.ld_config_map where key = 'ldsupport-crypt-pw'\""
    #if [ "$db" ]; then
      #cmd="sudo -u postgres psql $db -tAc \"select config from ld_admin.ld_config_map where key = 'ldsupport-crypt-pw'\""
    #fi
    if [[ "$cmd" != *psql* ]]; then
      if [ -n "$app_context" ]; then
        echo "ERROR: no such app context: $app_context"
        echo "Available contexts:"
        sudo lwsa --list_app_context_ids
      else
        echo "ERROR: could not read lwsa configuration to get psql connect string."
      fi
      return
    fi
    echo $ld_url
    local enc_pass="$(eval $cmd)"
    # echo a string for expect to pick up and launch a browser session
    printf "~%s|%s|%s|%s|\n" LAUNCH_LDSUPPORT_LOGIN "$ld_url" "$enc_pass" $(get_time_with_millis)
    echo
  else
    local version=$(show-version)
    if [[ "$version" = 3* ]]; then
      local pid=$(pgrep -U remoteadmin ssh)
      if [ -n "$pid" ]; then
        ps --no-headers ww $pid | perl -pe 's{.*?\b(\d+):localhost:80\b.*}{http://remoteadmin.lincware.com:$1}'
      fi
      generate-build-properties -get lincdoc.user.ldsupport.password
    else
      # version 2.x
      local pid=$(pgrep -U sshtunnel ssh)
      if [ -n "$pid" ]; then
        ps --no-headers -ww -o user:12,pid,args $pid | perl -pe 's{.*?\b(\d+):localhost:80\b.*}{http://remoteadmin.lincware.com:$1}'
      fi
      echo "lincdoc/$(generate-build-properties -get lincdoc.ldap.password)"
    fi
  fi
}
export -f get_ldsupport_pw

function ldu() {
  perl -e'%h=map{/.\s/;99**(ord$&&7)-$`,$_}`sudo du -h`;print@h{sort%h}'
}
export -f ldu

function update_gpg_key() {
  local apt_keyring=/etc/apt/trusted.gpg
  # the old key expired 04/28/2014
  local old_key="Lincware Repository"
  local apt_lincware_key_file=/etc/apt/trusted.gpg.d/apt.lincware.com.gpg
  # To do: set http_proxy environment var if customer uses a proxy
  local new_key_url=http://apt.lincware.com/apt.lincware.com.gpg
  echo "Attempting to fetch $new_key_url now"
  local new_key_base64="$(curl --silent $new_key_url)"
  sudo -H bash -s << EOSUDO
    gpg --no-default-keyring --with-colons --list-keys --keyring $apt_keyring "$old_key" >/dev/null 2>&1 && {
      # delete old gpg key that expired on 04/28/2014
      gpg --no-default-keyring --keyring $apt_keyring --yes --batch --delete-key "$old_key"
    }
    echo "$new_key_base64" | gpg --no-default-keyring --keyring $apt_lincware_key_file --import
EOSUDO
}
export -f update_gpg_key

OLD_LD_BIN=/opt/lincdoc/trunk/product/bin
if [ -d $OLD_LD_BIN ]; then
  pathadd $OLD_LD_BIN
fi
unset OLD_LD_BIN

function ssh() {
  signal_load_mybashprefs
  /usr/bin/ssh "$@"
  return $?
}
export -f ssh

}
  #exp_internal -f /tmp/log 0

  # compress all the bash commands, base64 encode, pass over the wire, base64
  # decode, and uncompress and eval on the remote end ...  but watch out if
  # this base64 string exceeds 4096 bytes (1024 for mac) which seems to be the
  # terminal driver limit (http://expect.sourceforge.net/FAQ.html#q76)
  # "terminal input queue" "typeahead buffer"
  # MAX_INPUT
  # "getconf -a|grep MAX_INPUT" may help determine this value
  #
  # using openssl's base64 for mac/linux compatibility; use grep to filter out
  # comment lines
  #set c [exec "bash" "-c" "echo \"\$0\" | grep -v -E '^\\s*#' | gzip -9 --stdout | openssl base64" $mybashprefs]
  set c [exec "bash" "-c" "echo \"\$0\" | gzip -9 --stdout | openssl enc -base64" $mybashprefs]
  # append \n to $mybashprefs make the md5 comparison work
  set mybashprefs_hash [string tolower [md5::md5 -hex $mybashprefs\n]]
  set c_len [string length $c]
  #send_user "mybashprefs_hash=$mybashprefs_hash,len=[string length $mybashprefs]"
  #send "eval \"\$(base64 --decode << EOF | gzip -d\r$c\rEOF\r)\"\r"
  #expect -re "$PROMPT"

  # Set HISTIGNORE to not save commands that begin with a space in bash
  # history, including hiding this next command.
  send "TMP=\$(history|tail -1|awk '{print \$1}') && history -d \$TMP && HISTCONTROL=ignoreboth && export HISTIGNORE=' *' && unset TMP && export SSH_EXPECT=$SSH_EXPECT\r"
  expect -re $PROMPT
  #exp_internal -f /tmp/log 1
  send " if test -f $mybashprefs_file; then openssl md5 $mybashprefs_file; else echo \"expect-ssh: no file $mybashprefs_file\"; fi\r"
  array unset expect_out
  expect -re "\\r\\n(?:.*?=\\s*)?(\\w.*?)\\r\\n.*(?:$PROMPT)"
  set check_hash [string tolower $expect_out(1,string)]
  #send_user "check_hash=$check_hash"
  #exp_internal 0
  if { $mybashprefs_hash eq $check_hash } {
    send_user "MD5 hash for $mybashprefs_file is verified: $check_hash\n"
    #send_user "loading $mybashprefs_file ... "
  } else {
    send_user "uploading $mybashprefs_file ...\n"
    # Note the leading space so it is not saved in bash history
    send " \[ ! -e $mybashprefs_file ] && { touch $mybashprefs_file; chmod 666 $mybashprefs_file; }\r"
    expect -re $PROMPT
    send " eval \"\$(openssl enc -base64 -d << ' EOF' | gzip -d | tee $mybashprefs_file >/dev/null\r"
    set lt_prompt "> (?:$ANSI_RE_TEXT_FORMATTING)*$"
    expect -re $lt_prompt

    # split into manageable chunks that will not exceed terminal driver
    # buf size
    set n 0
    foreach bashline [regexp -all -inline {(?:.{0,254}\n){1,1}} "$c\n"] {
      send "$bashline"
      #send_user "ans=[string length $bashline]\n"
      expect -re $lt_prompt
      incr n [string length $bashline]
      set precision [string length $c_len]
      send_user [format "%*d/%*d uploaded\r" $precision $n $precision $c_len]
    }
    send_user "\nDONE with upload\n"

    # Note the leading space so it is not saved in bash history
    send " EOF\r)\"\r"
    expect -re "$PROMPT"
  }
  set script [info script]
  # Be paranoid: do another md5 check before sourcing the commands.
  set warning "WARNING: load_mybashprefs md5 hash check failed."
  log_user 0
  send " rhash=\"\$(openssl md5 $mybashprefs_file)\" && rhash=\${rhash##* }\r"
  expect -re $PROMPT
  send " \[ \"\$rhash\" = \"$mybashprefs_hash\" ] && source $mybashprefs_file || printf '$warning rhash=%s\\n' \$rhash\r"
  set found_warning ""
  array unset expect_out
  expect {
    -re "\\r\\n($warning) rhash=(\\w+)\\r\\n.*$PROMPT" {
      set found_warning $expect_out(1,string)
      set rhash $expect_out(2,string)
    }
    -re $PROMPT
  }
  if { [string length $found_warning ] > 0 } {
    send_error $found_warning\n
    send_error "Expected hash $mybashprefs_hash does not match computed hash of $rhash.\n"
  } else {
    log_user 1
    #send " clear && echo 'bash prefs loaded'\r"
    #expect -re $PROMPT
  }
  send_user "Press ENTER to continue\n"
  gets stdin c
  send clear\r
  #send_user "done ($c_len bytes/$count lines).\n"
}
### END of load_mybashprefs

set is_marker_prompt 0
proc check_prompt_marker {arr} {
  global is_marker_prompt PS1_MARKER
  upvar $arr arr_ref
  set marker {*}$PS1_MARKER
  if { [info exists arr_ref(2,string)]==1 && [string trim $arr_ref(2,string)]==$marker } {
    set is_marker_prompt 1
  } else {
    set is_marker_prompt 0
  }
  return $is_marker_prompt
}

array set loaded {}
array set load_mybashprefs_flag {}
proc main_prompt_checker {arr} {
  global stdin_buf IS_INITIALIZED interact_out expect_out loaded load_mybashprefs_flag
  #upvar $arr arr_ref
  set stdin_buf ""
  if { $IS_INITIALIZED == 0 } {
    init_shell
  }
  if { [array size load_mybashprefs_flag] > 0 } {
    if { [check_prompt_marker $arr] == 0 } {
      load_mybashprefs [expr $load_mybashprefs_flag(SSH_EXPECT_CURR) + 1]
      set loaded($load_mybashprefs_flag(remote_hostname)) $load_mybashprefs_flag(time_of_day)
    }
  }
  array set load_mybashprefs_flag {}
}

#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set local_shell_only 0
set stdin_buf ""
set argv2 {}
foreach arg $argv {
  if { $arg == "-help" } {
    puts "This is ssh-expect, an ssh wrapper to make things"
    puts "easier when ssh-ing to multiple hosts, and sudo-ing"
    puts "to multiple users. Options:"
    puts "  -help   this help menu"
    puts "  -shell  don't ssh but instead run a local bash shell"
    puts "All other arguments are passed directly to ssh."
    puts "While inside any session, type these at a prompt:"
    puts "  ~d      toggle debug mode (writes to $LOGFILE)"
    puts "  ~i      load bash functions/preferences"
    puts "  ~k      kill expect: useful if running screen, and you"
    puts "          want to resume screen from another desktop"
    puts "Upon starting, Expect statements can be placed in"
    puts "~/.expect-ssh/config and they get sourced."
    exit
  }
  if { $arg == "-local_shell_only" || $arg == "-shell" } {
    set local_shell_only 1
  } elseif { $arg == "-debug" } {
    # truncate the file first
    close [open $LOGFILE "w"]
    exp_internal -f $LOGFILE 0
    send_user "DEBUG MODE: sending output for this session to $LOGFILE\n"
  } else {
    lappend argv2 "$arg"
  }
}
if { $local_shell_only == 1 } {
  eval [list spawn -noecho] /bin/bash
} else {
  eval [list spawn -noecho] /usr/bin/ssh $argv2
}
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)


trap {
  resize_handler
} WINCH
# force-resize: needed if on Mac in terminal full screen mode
resize_handler

proc init_shell {} {
  global IS_INITIALIZED PROMPT HAS_BASH stdin_buf env
  if { $IS_INITIALIZED > 0 } { return }
  # Initialize the session
  set IS_INITIALIZED 1
  log_user 0
  # test for bash shell
  send "echo =\$BASH=\r"
  expect -re "\\r\\n=(\[/\\w]*)=.*?$PROMPT"
  if { [string length $expect_out(1,string)] > 0 } {
    set HAS_BASH 1
    # Set HISTIGNORE to not save commands that begin with a space in bash
    # history, including hiding this next command, and the previous echo
    # command that was used to test for $BASH.
    send "TMP=\$(history|tail -1|awk '{print \$1}') && history -d \$TMP && history -d \$((\$TMP-1)) && HISTCONTROL=ignoreboth && HISTIGNORE=' *' && unset TMP\r"
    expect -re $PROMPT
  }

  log_user 1
  load_mybashprefs $env(SSH_EXPECT)
}

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env LOGFILE PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(SSH_EXPECT)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      # truncate the file first
      close [open $LOGFILE "w"]
      exp_internal -f $LOGFILE 0
      send_user "DEBUG MODE: sending output for this session to $LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

array set ldsupport_req_processed {}
proc process_ldsupport_request {ld_url enc_pass time_of_day} {
  global LD_SUPPORT_BASIC_AUTH PROMPT OS ldsupport_req_processed
  if { [info exists ldsupport_req_processed($time_of_day)]==1 } {
    return
  }
  set ldsupport_req_processed($time_of_day) 1
  set url https://svn.lincware.com/lw/ldsupportpw
  catch {
    set ld_support_pw [exec curl -s -H "Authorization: Basic $LD_SUPPORT_BASIC_AUTH" --data "$enc_pass" $url]
  } ld_support_pw
  expect -re $PROMPT
  if { [regexp {^[-\w]+$} $ld_support_pw] } {
    send " echo password is: $ld_support_pw\r"
    expect -re $PROMPT
    if { "$OS" == "Linux" } {
      exec sh -c "printf '%s' \"\$0\" | clipit 2>&1" $ld_support_pw
      system xdg-open $ld_url >/dev/null &
    } elseif { "$OS" == "Darwin" } {
      exec sh -c "printf '%s' \"\$0\" | pbcopy 2>&1" $ld_support_pw
      system open $ld_url &
    }
  } else {
    send_error "ERROR: could not read ldsupport password: further info: $ld_support_pw"
  }
}

if { $env(SSH_EXPECT) > 0 } {
  # the caller of this script is already a session of this script ... just
  # initialize the shell and interact so that copy/paste commands always get
  # intercepted by parent script
  interact {
    # "All the patterns before the -o apply to the user keystrokes. All the
    # patterns after the -o apply to the spawned process."
    -o
    -nobuffer -re "${PROMPT}" { main_prompt_checker interact_out }
  }
} else {
  interact {
    -re "." { process_keystroke $interact_out(0,string) }
    # "All the patterns before the -o apply to the user keystrokes. All the
    # patterns after the -o apply to the spawned process."
    -o
    -nobuffer -re $PROMPT { main_prompt_checker interact_out }
    #
    -nobuffer -re $COPY_TO_CLIPBOARD_BEGIN_RE {
      copy_to_clipboard $interact_out(1,string)
    }
    -nobuffer -re $DOWNLOAD_FILE_BEGIN_RE {
      download $interact_out(1,string) $interact_out(2,string)
    }
    #-re {(?:^|[\r\n](?:$ANSI_RE_GENERAL)*)~copy_to_clipboard_in_vim[^\w].*} {
      #send ":!copy_to_clipboard \$VIM_CLIPBOARD\r"
      #expect -re $COPY_TO_CLIPBOARD_BEGIN_RE
      #set n [copy_to_clipboard]
      #expect {
        #-re {Press ENTER or type command to continue.*$} {
          #send "\r"
          #expect -re "$ANSI_RE_SHOW_CURSOR$"
          #send ":echon \"$n characters were copied to clipboard\"\r"
          #expect -re "$ANSI_RE_SHOW_CURSOR$"
        #}
        #-re {has changed since editing started.*\(L\)oad File: $} {}
      #}
    #}
    -nobuffer -re [join { ~ paste_from_clipboard_in_vim} ""] {
      paste_from_clipboard_in_vim
    }
    -nobuffer -re [join { ~ {LAUNCH_LDSUPPORT_LOGIN\|([^\|]+)\|([^\|]+)\|([^\|]+)\|} } ""] {
      set ld_url $interact_out(1,string)
      set enc_pass $interact_out(2,string)
      set time_of_day $interact_out(3,string)
      process_ldsupport_request $ld_url $enc_pass $time_of_day
    }
    -nobuffer -re $LOAD_MYBASHPREFS_MARKER_RE {
      #
      # We have a request to load bash prefs into the current shell, but we
      # only do that under certain conditions below. For example, "ssh
      # localhost uname" should NOT trigger loading bash prefs, but "ssh
      # localhost" should.
      #
      set remote_hostname $interact_out(1,string)
      set time_of_day $interact_out(2,string)
      set SSH_EXPECT_CURR $interact_out(3,string)
      if { [info exists loaded($remote_hostname)] == 0 || $time_of_day > $loaded($remote_hostname) } {
        array unset expect_out
        set load_mybashprefs_flag(remote_hostname) $remote_hostname
        set load_mybashprefs_flag(time_of_day) $time_of_day
        set load_mybashprefs_flag(SSH_EXPECT_CURR) $SSH_EXPECT_CURR
      }
    }
    -nobuffer -re {\npsql .*Type "help" for help(.*)[#>] $} {
      if { [string first "\\set PROMPT1" $interact_out(1,string) ] < 0 } {
        send "\\set PROMPT1 '%n@%m:%/> '\r"
        expect -re "> $"
        send "\\set PROMPT2 '> '\r"
      }
    }
  }
}
EXPECT_EOF
