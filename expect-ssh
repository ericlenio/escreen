#!/bin/bash
# vim:filetype=expect
# Drop in replacement script for ssh, with helpful integrations to use bash,
# sudo, screen, and vim more effectively. Run with -help to see arguments.

if [ ! -t 0 -o -n "$EXPECT_SSH" ]; then
  exec /usr/bin/ssh "$@"
fi

export EXPECTSSH_TMPDIR=/tmp/.expect-ssh
export EXP_FILE=$EXPECTSSH_TMPDIR/ssh.expect.$USER

[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }

cat > $EXP_FILE << 'EXPECT_EOF' && exec /usr/bin/expect -c "set EXEC $(basename $0)" -f $EXP_FILE -- "$@"
# apt-get install tcllib
package require md5

file delete $env(EXP_FILE)

set spawn_out_slave_name 0
# for prompt, "\u001b[0m" is a possible "end of color" sequence
set ANSI_RE_TEXT_FORMATTING {\u001b\[(?:\d+;?)*[m]}
set ANSI_RE_CURSOR_POSITIONING {\u001b\\\[\d+;\d+[Hf]}
set ANSI_RE_GENERAL {\u001b\[[^a-zA-Z]*[a-zA-Z]}
set ANSI_RE_SHOW_CURSOR {\u001b\[\?25h}

# Certain bash functions will send patterns (markers) which expect picks up on
# to do further processing. The patterns are of the form of GENERIC_MARKER.  It
# is required that after the pattern is sent there will be a \n and then
# gzipped and base64 encoded data (optional), then a period (not optional).
set GENERIC_MARKER "~@(\[0-9]\[0-9]):"
array set MARKER {
  LOAD_MYBASHPREFS 01
  COPY_TO_CLIPBOARD 02
  DOWNLOAD_DEFAULT_FILE 03
  DOWNLOAD_DATA 04
  LDSUPPORT_PW 05
  VIM_PASTE_CLIPBOARD 06
}

proc get_marker {marker_type} {
  global GENERIC_MARKER MARKER
  return [regsub $GENERIC_MARKER ~@00: "~@$MARKER($marker_type):"]
}

set LOAD_MYBASHPREFS_MARKER [get_marker LOAD_MYBASHPREFS]
set COPY_TO_CLIPBOARD_MARKER [get_marker COPY_TO_CLIPBOARD]
set DOWNLOAD_DEFAULT_FILE_MARKER [get_marker DOWNLOAD_DEFAULT_FILE]
set DOWNLOAD_DATA_MARKER [get_marker DOWNLOAD_DATA]
set LDSUPPORT_PW_MARKER [get_marker LDSUPPORT_PW]
set VIM_PASTE_CLIPBOARD_MARKER [get_marker VIM_PASTE_CLIPBOARD]

set EXPECTSSH_TMPDIR $env(EXPECTSSH_TMPDIR)
# PS1_MARKER is a non-regexp marker in the normal PS1 prompt that we search for
# in certain situations to see if we need to load bash prefs. Watch that it
# works in regular bash, as well as inside a screen session because screen
# will translate many ANSI escape codes.
#
# TO DO: figure out why screen always translates "\033[9Xm" to
# "\033[3Xm\033[9Xm" for X=0..9. It won't hurt us here because the 
# marker is still in the PS1 string.
#set PS1_MARKER {:\033[7m$\033[0m }
set PS1_MARKER {:\033[7m\$\033[0m }
#set PROMPT "($ANSI_RE_TEXT_FORMATTING)*(?::(?:$ANSI_RE_TEXT_FORMATTING))*(#|\\\$)($ANSI_RE_TEXT_FORMATTING)* $"
set PROMPT "(?:"
append PROMPT "((?!:)(?:#|\\\$)(?:$ANSI_RE_TEXT_FORMATTING)* (?:$ANSI_RE_GENERAL)*$)"
append PROMPT "|"
#append PROMPT "([regsub -all {([\$\[])} $PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT "([regsub -all {([\[])} $PS1_MARKER [join { {\\} {\1} } {}]])(?:$ANSI_RE_GENERAL)*$"
append PROMPT ")"
set OS [exec uname -s]
set LD_SUPPORT_BASIC_AUTH secret

set rcfile "$env(HOME)/.expect-ssh/config"
if {[file exists $rcfile]} {
  source $rcfile
}

if {[info exists env(EXPECT_SSH)] == 1} {
  set env(EXPECT_SSH) [expr $env(EXPECT_SSH) + 1]
} else {
  set env(EXPECT_SSH) 0
}

set CTRL_Z \032
set LOGFILE "/tmp/ssh.log"
match_max 10000

proc resize_handler {} {
  global spawn_out_slave_name
  # Detect if window size has changed, and resize accordingly.
  set rows [stty rows]
  set cols [stty columns]
  stty rows $rows columns $cols < $spawn_out_slave_name
}

proc copy_to_clipboard {clipboard_data} {
  global PROMPT OS ANSI_RE_GENERAL
  set max_clipboard_data_len 1000000
  log_user 1
  if { $OS == "Darwin" } {
    exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c | pbcopy" $clipboard_data
    set l [exec pbpaste | wc --bytes]
  } elseif { $OS == "Linux" } {
    exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c | clipit" $clipboard_data
    set l [exec clipit -c | wc --bytes]
  } else {
    send_error "copy_to_clipboard: need handling for $OS"
    return
  }
  send_user "DONE...$l bytes copied to the clipboard"
  return $l
}

proc get_download_filename {default_file_name} {
  global PROMPT OS
  set default_outfile "/tmp/$default_file_name"
  spawn -noecho /bin/bash
  set outfile ""
  expect -re $PROMPT
  if { "$OS" == "Linux" } {
    send " read -e -i '$default_outfile' -p 'Save downloaded file to: ' ans && echo ans=\$ans\r"
  } elseif { "$OS" == "Darwin" } {
    send " read -e -p 'Save downloaded file to: ' ans && echo ans=\$ans\r"
    expect -ex :
    send $default_outfile
  } else {
    send_error "get_download_filename: need support for OS=$OS"
  }
  interact {
    -o
    -re "\\nans=(\[^\\r\\n]*).*$PROMPT" {
      set outfile $interact_out(1,string)
      close
      return $outfile
    }
  }
}

proc upload_file {} {
  global PROMPT OS spawn_id
  set bashscript {function get_upload_file() {
    local f
    local yn
    read -e -p 'Choose a file to be uploaded: ' f
    # canonicalize f: must do tilde expansion
    f=${f/#~/$HOME}
    if [ ! -e "$f" ]; then
      echo "No such file \"$f\", stop."
      return 1
    fi
    read -p "Confirm: upload \"$f\" (y/n, default y): " yn
    [ -z "$yn" ] && yn=y
    [ "$yn" != y ] && return
    echo "File to be uploaded: $f"
    local outfile=/tmp/$(basename "$f")
    echo "Will be uploaded to: $outfile"
    }
    # execute the function
    get_upload_file
  }
  set main_spawn_id $spawn_id
  spawn -noecho /bin/bash --norc --noprofile -c "eval \"\$0\"" $bashscript
  set upload_file ""
  interact {
    -o -nobuffer -re "File to be uploaded: (.*)\r\nWill be uploaded to: (.*)\r" {
      set upload_file $interact_out(1,string)
      set outfile $interact_out(2,string)
    }
  }
  set spawn_id $main_spawn_id
  if { [file exists $upload_file] == 0 } {
    return
  }
  # Delimit the input with a space, and after each line is sent send \r so
  # the terminal does not scroll
  send " \[ -e \"$outfile\" -a ! -w \"$outfile\" ] && echo '$outfile is not writable, aborting upload.'\r"
  expect {
    -re "\n.*aborting" {
      return
    }
    -re $PROMPT
  }
  send { tty=$(tty); while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l; printf "\015" >$tty; done}
  send "| openssl enc -d -base64 | gzip -d -c > \"$outfile\"; unset tty\r"
  # split into manageable chunks that will not exceed terminal driver
  # buf size
  set n -1 
  log_user 1
  set upload_file_enc [exec "bash" "-c" "gzip -9 -c \"$upload_file\" | openssl enc -base64"]
  set c_len [string length $upload_file_enc]
  foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$upload_file_enc\n"] {
    send "[string trimright $line] "
    expect -re "\x0d$"
    if { $n > -1 } { send_user \r }
    incr n [string length $line]
    set precision [string length $c_len]
    send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
  }
  send_user " ... DONE with upload to $outfile\r\n"
  send ". "
  expect ". "
  log_user 1
  expect -re $PROMPT
}

proc download {outfile encoded_data} {
  catch {
    set chan [open "|/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\"" w]
    fconfigure $chan -translation binary -encoding binary
    puts $chan $encoded_data
    flush $chan
    close $chan
    set l [file size $outfile]
    send_user "DONE...downloaded to $outfile, $l bytes"
    return $l
  } err
  send_error "ERROR in proc download: $err"
}

proc paste_from_clipboard_in_vim {} {
  global OS PROMPT ANSI_RE_SHOW_CURSOR
  send ":shell\r"
  expect -re $PROMPT
  # encode the clipboard data and send it across the wire, decoding it on the
  # other end, and store it in the VIM_CLIPBOARD file.
  # Leading space before cat so as to not save it to history
  send " tty=\$(tty)\r"
  expect -re $PROMPT
  send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l; printf "\015" >$tty; done}
  send " | /usr/bin/openssl enc -base64 -d | gzip -d -c > \$VIM_CLIPBOARD\r"
  expect -re \r\n$
  if { "$OS" == "Linux" } {
    set buf [exec clipit -c | gzip -9 -c | /usr/bin/openssl enc -base64]
  } elseif { "$OS" == "Darwin" } {
    set buf [exec pbpaste | gzip -9 -c | /usr/bin/openssl enc -base64]
  }
  foreach line [split $buf] {
    send "[string trimright $line] "
    expect -re "\x0d$"
  }
  send ". "
  expect ". "
  expect -re $PROMPT
  send " exit\r"
  expect {
    -re $ANSI_RE_SHOW_CURSOR {
      # read the file and put it in the unnamed register
      send {:let @"=join(readfile($VIM_CLIPBOARD,"b"),"\n")}
      send "\r"
      expect {
        -re $ANSI_RE_SHOW_CURSOR {
          # paste contents of unnamed register
          send ":if col(\"\$\")-col(\".\")==1 | call feedkeys(\"p\") | else | call feedkeys(\"P\") | endif\r"
        }
        -re {has changed since editing started.*\(L\)oad File: $} {}
        timeout {send_error "TIMEOUT #1 during paste, aborting"; return}
      }
    }
    -re {has changed since editing started.*\(L\)oad File: $} {}
    timeout {send_error "TIMEOUT #2 during paste, aborting"; return}
  }
}

proc load_mybashprefs {EXPECT_SSH {nest_level 0}} {
  global PROMPT ANSI_RE_TEXT_FORMATTING PS1_MARKER ANSI_RE_GENERAL EXPECTSSH_TMPDIR MYBASHPREFS_PASSWORD
  global LOAD_MYBASHPREFS_MARKER COPY_TO_CLIPBOARD_MARKER DOWNLOAD_DEFAULT_FILE_MARKER DOWNLOAD_DATA_MARKER
  global LDSUPPORT_PW_MARKER VIM_PASTE_CLIPBOARD_MARKER
  log_user 1
  # verify we are in bash
  #send " echo 'test for bash'\r"
  #expect {
    #-re "\ntest for bash\r.*$PROMPT" {}
    #timeout {
      #send_error "timeout in load_mybashprefs while testing for bash\n"
      #return
    #}
  #}
  set mybashprefs_file $EXPECTSSH_TMPDIR/.mybashprefs
  set mybashprefs "export EXPECTSSH_TMPDIR=$EXPECTSSH_TMPDIR\n"
  append mybashprefs "export HISTCONTROL=ignoreboth:erasedups\n"
  # see if previous command in history was the line to decode bashprefs, and if so delete it from history
  append mybashprefs {history -p '!!'|grep -q ^' c=' && TMP=$(history|tail -1|awk '{print $1}') && history -d $TMP && unset TMP}
  append mybashprefs \n
  append mybashprefs "export MYBASHPREFS_FILE=$mybashprefs_file\n"
  append mybashprefs {export PS1='${debian_chroot:+($debian_chroot)}\u@\H:\[\033[1;32m\]\w}
  # NOTE: all non-printing characters in the prompt must be surrounded with \[ \]
  # otherwise the line spacing gets all weird when typing out long bash commands
  append mybashprefs [regsub -all {\\033\[[^a-zA-Z]*[a-zA-Z]} $PS1_MARKER [join { {\[} {\0} {\]} } {}]]
  append mybashprefs "'\n"
  # signal_load_mybashprefs:
  # Do an expression that is easily evaluated to a TCL array for args;
  append mybashprefs "function signal_load_mybashprefs() { local marker=$LOAD_MYBASHPREFS_MARKER\n"
  # EXPECTSSH_IN_SCREEN is a flag to know if current shell is (ultimately)
  # inside a screen session, and if so when ssh-ing to a new host we can update
  # the screen window title with the new hostname.
  append mybashprefs "local in_screen=0\n"
  append mybashprefs {if [ -n "$STY" -o -n "$EXPECTSSH_IN_SCREEN" ]; then in_screen=1; fi}
  append mybashprefs "\n"
  append mybashprefs {local CMD_ARRAY=("$@")}
  append mybashprefs "\n"
  append mybashprefs {local args=$(printf "EXPECT_SSH %s EXPECTSSH_IN_SCREEN {%s} CMD_ARRAY {%s}" $EXPECT_SSH "$in_screen" "$(declare -p CMD_ARRAY)" | gzip -9 -c | openssl enc -base64)}
  append mybashprefs "\n"
  # pass a \010 (backspace) character to erase last character of the pattern so
  # that expect-ssh only processes this signal 1 time ... else when inside
  # screen it would potentially get re-executed from a resumed session.
  append mybashprefs {printf "%s\010.\n%s.\n" "$marker" "$args"}
  append mybashprefs "\n}\n"
  append mybashprefs "export -f signal_load_mybashprefs\n"

  append mybashprefs "function copy_to_clipboard() { local marker=$COPY_TO_CLIPBOARD_MARKER\n"
  # copy_to_clipboard: use perl to remove the last \n on the last line, and
  # minimally set a hyphen character in the stream so as to not pass 0 bytes to
  # clipit (which causes it to block)
  append mybashprefs {local file_to_copy="$1"
    printf "%s\010.\n" "$marker"
    if [ -z "$file_to_copy" ]; then
      file_to_copy="-"
    elif [ ! -e "$file_to_copy" ]; then
      echo "Error: no such file: $file_to_copy"
      file_to_copy=/dev/null
    fi
    for l in $(perl -pe 'BEGIN{$n=0;}END{print "-" if $n==0}$n+=length($_);chomp if eof' -- "$file_to_copy" | gzip -9 -c | openssl enc -base64); do
      printf "%s" $l
      printf "\015"
    done
    printf ".\n"
  }
  append mybashprefs "}\n"
  append mybashprefs "export -f copy_to_clipboard\n"

  append mybashprefs {
    function receive_uploaded_file() {
      local outfile="$1"
      local tty=$(tty)
      while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l; printf "\015" >$tty; done \
      | openssl enc -d -base64 | gzip -d -c > "$outfile"
    }
    export -f receive_uploaded_file
  }

  append mybashprefs "function download() { local marker1=$DOWNLOAD_DEFAULT_FILE_MARKER\n"
  append mybashprefs "local marker2=$DOWNLOAD_DATA_MARKER\n"
  append mybashprefs {local file="$1"
    if [ ! -e "$file" ]; then
      echo "Error: no such file: $file"
      return
    fi
    local locfile=$(basename "$file")
    local args=$(printf "default_file_name {%s}" "$locfile" | gzip -9 -c | openssl enc -base64)
    printf "%s\010.\n%s.\n" "$marker1" "$args"
    local ans
    # Only continue if a valid download filename was picked in get_download_filename
    read -p "Continue? " ans
    if [ "$ans" != y ]; then
      return
    fi
    printf "%s\010.\n" "$marker2"
    for l in $(gzip -9 -c "$file" | openssl enc -base64); do
      printf "%s" $l
      printf "\015"
    done
    printf ".\n"
  }
  append mybashprefs "}\n"
  append mybashprefs "export -f download\n"

  
  append mybashprefs {unset PROMPT_COMMAND
export HISTIGNORE=' *'
export VIM_CLIPBOARD=$EXPECTSSH_TMPDIR/vim.clipboard.$USER
touch $VIM_CLIPBOARD
chmod 600 $VIM_CLIPBOARD || {
  echo "WARNING: could not chmod on $VIM_CLIPBOARD, halting."
  return
}
}
  
  append mybashprefs "export VIMINIT='map <c-v> :echon \"$VIM_PASTE_CLIPBOARD_MARKER\\n.\""
  append mybashprefs {<cr>|vnoremap <C-c> y:call writefile(split(@","\n","b"),$VIM_CLIPBOARD)<cr>:!copy_to_clipboard $VIM_CLIPBOARD<cr>|colorscheme elflord|syntax enable|set noswapfile number hlsearch incsearch sw=2 ignorecase wrap nocompatible ruler ai showmatch modeline modelines=5 nobackup nowritebackup textwidth=0 expandtab formatoptions=croql wildignore=*.class path=.,,**|autocmd Filetype java setlocal omnifunc=javacomplete#Complete'
export EDITOR=/usr/bin/vim
export FCEDIT=$EDITOR

function openssl_show_cert() {
  local cert=$1
  if [ -z "$cert" ]; then
    # assume stdin
    cert="-"
  fi
  openssl x509 -in $cert -noout -text
}
export -f openssl_show_cert

function openssl_s_client_showcerts() {
  local hostport="$1"
  local host=${hostport%%:[0-9]*}
  local port=${hostport##*:}
  if [ "$host" = "$hostport" -o "$port" = "$hostport" ]; then
    echo "Usage: ${FUNCNAME[0]} host.example.com:port"
    return
  fi
  echo | openssl s_client -showcerts -connect $host:$port
}
export -f openssl_s_client_showcerts

function pathadd() {
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="${PATH:+"$PATH:"}$1"
  fi
}

function l() {
  local os=$(uname -s)
  if [ $os = Darwin ]; then
    ls -laF "$@"
  else
    ls -laF --time-style=+'%D %H:%M:%S' "$@"
  fi
}
unalias l 2>/dev/null
export -f l

function vimf() {
  local patt="$1"
  if [ -z "$patt" ]; then
    patt="*"
  else
    patt="*$patt*"
  fi
  vim $(find . ! -type d ! -wholename '*/.svn*' ! -iregex '.*\.\(jar\|pdf\|swp\|png\|class\|jpg\|gif\)' -name "$patt")
}
export -f vimf

function pg_version() {
  # Note: just gets the major.minor version number
  sudo -u postgres psql -tAc "select version()" 2>/dev/null | perl -pe 's{^\w+\s(\d+\.\d+).*}{$1}'
}
export -f pg_version

function pg_activity() {
  local version=$(pg_version)
  local query="SELECT datname,usename,pid,client_addr,waiting,query_start,query FROM pg_stat_activity order by datname,usename,query_start"
  perl -e "exit ( $version <= 9.2 ? 0 : 1 )" && \
    query="SELECT datname,usename,procpid,client_addr,waiting,query_start,current_query FROM pg_stat_activity order by datname,usename,query_start"
  sudo -u postgres psql -c "$query"
}
export -f pg_activity

function pg_cancel_backend() {
  local procpid="$1"
  if [ -z "$procpid" ]; then
    echo "Usage: pg_cancel_backend procpid"
    return 1
  fi
  printf "select pg_cancel_backend($procpid);" | sudo -u postgres psql
}
export -f pg_cancel_backend

function pg_terminate_backend() {
  local procpid="$1"
  if [ -z "$procpid" ]; then
    echo "Usage: pg_terminate_backend procpid"
    return 1
  fi
  printf "select pg_terminate_backend($procpid);" | sudo -u postgres psql
}
export -f pg_terminate_backend

function get_time_with_millis() {
  # Mac does not support %N in date command, so use perl
  local time=$(perl -MTime::HiRes -e "printf(qq(%.3f\n),Time::HiRes::time())")
  echo -n $time
}
export -f get_time_with_millis

function jargrep() {
  for f in $(find . -name '*.jar'); do
    local output=$(jar tvf $f | grep "$@")
    if [ "$output" ]; then
      echo "$f: $output"
    fi
  done
}
export -f jargrep

function rgrep() {
  find . -type f ! -wholename './build/*' ! -wholename '*/.svn*' ! -wholename '*.class' ! -wholename '*.jar' ! -wholename '*.swp' | xargs grep "$@" 2>/dev/null
}
export -f rgrep

function tomcatlog() {
  local OPTS=$(getopt -o 23ecx -- "$@")
  eval set -- "$OPTS"
  local flag=$1
  local logfile=/var/log/tomcat7/catalina.out
  local tomcat_user=tomcat7
  local op
  while true ; do
    case "$1" in
      -2) logfile=/var/log/lincdoc/catalina.out
        tomcat_user=tomcat
        shift
        ;;
      -3) logfile=/var/log/lincdoc/catalina.log
        tomcat_user=tomcat
        shift
        ;;
      -e) op=edit; shift;;
      -c) op=clear; shift;;
      -x) op=exceptions; shift;;
      --) shift ; break ;;
    esac
  done
  if [ "$op" = "edit" ]; then
    signal_load_mybashprefs "unset DISPLAY && vim -n -i NONE $logfile; exit"
    sudo -H -u $tomcat_user /bin/bash
  elif [ "$op" = "clear" ]; then
    sudo truncate --no-create --size 0 $logfile
    echo "$logfile was truncated."
  elif [ "$op" = "exceptions" ]; then
    sudo -u $tomcat_user grep Exception $logfile
  else
    sudo -E -H -u $tomcat_user multitail -f -c $logfile
  fi
}
export -f tomcatlog

function screen() {
  # see if -r or -R was passed, if so just invoke screen with the current arg list "as is"
  local origArgs=("$@")
  local OPTS=$(getopt -q -o rR -- "$@")
  eval set -- "$OPTS"
  while true; do
    case "$1" in
      -r|-R) /usr/bin/screen "${origArgs[@]}"; return ;;
      --) shift; break ;;
      *) shift ;;
    esac
  done

  local shell=$EXPECTSSH_TMPDIR/.bash.screen.$USER
  #printf 'exec /bin/bash --norc --noprofile "$@"\n' > $shell
  # why exec bash via perl here? because bash will munge PS1 otherwise
  # on Macs
  printf '#!/usr/bin/perl\n' > $shell
  printf 'exec qw(/bin/bash --norc --noprofile),@ARGV;\n' >> $shell
  chmod 700 $shell
  local SCREENRC=$EXPECTSSH_TMPDIR/.screenrc.$USER
  # Set up a little macro so that ^a% will dump the current screen to a file,
  # then edit it in vim.
  local printscreen_macro=$EXPECTSSH_TMPDIR/.screenrc.$USER.printscreen
  local hardcopy_file=$EXPECTSSH_TMPDIR/.screenrc.$USER.hardcopy
  touch $SCREENRC $printscreen_macro $hardcopy_file
  chmod 600 $SCREENRC $printscreen_macro $hardcopy_file
  export SCREENRC
  cat > $SCREENRC << 'EOF'
startup_message off
bind " " windowlist -b
vbell on
vbell_msg DING
#shelltitle "$ |bash:"
bindkey "\032" stuff "\032"
caption always "%{= kw}%-w%{= BW}%n%t%{-}%+w %-= @%H %m/%d %c"
shelltitle "$ |:"
defmonitor on
#setenv PROMPT_COMMAND 'screen_prompt'
#shell $shell
#screen rm $SCREENRC
EOF
  cat >> $SCREENRC << EOF
bind % source $printscreen_macro
EOF
  cat > $printscreen_macro << EOF
hardcopy_append off
hardcopy $hardcopy_file
screen vim $hardcopy_file
EOF

  local esc='^Ee'
  if [ "$EXPECT_SSH" = 0 ]; then
    esc='^Aa'
  fi
  /usr/bin/screen -e$esc -s $shell "${origArgs[@]}"
}
export -f screen

function s() {
  local user=$1
  if [ "$user" = "" ]; then
    user=root
  fi
  id -u "$user" >/dev/null 2>&1 || { echo "No such user \"$user\"."; return; }
  signal_load_mybashprefs
  sudo -H -u $user -- /bin/bash
}
export -f s

function screen_prompt() {
  # use printf instead of echo: works on macs
  #printf "\033k${HOSTNAME}\033\134"
  false
}
export -f screen_prompt
}

  append mybashprefs "function get_ldsupport_pw() { local marker=$LDSUPPORT_PW_MARKER\n"
  append mybashprefs {local app_context=$1
  if [ -z "$app_context" ]; then
    app_context=lincdoc
  fi
  if [ -d /etc/lincware/lwsa ]; then
    # 3.1 or higher
    local ld_url="http://remoteadmin.lincware.com:$(sudo cat /var/run/lwsa-remoteadmin.http_port)/$app_context/login/_/system"
    #local url=https://svn.lincware.com/lw/ldsupportpw
    local cmd="$(sudo lwsa --get_psql_connect $app_context --silent) -tAc \"select config from ld_admin.ld_config_map where key = 'ldsupport-crypt-pw'\""
    #if [ "$db" ]; then
      #cmd="sudo -u postgres psql $db -tAc \"select config from ld_admin.ld_config_map where key = 'ldsupport-crypt-pw'\""
    #fi
    if [[ "$cmd" != *psql* ]]; then
      if [ -n "$app_context" ]; then
        echo "ERROR: no such app context: $app_context"
        echo "Available contexts:"
        sudo lwsa --list_app_context_ids
      else
        echo "ERROR: could not read lwsa configuration to get psql connect string."
      fi
      return
    fi
    echo $ld_url
    local enc_pass="$(eval $cmd)"
    local args="$(printf "ld_url {%s} enc_pass {%s}" "$ld_url" "$enc_pass" | gzip -9 -c | openssl enc -base64)"
    # send \010. to prevent the pattern from being detected again
    printf "%s\010.\n%s.\n" "$marker" "$args"
    echo
  else
    local version=$(show-version)
    if [[ "$version" = 3* ]]; then
      local pid=$(pgrep -U remoteadmin ssh)
      if [ -n "$pid" ]; then
        ps --no-headers ww $pid | perl -pe 's{.*?\b(\d+):localhost:80\b.*}{http://remoteadmin.lincware.com:$1}'
      fi
      generate-build-properties -get lincdoc.user.ldsupport.password
    else
      # version 2.x
      local pid=$(pgrep -U sshtunnel ssh)
      if [ -n "$pid" ]; then
        ps --no-headers -ww -o user:12,pid,args $pid | perl -pe 's{.*?\b(\d+):localhost:80\b.*}{http://remoteadmin.lincware.com:$1}'
      fi
      echo "lincdoc/$(generate-build-properties -get lincdoc.ldap.password)"
    fi
  fi
}
  append mybashprefs "}\n"
  append mybashprefs {export -f get_ldsupport_pw

function ldu() {
  perl -e'%h=map{/.\s/;99**(ord$&&7)-$`,$_}`sudo du -h`;print@h{sort%h}'
}
export -f ldu

function update_gpg_key() {
  local apt_keyring=/etc/apt/trusted.gpg
  # the old key expired 04/28/2014
  local old_key="Lincware Repository"
  local apt_lincware_key_file=/etc/apt/trusted.gpg.d/apt.lincware.com.gpg
  # To do: set http_proxy environment var if customer uses a proxy
  local new_key_url=http://apt.lincware.com/apt.lincware.com.gpg
  echo "Attempting to fetch $new_key_url now"
  local new_key_base64="$(curl --silent $new_key_url)"
  sudo -H bash -s << EOSUDO
    gpg --no-default-keyring --with-colons --list-keys --keyring $apt_keyring "$old_key" >/dev/null 2>&1 && {
      # delete old gpg key that expired on 04/28/2014
      gpg --no-default-keyring --keyring $apt_keyring --yes --batch --delete-key "$old_key"
    }
    echo "$new_key_base64" | gpg --no-default-keyring --keyring $apt_lincware_key_file --import
EOSUDO
}
export -f update_gpg_key

OLD_LD_BIN=/opt/lincdoc/trunk/product/bin
if [ -d $OLD_LD_BIN ]; then
  pathadd $OLD_LD_BIN
fi
unset OLD_LD_BIN

function ssh() {
  signal_load_mybashprefs
  /usr/bin/ssh "$@"
  if [ "$EXPECTSSH_IN_SCREEN" = 1 -o -n "$STY" ]; then
    printf "\033k${HOSTNAME}\033\134"
  fi
  return $?
}
export -f ssh

}

  # unset $c, set below
  append mybashprefs "unset c\n"
  # set EXPECT_SSH, this must be the last part of mybashprefs, as we paste the
  # value for EXPECT_SSH below in the send statement
  append mybashprefs "export EXPECT_SSH="

  #exp_internal -f /tmp/log 0

  #
  set mybashprefs_hash [string tolower [md5::md5 -hex $mybashprefs]]
  # Combine my password with md5 hash for the password to encrypt the data,
  # with the md5 in the password we can trigger a re-upload of bash prefs
  # should they change.
  set pass "$MYBASHPREFS_PASSWORD-$mybashprefs_hash"
  send " c=\"\$(openssl enc -a -d -aes256 -in $mybashprefs_file)\" && eval \"\${c}$EXPECT_SSH\"\r"
  set password_was_entered 0
  expect {
    -re "password:$" {
      send $pass\r
      set password_was_entered 1
      exp_continue
    }
    -re "(?:bad decrypt|bad magic number|error reading input file|No such file or directory).*$PROMPT" {
      if { $nest_level > 0 } {
        # do not get in recursive loop attempting to upload + write out bash prefs
        return "NOT OK"
      }
      # compress all the bash commands, base64 encode, pass over the wire,
      # base64 decode, uncompress, then encrypt + base64 encode and write to
      # disk ... but watch out if this base64 string exceeds 4096 bytes (1024
      # for mac) which seems to be the terminal driver limit
      # (http://expect.sourceforge.net/FAQ.html#q76) "terminal input queue"
      # "typeahead buffer" MAX_INPUT
      # "getconf -a|grep MAX_INPUT" may help determine this value
      send "TMP=\$(history|tail -1|awk '{print \$1}') && history -d \$TMP && history -d \$((\$TMP-1)) && HISTCONTROL=ignoreboth:erasedups && unset TMP\r"
      expect -re $PROMPT
      send " \[ ! -d $EXPECTSSH_TMPDIR ] && { mkdir $EXPECTSSH_TMPDIR; chmod 1777 $EXPECTSSH_TMPDIR; }\r"
      expect -re $PROMPT
      #send_user "uploading $mybashprefs_file ...\n"
      # Note the leading space so it is not saved in bash history
      send " \[ ! -e $mybashprefs_file ] && { touch $mybashprefs_file; chmod 666 $mybashprefs_file; }\r"
      expect -re $PROMPT
      send " exec 3< <(echo '$pass')\r"
      expect -re $PROMPT
      send " tty=\$(tty)\r"
      expect -re $PROMPT
      # Delimit the input with a space, and after each line is sent send \r so
      # the terminal does not scroll
      send { while true; do read -d' ' l; [ "$l" = . ] && break; printf "%s\n" $l; printf "\015" >$tty; done}
      send "| openssl enc -d -base64 | gzip -d -c | openssl enc -a -aes256 -pass fd:3 -out $mybashprefs_file; exec 3<&-; unset tty\r"
      expect -re \r\n$
      # split into manageable chunks that will not exceed terminal driver
      # buf size
      set n -1 
      log_user 0
      set mybashprefs_enc [exec "bash" "-c" "echo -n \"\$0\" | gzip -9 -c | openssl enc -base64" $mybashprefs]
      set c_len [string length $mybashprefs_enc]
      foreach line [regexp -all -inline {(?:.{0,80}){1,1}\n} "$mybashprefs_enc\n"] {
        send "[string trimright $line] "
        expect -re "\x0d$"
        if { $n > -1 } { send_user \r }
        incr n [string length $line]
        set precision [string length $c_len]
        send_user [format "%*d/%*d uploaded" $precision $n $precision $c_len]
      }
      send_user " ... DONE with upload\r\n"
      send ". "
      expect ". "
      log_user 1
      expect -re $PROMPT
      return [load_mybashprefs $EXPECT_SSH 1]
    }
    -re $PROMPT {
      # sometimes the prompt can be detected BEFORE we have had a chance to get
      # to openssl's password prompt ...
      if { $password_was_entered == 0 } { exp_continue }
    }
    timeout { send_error "TIMEOUT in proc load_mybashprefs"; return "NOT OK" }
  }
  #exp_internal -f /tmp/log 1
  return "OK"
}
### END of load_mybashprefs

set is_marker_prompt 0
# See if the custom prompt is in effect
proc check_prompt_marker {arr} {
  global is_marker_prompt PS1_MARKER
  upvar $arr arr_ref
  set marker {*}$PS1_MARKER
  if { [info exists arr_ref(2,string)]==1 && [string trim $arr_ref(2,string)]==$marker } {
    set is_marker_prompt 1
  } else {
    set is_marker_prompt 0
  }
  return $is_marker_prompt
}

array set load_mybashprefs_args {}
proc main_prompt_checker {arr} {
  global stdin_buf interact_out expect_out load_mybashprefs_args PROMPT
  set stdin_buf ""
  if { [array size load_mybashprefs_args] > 0 } {
    if { [check_prompt_marker $arr] == 0 } {
      set rc [load_mybashprefs [expr $load_mybashprefs_args(EXPECT_SSH) + 1]]
      if { $rc == "OK" } {
        if { [info exists load_mybashprefs_args(EXPECTSSH_IN_SCREEN)] > 0 && $load_mybashprefs_args(EXPECTSSH_IN_SCREEN)==1 } {
          send " export EXPECTSSH_IN_SCREEN=1 && "
          send {printf "\033k${HOSTNAME}\033\134"}
          send \r
          expect -re $PROMPT
        }
        if { [info exists load_mybashprefs_args(CMD_ARRAY)] > 0 && $load_mybashprefs_args(CMD_ARRAY) != "declare -a CMD_ARRAY='()'" } {
          send " $load_mybashprefs_args(CMD_ARRAY) && eval \"\${CMD_ARRAY\[@]}\"\r"
        }
      }
    }
  }
  array unset load_mybashprefs_args
}

#if {[catch {fconfigure stdin -mode}]} {
#  # Running ssh in a pipeline, stdin is not a keyboard
#  eval [list system] /usr/bin/ssh $argv
#  exit
#}
set local_shell_only 0
set stdin_buf ""
set argv2 {}
foreach arg $argv {
  if { $arg == "-help" } {
    puts "This is ssh-expect, an ssh wrapper to make things"
    puts "easier when ssh-ing to multiple hosts, and sudo-ing"
    puts "to multiple users. Options:"
    puts "  -help   this help menu"
    puts "  -shell  don't ssh but instead run a local bash shell"
    puts "All other arguments are passed directly to ssh."
    puts "While inside any session, type these at a prompt:"
    puts "  ~d      toggle debug mode (writes to $LOGFILE)"
    puts "  ~i      load bash functions/preferences"
    puts "  ~k      kill expect: useful if running screen, and you"
    puts "          want to resume screen from another desktop"
    puts "Upon starting, Expect statements can be placed in"
    puts "~/.expect-ssh/config and they get sourced."
    exit
  }
  if { $arg == "-local_shell_only" || $arg == "-shell" } {
    set local_shell_only 1
  } elseif { $arg == "-debug" } {
    # truncate the file first
    close [open $LOGFILE "w"]
    exp_internal -f $LOGFILE 0
    send_user "DEBUG MODE: sending output for this session to $LOGFILE\n"
  } else {
    lappend argv2 "$arg"
  }
}

trap {
  resize_handler
} WINCH

proc process_keystroke {c} {
  # monitor keyboard input for ~i immediately following a bash prompt, and load
  # bash prefs if user types in that sequence ... cuts down on false positives
  # if say we are inside vim and use that sequence. Must do it by monitoring 1
  # keystroke at a time, putting keystrokes into buffer variable stdin_buf.
  global stdin_buf env LOGFILE PROMPT
  append stdin_buf $c
  set buflen [string length $stdin_buf]
  if { $stdin_buf == "~i" } {
    load_mybashprefs $env(EXPECT_SSH)
    set stdin_buf ""
  } elseif { $stdin_buf == "~k" } {
    # useful when screen was launched remotely, and you want to take it
    # over on your local machine
    stty echo
    puts "Type YES to kill expect: "
    gets stdin ans
    if { $ans == "YES" } { exit } else { stty -echo }
  } elseif { $stdin_buf == "~d" } {
    # toggle debug mode
    set curr [exp_internal -info]
    if { [string first "$LOGFILE" "$curr"] >= 0 } {
      send_user "DEBUG MODE is now OFF\r"
      send_log \n
      exp_internal 0
    } else {
      # truncate the file first
      close [open $LOGFILE "w"]
      exp_internal -f $LOGFILE 0
      send_user "DEBUG MODE: sending output for this session to $LOGFILE"
      send_log \n
    }
    set stdin_buf ""
    send \r
  } elseif { $stdin_buf == "~u" } {
    upload_file
    set stdin_buf ""
  } else {
    if { $buflen == 1 } {
      if { $c != "~" } { send -- $c }
    } else {
      send -- $c
      # set stdin_buf to any non-blank value
      set stdin_buf "-"
    }
  }
}

proc process_ldsupport_request {ld_url enc_pass} {
  global LD_SUPPORT_BASIC_AUTH PROMPT OS
  set url https://svn.lincware.com/lw/ldsupportpw
  catch {
    set ld_support_pw [exec curl -s -H "Authorization: Basic $LD_SUPPORT_BASIC_AUTH" --data "$enc_pass" $url]
  } ld_support_pw
  expect -re $PROMPT
  if { [regexp {^[-\w]+$} $ld_support_pw] } {
    send " echo password is: $ld_support_pw\r"
    expect -re $PROMPT
    if { "$OS" == "Linux" } {
      exec sh -c "printf '%s' \"\$0\" | clipit 2>&1" $ld_support_pw
      system xdg-open $ld_url >/dev/null &
    } elseif { "$OS" == "Darwin" } {
      exec sh -c "printf '%s' \"\$0\" | pbcopy 2>&1" $ld_support_pw
      system open $ld_url &
    }
  } else {
    send_error "ERROR: could not read ldsupport password: further info: $ld_support_pw"
  }
}

if { $local_shell_only == 1 } {
  eval [list spawn -noecho] /bin/bash
} else {
  eval [list spawn -noecho] /usr/bin/ssh $argv2
}
# spawn command above will set spawn_out
set spawn_out_slave_name $spawn_out(slave,name)
# force-resize: needed if on Mac in terminal full screen mode
resize_handler
load_mybashprefs $env(EXPECT_SSH)

interact {
  # "If two or more patterns can match the same output, only one action will
  # be executed. The action corresponds to the pattern that appears first in
  # the command."
  -re "." { process_keystroke $interact_out(0,string) }
  # "All the patterns before the -o apply to the user keystrokes. All the
  # patterns after the -o apply to the spawned process."
  -o
  -nobuffer -re $PROMPT { main_prompt_checker interact_out }
  #-re {(?:^|[\r\n](?:$ANSI_RE_GENERAL)*)~copy_to_clipboard_in_vim[^\w].*} {
    #send ":!copy_to_clipboard \$VIM_CLIPBOARD\r"
    #expect -re $COPY_TO_CLIPBOARD_BEGIN_RE
    #set n [copy_to_clipboard]
    #expect {
      #-re {Press ENTER or type command to continue.*$} {
	#send "\r"
	#expect -re "$ANSI_RE_SHOW_CURSOR$"
	#send ":echon \"$n characters were copied to clipboard\"\r"
	#expect -re "$ANSI_RE_SHOW_CURSOR$"
      #}
      #-re {has changed since editing started.*\(L\)oad File: $} {}
    #}
  #}
  -nobuffer -re \[\n\r]$GENERIC_MARKER {
    set marker_type $interact_out(1,string)
    set encoded_args ""
    expect \n
    expect {
      -re "(\[^\\.]*)\\." {
	append encoded_args $expect_out(1,string)
      }
      -re "(\[^\\.]{1,255})" {
	append encoded_args $expect_out(1,string)
	exp_continue
      }
    }
    # convert all \015 back to \n
    regsub -all "\015" $encoded_args "\n" encoded_args
    if { $marker_type == $MARKER(LOAD_MYBASHPREFS) } {
      #
      # We have a request to load bash prefs into the current shell, but we
      # only do that under certain conditions below. For example, "ssh
      # localhost uname" should NOT trigger loading bash prefs, but "ssh
      # localhost" should.
      #
      array set load_mybashprefs_args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
    } elseif { $marker_type == $MARKER(COPY_TO_CLIPBOARD) } {
      copy_to_clipboard $encoded_args
    } elseif { $marker_type == $MARKER(DOWNLOAD_DEFAULT_FILE) } {
      array set args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
      set outfile [get_download_filename $args(default_file_name)]
      if { $outfile == "" } {
	# discontinue downloading
	send "NO\r"
      } else {
	send "y\r"
	expect -ex \n
      }
    } elseif { $marker_type == $MARKER(DOWNLOAD_DATA) } {
      download $outfile $encoded_args
    } elseif { $marker_type == $MARKER(LDSUPPORT_PW) } {
      array set args [exec sh -c "printf '%s\n' \"\$0\" | /usr/bin/openssl enc -base64 -d | gzip -d -c" $encoded_args]
      process_ldsupport_request $args(ld_url) $args(enc_pass)
    } elseif { $marker_type == $MARKER(VIM_PASTE_CLIPBOARD) } {
      paste_from_clipboard_in_vim
    }
  }
  #-nobuffer -re {\npsql .*Type "help" for help(.*)[#>] $} {
    #if { [string first "\\set PROMPT1" $interact_out(1,string) ] < 0 } {
      #send "\\set PROMPT1 '%n@%m:%/> '\r"
      #expect -re "> $"
      #send "\\set PROMPT2 '> '\r"
    #}
  #}
}
EXPECT_EOF
