proc read_from_client_sock {chan BYTES_READ_var decoded_args_var status_var} {
  upvar $BYTES_READ_var BYTES_READ
  upvar $decoded_args_var decoded_args
  upvar $status_var STATUS
  catch {
    set l [gets $chan]
    return
  } err
  if {[string length $err]>0} {
    send_error "read_from_client_sock: channel $chan: $err\r\n"
    return
  }
  append decoded_args $l
  incr BYTES_READ [string length $l]
  if {[eof $chan]} {
    set b [fblocked $chan]
    if {$b==1} {
      send_error "read_from_client_sock:EOF detected in $chan, but fblocked==1\r\n"
    } else {
      close $chan
      set STATUS DONE
    }
    return
  }
  # unlikely to be blocked, but perhaps
  if {[fblocked $chan]==0 && [string length $l]>0} {
    append decoded_args \n
  }
}

proc Command_Server {client_sock client_addr client_port} {
  global MARKER
  fconfigure $client_sock -translation binary -encoding binary
  #puts "Accept $client_sock from $client_addr:$client_port"
  gets $client_sock line
  variable marker_idx [lindex [eval list $line] 0]
  # strip leading zero, else may be interpreted as octal
  regexp {^0*(\d+)} $marker_idx - marker_idx
  variable marker [get_marker_word $marker_idx]
  variable decoded_args ""
  variable STATUS ""
  variable BYTES_READ 0
  if {[eof $client_sock]==0} {
    variable chan [open "| /usr/bin/openssl enc -base64 -d | gzip -d -c" r+]
    fconfigure $chan -translation binary -encoding binary -blocking 0
    # The script for a file event is executed at global level (outside the
    # context of any Tcl procedure) in the interpreter in which the fileevent
    # command was invoked. If an error occurs while executing the script then
    # the bgerror mechanism is used to report the error.
    fileevent $chan readable [list read_from_client_sock $chan BYTES_READ decoded_args STATUS]
    while 1 {
      gets $client_sock l
      if {$l eq "."} {
        chan close $chan write
        break
      }
      puts $chan $l
      if {[eof $client_sock]} {
        break
      }
    }
    vwait STATUS
  }
  foreach key [array names MARKER -regexp {^(\w+)$}] {
    if {$marker_idx == $MARKER($key,idx)} {
      set handler $MARKER($key,handler)
      catch {
        eval [list $handler $client_sock $decoded_args]
      } err
      if {[string length $err]>0} {
        send_error "ERROR invoking handler $handler: $err\r\n"
        send_log "decoded_args=<$decoded_args>\r\n"
      }
    }
  }
  flush $client_sock
  close $client_sock
}
