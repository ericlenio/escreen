_ES_register_marker DOWNLOAD_DEFAULT_FILE download_default_file_handler
_ES_register_marker DOWNLOAD_DATA download_data_handler

proc download_default_file_handler {decoded_args} {
  array set args $decoded_args
  set outfile [get_download_filename $args(default_file_name)]
  if { $outfile == "" } {
    # discontinue downloading
    send "\r"
  } else {
    send "$outfile\r"
    expect -ex \n
  }
}

proc download_data_handler {decoded_args} {
  array set args $decoded_args
  set outfile $args(outfile)
  set l -1
  if { [catch {
    set chan [open "|/usr/bin/openssl enc -base64 -d | gzip -d -c > \"$outfile\"" w]
    fconfigure $chan -translation binary -encoding binary
    puts $chan $args(content)
    flush $chan
    close $chan
    set l [file size $outfile]
    # bash is doing a read operation, send along a status line too
    send "DONE...downloaded to $outfile, $l bytes\r"
    } err] } {
    send_error "ERROR in download_data_handler: $err\r\n"
  }
  return ""
}

proc get_download_filename {default_file_name} {
  global spawn_id
  set default_outfile "/tmp/$default_file_name"
  set outfile ""
  set main_spawn_id $spawn_id
  set bashscript {function get_download_file() {
    read -e -p 'Save downloaded file to (leave blank to cancel): ' f
    if [ -z "$f" ]; then return; fi
    if [ -e "$f" -a ! -w "$f" ]; then echo "ERROR: $f is not writable"; return; fi
    local dir=$(dirname "$f")
    if [ -z "$dir" ]; then dir=$(pwd); fi
    if [ ! -e "$f" -a ! -w "$dir" ]; then echo "ERROR: directory $dir is not writable"; return; fi
    echo "File will be downloaded to: $f"
    }
    get_download_file
  }
  spawn -noecho /bin/bash --norc --noprofile -c {eval "$0"} $bashscript
  expect ": "
  send $default_outfile
  interact {
    -o -nobuffer -re "File will be downloaded to: (.*)\r" {
      set outfile $interact_out(1,string)
    }
  }
  set spawn_id $main_spawn_id
  return $outfile
}
