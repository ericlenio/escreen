# vim:filetype=sh
# Upload a file from the system that launched escreen to the current running
# shell's working directory.
upload() {
  # esh_port0 is ESH_PORT from the system that launched escreen
  local esh_port0=$(_esh_b getEnv ESH_PORT)
  local sshuser=$(_esh_b getEnv USER)
  local token=$(openssl rand -hex 4)
  #
  # Strategy: launch a shell back on originating escreen system and utilize
  # bash's readline path autocomplete feature to pick a file.
  #
  /usr/bin/ssh -t -q -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null \
    -oProxyCommand='bash -c "{ echo $ESH_AT sshd; cat; } | nc localhost $ESH_PORT"' $sshuser@fakehost \
    /bin/bash -c '"read -p \"Logged in to \$(hostname). Pick a file to upload: \" -e f; [ -r \"\$f\" ] && [ ! -d \"\$f\" ] && { echo '$ESH_AT' setUploadFilename '$token' \$(echo -n \"\$f\" | openssl enc -base64 -A) | nc localhost '$esh_port0'; } || { echo \"Not a file, or not readable: \$f\"; exit 1; }"' || return
  local upload_file=$(_esh_b getUploadFilename $token)
  [ -z "$upload_file" ] && return
  upload_file=$(basename "$upload_file")
  echo "uploading now ..."
  local setmode=0
  # only set the mode if file did not previously exist (locally)
  [ ! -f "$upload_file" ] && setmode=1
  echo $ESH_AT getUploadFile $token | $ESH_NC localhost $ESH_PORT > "$upload_file"
  # Use md5 to verify the file transferred correctly
  local expected_md5=$(_esh_b getUploadFileHash $token)
  if [ $setmode = 1 ]; then
    local mode=$(_esh_b getUploadFileMode $token)
    chmod $mode "$upload_file"
    echo "set mode: $mode"
  fi
  local md5=$(openssl md5 -hex "$upload_file")
  # md5 will look something like this:
  # MD5(somefile)= 7f851736b8f86d8ee734a5d94bedf2f7
  # remove the prefix
  md5=${md5##*= }
  # force to lowercase
  md5=${md5,,}
  if [ "$md5" != "$expected_md5" ]; then
    echo "ERROR: md5 check failed for $upload_file"
  else
    echo "SUCCESS: MD5 check verified for $upload_file"
  fi
  _esh_b dropUploadToken $token
}
