# vim:filetype=sh
#
# Good test:
# ssh localhost -t -A -oPermitLocalCommand=yes -oLocalCommand="bash -c 'date && pwd'" uname
#
ssh() {
  if [ ! -t 0 -o ! -t 1 ]; then
    # in a pipeline
    env ssh "$@"
    return $?
  fi
  # openssh introduced multiplexing in 3.9
  # ControlMaster=auto introduced in 4.2
  # ControlPersist introduced in 5.6
  # must use unique cp_prefix that enables us to parse out the ssh port from
  # the control master socket
  local last_arg=${@:$#}
  [ -z "$last_arg" ] && { echo "no arguments to ssh?"; return; }
  # Need to determine now if we are just running a plain shell in the remote
  # host, or some other command. For the former case, we set up a
  # ControlMaster; for the latter, no ControlMaster is necessary and we just
  # run the command as is.
  #
  # So now we strip out all the ssh options. What's left would be the
  # user@ssh_host part (or just ssh_host), and possibly a command + args to be
  # run on the remote host.
  #
  # List of legal ssh options: pulled from ssh.c from openssh-client debian
  # package. As these options can change my preference was to go about it a
  # different way: it could potentially be done with ssh's Match statement:
  # acquire original ssh host from something like:
  #   Match exec "bash -c 'echo orighost=%n'"
  # but that statement cannot work on a command line, only inside
  # ~/.ssh/config, so not really a viable option.
  local ssh_legal_opts="1246ab:c:e:fgi:kl:m:no:p:qstvxACD:E:F:I:KL:MNO:PQ:R:S:TVw:W:XYy"
  local OPTS
  local origArgs=("$@")
  local -a ssh_opts
  local force_tty=0
  local uname=$(uname)
  if [ $uname = Darwin ]; then
    OPTS=$(getopt $ssh_legal_opts "$@")
  else
    OPTS=$(getopt -o $ssh_legal_opts -- "$@")
  fi
  # set temporary positional parameters
  eval set -- "$OPTS"
  # strip out all ssh command line options
  while true; do
    local arg1=$1
    shift
    [ "$arg1" = -- ] && break
    [ "$arg1" = -t ] && force_tty=1
    ssh_opts+=("$arg1")
  done
  if [ $# = 0 ]; then
    # Might have done -V, allow to continue
    env ssh "${ssh_opts[@]}"
    return $?
  fi
  # should now have user@ssh_host, or just plain ssh_host
  local ssh_user_host="$1"
  local cmdline_ssh_host=${ssh_user_host##*@}
  shift
  local sshV=$(env ssh -V 2>&1)
  if [[ "$sshV" =~ OpenSSH_([[:digit:]]+)\.([[:digit:]]+) ]]; then
    local ssh_major=${BASH_REMATCH[1]}
    local ssh_minor=${BASH_REMATCH[2]}
  fi
  local -a remote_cmd=( exec \`which bash\` --norc --noprofile )
  [ -n "$STY" ] && {
    local h=$cmdline_ssh_host
    [ -n "$SSH_STY_LBL" ] && h=$SSH_STY_LBL
    printf "\033k$h\033\134"
  }
  # if anything left in the command line (and ssh option -t is not set), then
  # we just do straight through call to ssh, no ControlMaster. If -t is set
  # then we assume we want to still do a ControlMaster and initialize the
  # remote environment.
  if [ $# -gt 0 -a $force_tty = 0 ]; then
    env ssh "${origArgs[@]}"
  else
    [ $# -gt 0 ] && remote_cmd=( "$@" )
    #
    # We need an open port on the remote host. Pick a random port and hope it
    # is open: worst case is the port is not open, and
    # -oExitOnForwardFailure=yes causes it to fail, and user can then just
    # re-issue the same ssh command. Deemed a small enough risk to be
    # acceptable. Other strategies that were considered:
    # 1) ssh to host and find a known open port: at the expense of 2 separate
    # ssh connections
    # 2) run a ControlMaster, and then a separate ssh command to find the port:
    # good with modern ssh's, but various issues with older ssh (like 4.7 on
    # Ubuntu Hardy)
    # 3) After connecting to remote ssh host, find open port, then run GNU
    # screen escape to run ssh escape command (ESC ] 83 ; cmd ^G) to forward
    # the port: this leads to terminal IO issues when stuffing the ssh escape
    # command into the terminal driver.
    local rem_port=$(( $RANDOM % 1000 + 56100 ))
    local c="$(bash_init_string $ssh_user_host-0000 $rem_port|gzip -9 -c|openssl enc -a -A)"
    #
    # Assumption: /bin/sh exists on remote system. We use it to check for
    # /bin/bash, and if that exists set up prefered bash shell settings.
    # Otherwise, run default login shell.
    env ssh "${ssh_opts[@]}" -t -oExitOnForwardFailure=yes -R$rem_port:localhost:$(_esh_p) $ssh_user_host -- sh -c "'"'b=`which bash`; [ "$b" ] && exec $b -c "eval $(echo '$c'|openssl enc -d -a -A|gzip -d -c)" - "$@" || exec $SHELL -l'"'" - "${remote_cmd[@]}"
  fi
  local sshrc=$?
  [ "$STY" ] && printf "\033k${HOSTNAME}\033\134"
  return $sshrc
}
export -f ssh
