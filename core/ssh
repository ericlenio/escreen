# vim:filetype=sh
#
# Good test:
# ssh localhost -t -A -oPermitLocalCommand=yes -oLocalCommand="bash -c 'date && pwd'" uname
#
ssh() {
  if [ ! -t 0 -o ! -t 1 ]; then
    # in a pipeline
    env ssh "$@"
    return $?
  fi
  # openssh introduced multiplexing in 3.9
  # ControlMaster=auto introduced in 4.2
  # ControlPersist introduced in 5.6
  # must use unique cp_prefix that enables us to parse out the ssh port from
  # the control master socket
  local last_arg=${@:$#}
  [ -z "$last_arg" ] && { echo "no arguments to ssh?"; return; }
  # Need to determine now if we are just running a plain shell in the remote
  # host, or some other command. For the former case, we set up a
  # ControlMaster; for the latter, no ControlMaster is necessary and we just
  # run the command as is.
  #
  # So now we strip out all the ssh options. What's left would be the
  # user@ssh_host part (or just ssh_host), and possibly a command + args to be
  # run on the remote host.
  #
  # List of legal ssh options: pulled from ssh.c from openssh-client debian
  # package. As these options can change my preference was to go about it a
  # different way: it could potentially be done with ssh's Match statement:
  # acquire original ssh host from something like:
  #   Match exec "bash -c 'echo orighost=%n'"
  # but that statement cannot work on a command line, only inside
  # ~/.ssh/config, so not really a viable option.
  local ssh_legal_opts="1246ab:c:e:fgi:kl:m:no:p:qstvxACD:E:F:I:KL:MNO:PQ:R:S:TVw:W:XYy" \
    OPTS origArgs=("$@") force_tty=0 uname=$(uname) arg1
  local -a ssh_opts
  OPTIND=1
  while builtin getopts $ssh_legal_opts arg1; do
    [ "$arg1" = -t ] && force_tty=1
    ssh_opts+=("-$arg1")
    [ "$OPTARG" ] && ssh_opts+=("$OPTARG")
  done
  # shift the argument list until we strip out all ssh arguments just acquired
  # from getopts; after this loop we know the ssh host is left in $1 (assuming
  # an ssh host was provided on the command line, which is most of the time)
  [ $OPTIND -gt 1 ] && for arg1 in {2..$OPTIND}; do shift; done
  if [ $# = 0 ]; then
    # Might have done -V, allow to continue
    env ssh "${ssh_opts[@]}"
    return $?
  fi
  # should now have user@ssh_host left in function arguments, or just plain
  # ssh_host
  local ssh_user_host="$1" sshV=$(env ssh -V 2>&1) sshrc ssh_major ssh_minor
  local cmdline_ssh_host=${ssh_user_host##*@}
  shift
  if [[ $sshV =~ OpenSSH_([0-9]+)\.([0-9]+) ]]; then
    ssh_major=${BASH_REMATCH[1]} ssh_minor=${BASH_REMATCH[2]}
  fi
  local -a remote_cmd=(exec env bash --norc --noprofile)
  [ "$STY" ] && {
    local h=$cmdline_ssh_host
    [ "$SSH_STY_LBL" ] && h=$SSH_STY_LBL
    printf "\033k$h\033\134"
  }
  eval $(_esh_e)
  # if anything left in the command line (and ssh option -t is not set), then
  # we just do straight through call to ssh, no ControlMaster. If -t is set
  # then we assume we want to still do a ControlMaster and initialize the
  # remote environment.
  if [ $# -gt 0 -a $force_tty = 0 ]; then
    env ssh "${origArgs[@]}"
    sshrc=$?
  else
    [ $# -gt 0 ] && remote_cmd=( "$@" )
    #
    # We need an open port on the remote host. Pick a random port and hope it
    # is open: worst case is the port is not open, and
    # -oExitOnForwardFailure=yes causes it to fail, and user can then just
    # re-issue the same ssh command. Deemed a small enough risk to be
    # acceptable. Other strategies that were considered:
    #
    # 1) ssh to host and find a known open port: at the expense of 2 separate
    # ssh connections
    #
    # 2) run a ControlMaster, and then a separate ssh command to find the port:
    # good with modern ssh's, but various issues with older ssh (like 4.7 on
    # Ubuntu Hardy)
    #
    # 3) After connecting to remote ssh host, find open port, then run GNU
    # screen escape to run ssh escape command (ESC ] 83 ; cmd ^G) to forward
    # the port: this leads to terminal IO issues when stuffing the ssh escape
    # command into the terminal driver.
    #
    local rem_port=$(( $RANDOM % 1000 + 56100 ))
    #
    # Assumption: /bin/sh exists on remote system. We use it to check for
    # /bin/bash, and if that exists set up prefered bash shell settings.
    # Otherwise, run default login shell.
    #
    # OLD WAY: gzip + base64 encode to pass init code to remote session ...
    #
    #local c="$(bash_init_string $ssh_user_host-0000 $rem_port|gzip -9 -c|openssl enc -a -A)"
    #env ssh "${ssh_opts[@]}" -t -oExitOnForwardFailure=yes -R$rem_port:localhost:$(_esh_e) $ssh_user_host -- sh -c "'"'b=`which bash`; [ "$b" ] && exec $b -c "eval $(echo '$c'|openssl enc -d -a -A|gzip -d -c)" - "$@" || exec $SHELL -l'"'" - "${remote_cmd[@]}"
    #
    # NEW WAY: just gzip and send the init code via netcat; requires opening a
    # 2nd forwarded port; this way saves the overhead of the base64 encoding
    #
    # Kinda dumb, just add 1 to rem_port for our 2nd port ... probably should
    # use something for find known open local port at least (but knowing it is
    # open on the remote end is still an unknown)
    local port2=$(( $rem_port + 1 )) id=$(printf %x $(date +%s))
    (
      # set up a channel to pass code to remote end to init the session; doing
      # it in a sub-shell here so that the backgrounded nc process does not
      # display its job number to the screen (bash does it by default for all
      # backgrounded jobs)
      bash_init_string $ssh_user_host-$id $rem_port | gzip -9 -c | nc -l localhost $port2 &
      pid=$!
      # make sure nc process is stopped
      (sleep 30; kill $pid 2>/dev/null) &
    )
    ssh_opts+=(
      -t -oExitOnForwardFailure=yes
      -R$rem_port:localhost:$ESH_PORT -R$port2:localhost:$port2 $ssh_user_host
      # for the last arg to ssh_opts we build out a pretty long initialization
      # string; assume that remote end at least has sh; weird use of nc below:
      # we first try "nc -d" which works on most systems but fall back to "nc
      # ... </dev/null" which was needed for (at least) Ubuntu 10
'
exec sh << "EOF1"
b=`which bash`
[ ! "$b" ] && exec $SHELL -l 0<>$SSH_TTY
exec $b << "EOF2"
[ -f /etc/escreen.sshrc ] && source /etc/escreen.sshrc
eval "$(nc localhost '$port2' </dev/null | gzip -d -c)"
'"${remote_cmd[@]}"' 0<>$SSH_TTY
EOF2
EOF1
')
    env ssh "${ssh_opts[@]}"
    sshrc=$?
  fi
  [ "$STY" ] && printf "\033k${HOSTNAME}\033\134"
  return $sshrc
}
export -f ssh
