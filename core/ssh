# vim:filetype=sh
function ssh() {
  if [ -t 1 ]; then
    local cp_prefix=$ESH_TMP/$USER.ssh-ctrl-path:$$:
    local cp_mask=$cp_prefix%r:%h:%n:%p
    rm -f $cp_prefix*
    local last_arg=${@:$#}
    [ -z "$last_arg" ] && { echo "no arguments to ssh?"; return; }
    /usr/bin/ssh -oControlMaster=yes -S $cp_mask -n -N "$@" | {
      # wait for ControlPath file to exist
      while [ -z "$(ls $cp_prefix* 2>/dev/null)" ]; do
        sleep 0.1
      done
      # find ssh host from ControlPath file that just was created
      local ssh_host=$(ls $cp_prefix* | cut -d: -f 4)
      # find ssh host, as specified on command line, from ControlPath file that just was created
      local cmdline_ssh_host=$(ls $cp_prefix* | cut -d: -f 5)
      [ -n "$STY" ] && printf "\033k${cmdline_ssh_host}\033\134"
      # test if bash exists
      local has_bash=$(/usr/bin/ssh -S $cp_mask $cmdline_ssh_host 'sh -c "[ -f /bin/bash ] && echo 1"')
      # now do actual ssh session
      if [ "$has_bash" = 1 ]; then
        # 
        # ASSUMPTION: all args after the ssh host are part of the command to be
        # run on remote host

        # ssh_args: args up to and including ssh host
        local ssh_args=()
        # args_after_host: all args after the ssh host
        local args_after_host=()
        local use=0
        local arg
        for arg in "$@"; do
          [ $use = 0 ] && ssh_args[${#ssh_args[@]}]="$arg"
          [ $use = 1 ] && args_after_host[${#args_after_host[@]}]="$arg"
          [ "$arg" = $cmdline_ssh_host ] && use=1
        done
        if [ "$last_arg" = "$cmdline_ssh_host" ]; then
          args_after_host=( exec /bin/bash --norc --noprofile )
          # set up channel to Command_Server
          local rem_port=$(/usr/bin/ssh -q -S $cp_mask -O forward -R0:localhost:$ESH_PORT $cmdline_ssh_host)
          # This works, but is insecure
          #/usr/bin/ssh -t -S $cp_mask "$@" "ESH_PORT=$rem_port;$(declare -f _esh_b);eval \"\$(_esh_b zI)\"; /bin/bash --norc --noprofile" </dev/tty
          # 
          # This approach is better, uses a 1 time auth token so you can see it
          # in ps -fe, but at that point it is already expired
          /usr/bin/ssh -t -S $cp_mask "${ssh_args[@]}" $(bash_init_string $rem_port </dev/null) -- "${args_after_host[@]}" </dev/tty
        else
          # Simpler, but then we don't have custom functions on other end: assuming that
          # we just want to run a quick command
          /usr/bin/ssh -S $cp_mask "$@"
        fi
      else
        /usr/bin/ssh -S $cp_mask "$@" </dev/tty
      fi
      # tear down the ControlMaster
      /usr/bin/ssh -S $cp_mask -O exit $cmdline_ssh_host
      [ -n "$STY" ] && printf "\033k${HOSTNAME}\033\134"
    }
    rm -f $cp_prefix*
  else
    # we are in a pipeline
    /usr/bin/ssh "$@"
  fi
}
export -f ssh
