#! /bin/bash

# bootstrapping function: 1st arg is an event ID that the server will inspect
# and run appropriate event handler for; event IDs starting with "z" send back
# a gzip'd response from the server.
#_esh_b() {
  #exec 3<>/dev/tcp/localhost/$ESH_PORT
  #echo $ESH_AT "$*" >&3
  ## Send stdin of this function to esh server (like with cp2cb). This next
  ## cat may show "Resource temporarily unavailable" under certain
  ## conditions, if so generally just set stdin of caller to </dev/null.
  #[ ! -t 0 ] && cat >&3
  #[ ${1:0:1} = z ] && gzip -d -c <&3 || cat <&3
  #exec 3<&- 3>&-
#}
# older shells may not be able to do the /dev/tcp/host/port trick, this works
# around that ... netcat will be needed though
_esh_b() {
  {
    echo $ESH_AT "$*"
    [ ! -t 0 ] && cat
  } | nc -q -1 localhost $ESH_PORT | {
    [ ${1:0:1} = z ] && gzip -d -c || cat
  }
}
export -f _esh_b

# load a bash function into the session: first try using cached version,
# re-uploading if it is out of date (or non-existent). Args:
# 1: full pathname to cached file
# 2: optional: password (just be sure to pass a known valid password)
# 3: optional: if non-zero length, just echo the cached file; default is
# to eval it
_esh_l() {
  local f=$1 c p o
  p=$([ "$2" ] && echo $2 || echo $(_esh_b fpw ${f/*.}))
  o="openssl enc -a -aes256 -pass pass:$p"
  # try to use the cached file first ...
  [ -f $f ] && c="$($o -d -in $f 2>/dev/null)" || {
    # cached file does not exist or is expired, so re-cache it
    echo up:${f/*.} >&2
    c="$(_esh_b zup ${f/*.})"
    echo "$c" | $o >$f
    chmod 666 $f
  }
  [ -z "$3" ] && eval "$c" || echo "$c"
}
export -f _esh_l

export ESH_AT=$(openssl rand 3 -hex)
export ESH_TMP=/tmp/esh

# shell init script here
eval '_esh_I() {
  # p0, p1, p2 are set by fpw call
  local 't=$ESH_TMP u=$USER' $(_esh_b fpw cbf)
  [ ! -d $t ] && mkdir $t && chmod 1777 $t
  _esh_l $t/$u.core $p0
  _esh_l $t/$u.bashrc $p1
  for f in $(_esh_l $t/$u.fcnlist $p2 1); do
    _esh_gen_stub $t/$u.f.$f
  done
  export ESH_PORT ESH_AT ESH_TMP ESH_STY
  export -f _esh_I _esh_b _esh_l
}'

export ESH_HOME=$(dirname $(readlink -f $0))
ESH_CORE=$ESH_HOME/core
ESH_PROFILE=$ESH_HOME/profile.lenio
export ESH_PORT=$(node $ESH_HOME/GetFreePort.js)
[ -z "$ESH_PORT" ] && {
  echo "ERROR: could not get free port."
  exit 1
}

export ESH_LOGFILE=$ESH_TMP/$USER.esh.log.$ESH_PORT
touch $ESH_LOGFILE
chmod 600 $ESH_LOGFILE
node $ESH_HOME/EscreenRunServer.js $ESH_PORT >$ESH_LOGFILE 2>&1 </dev/null &
export ESH_NODE_PID=$!
while ! nc -z localhost $ESH_PORT; do
  sleep 0.1
  echo -n z
done
_esh_I
ESH_SCREEN_EXEC=1
screen -- bash -c '/usr/bin/screen -S $STY -X monitor off;nohup sh -c "while kill -0 ${STY%%.*}; do sleep 5; done; kill '$ESH_NODE_PID'; sleep 3600; rm -f '$ESH_LOGFILE';" </dev/null >/dev/null 2>&1 & tail -f '$ESH_LOGFILE
