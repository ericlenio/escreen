#! /bin/bash

screen_exec=$(which screen)
if [ "$1" = -r ]; then
  if [ -z "$ESH_AT" ]; then
    echo "Oops, you do not appear to already be in an escreen session, exiting."
    exit 1
  fi
  curr_sty=${STY:-some_value}
  screen_stys=($($screen_exec -ls | grep -v $curr_sty | perl -n -e 's{^\s*(\d+\.\S+).*}{$1} && print'))
  if [ ${#screen_stys} = 0 ]; then
    echo "No escreen sessions detected."
    exit 1
  fi
  printf "Resume which escreen session?\n"
  i=0
  IFS='\n' $screen_exec -ls | grep -v $curr_sty | perl -n -e 's{^\s*(\d+\..*)}{$1} && print' | while read l; do
    printf "%s. %s\n" $i "$l"
    i=$(($i+1))
  done
  read -p "Enter choice: " choice
  if [ "$choice" -a ${screen_stys[$choice]+is_set} ]; then
    sty=${screen_stys[$choice]}
    $screen_exec -S $sty -X screen bash -c "_esh_b forwardEscreen $ESH_PORT $ESH_AT $(echo -n $ESH_NC|openssl enc -A -base64)"
    $screen_exec -S $sty -X escape ^ee
    $screen_exec -d -r $sty
    $screen_exec -S $sty -X screen bash -c "_esh_b unforwardEscreen"
    exit
  else
    echo "Invalid choice."
    exit 1
  fi
fi
#
# get/set the main communications port, and other environment variables
#
# if 0 args: cat out current variables from file
#
# if 1 arg: copy variables from old file to new file
#
# if 2+ args:
# 1st arg: $ESH_STY value
# 2nd arg: name of variable 1
# 3rd arg: value of variable 1
# 4th arg: name of variable 2
# 5th arg: value of variable 2
# ... etc.
#
_esh_e() {
  local s=${1:-$ESH_STY} n v f
  # little nested function here to derive name of file to stash environment
  # vars
  F() {
    printf "%s/STY-%s.env" $ESH_TMP $1
  }
  f=$(F $s)
  case $# in
    0)
      cat $f
      ;;
    1)
      case $1 in
        -f)
          F $ESH_STY
          ;;
        *)
          cat $(F $ESH_STY) > $f
          echo wrote $f: $(cat $f) 1>&2
          ;;
      esac
      ;;
    *)
      shift
      rm -f $f && touch $f && {
        while [ $# -gt 0 ]; do
          n=$1; shift
          v=$1; shift
          echo "declare $n='$v'">>$f
        done
        echo wrote $f: $(cat $f) 1>&2
      }
  esac
}
export -f _esh_e

# bootstrapping function: 1st arg is an event ID that the server will inspect
# and run appropriate event handler for; event IDs starting with "z" send back
# a gzip'd response from the server.
#_esh_b() {
  #exec 3<>/dev/tcp/localhost/$ESH_PORT
  #echo $ESH_AT "$*" >&3
  ## Send stdin of this function to esh server (like with cp2cb). This next
  ## cat may show "Resource temporarily unavailable" under certain
  ## conditions, if so generally just set stdin of caller to </dev/null.
  #[ ! -t 0 ] && cat >&3
  #[ ${1:0:1} = z ] && gzip -d -c <&3 || cat <&3
  #exec 3<&- 3>&-
#}
# older shells may not be able to do the /dev/tcp/host/port trick, this works
# around that ... netcat will be needed though
_esh_b() {
  eval $(_esh_e)
  {
    echo $ESH_AT "$*"
    # must unbuffer output for large file downloads ... "sed -u" not
    # compatible with OSX though
    #[ ! -t 0 ] && sed -u ''
    [ ! -t 0 ] && perl -pe 'BEGIN{$|=1}'
  } | \
  $ESH_NC localhost $ESH_PORT | {
    [ ${1:0:1} = z ] && gzip -d -c || cat
  }
}
export -f _esh_b

#_esh_b_TEST() {
  #perl -pe 'BEGIN{shift;@a=@ARGV;undef @ARGV;printf "%s %s\n",$ENV{ESH_AT},join(" ",@a)}' -- - "$@" | \
  #sed -u "1i$ESH_AT $*" | \
  #nc -q -1 localhost $ESH_PORT | {
    #[ ${1:0:1} = z ] && gzip -d -c || cat
  #}
#}
#export -f _esh_b_TEST

# load a bash function into the session: first try using cached version,
# re-uploading if it is out of date (or non-existent). Args:
# 1: full pathname to cached file
# 2: optional: password (just be sure to pass a known valid password)
# 3: optional: if non-zero length, just echo the cached file; default is
# to eval it
_esh_l() {
  local f=$1 c p o
  export p=$([ "$2" ] && echo $2 || echo $(_esh_b fpw ${f/*.}))
  # https://cryptosense.com/weak-key-derivation-in-openssl/
  o="openssl enc -a -aes256 -pass env:p"
  # try to use the cached file first ...
  [ -f $f ] && 
    c="$($o -d -in $f 2>/dev/null)" &&
    # check for 16 byte header block injected by server: integrity check for
    # #16
    [[ "$c" =~ ^0000000000000000 ]] || {
    # cached file does not exist or is expired, or failed integrity check so
    # re-cache it
    echo -n "up:${f/*.} " >&2
    c="$(_esh_b zup ${f/*.})"
    echo ${#c} bytes >&2
    echo "$c" | $o >$f
    chmod 666 $f
  }
  # strip out 16 byte header block for integrity check
  c=${c:16}
  [ -z "$3" ] && eval "$c" || echo "$c"
}
export -f _esh_l

# ESH_AT is a simple security access token
export ESH_AT=$(openssl rand 3 -hex)
[ -z "$ESH_TMP" ] && ESH_TMP=/tmp/esh
export ESH_TMP
[ ! -d $ESH_TMP ] && mkdir $ESH_TMP && chmod 1777 $ESH_TMP

# shell init script here
eval '_esh_i() {
  local 't=$ESH_TMP u=$USER'
  [ ! -d $t ] && mkdir $t && chmod 1777 $t
  # only write out ESH_STY file if we are NOT in a sudo session
  [ -z "$SUDO_USER" ] && _esh_e "$@"
  ESH_NC="nc -q -1"
  # test if -q is supported with nc, due to 
  # https://bugs.launchpad.net/ubuntu/+source/netcat-openbsd/+bug/544935
  # we need it on newer ubuntu systems
  [ "$(nc -q -1 -z localhost 1 2>&1)" ] && ESH_NC="nc"
  # p0, p1, p2 are set by fpw call
  local $(_esh_b fpw cbf)
  _esh_l $t/$u.core $p0
  _esh_l $t/$u.bashrc $p1
  for f in $(_esh_l $t/$u.fcnlist $p2 1); do
    _esh_gen_stub $t/$u.f.$f
  done
  export ESH_AT ESH_TMP ESH_STY ESH_NC
  export -f _esh_e _esh_i _esh_b _esh_l
  # if initializng a new ssh session, set up job to delete the ESH_STY file
  # when the shell exits
  [ "$SSH_CLIENT" ] && nohup sh -c "while kill -0 $$; do sleep 5; done; f=$(_esh_e -f); rm -f \$f" </dev/null >/dev/null 2>&1 &
}'
export _esh_i

export ESH_HOME=$(dirname $([ -h $0 ] && readlink $0 || echo $0))
ESH_CORE=$ESH_HOME/core
[ "$1" ] && ESH_PROFILE="$1" || ESH_PROFILE=$ESH_HOME/profile.lwprof
ESH_PORT=$(node $ESH_HOME/GetFreePort.js)
[ -z "$ESH_PORT" ] && {
  echo "ERROR: could not get free port."
  exit 1
}

export ESH_LOGFILE=$ESH_TMP/$USER.esh.log.$ESH_PORT
touch $ESH_LOGFILE
chmod 600 $ESH_LOGFILE
ESH_PORT=$ESH_PORT node $ESH_HOME/EscreenRunServer.js $ESH_PROFILE $ESH_PORT >$ESH_LOGFILE 2>&1 </dev/null &
export ESH_NODE_PID=$!

while ! nc -z localhost $ESH_PORT; do
  sleep 0.1
done

# ESH_STY is loosely tied to screen's STY variable ... it gets used as a unique
# ID to properly track the communications port (ESH_PORT) to use in a given
# shell between various combinations of screen, sudo, and ssh
ESH_STY=0000
_esh_i $ESH_STY ESH_PORT $ESH_PORT
ESH_SCREEN_EXEC=1

  #nohup sh -c "while kill -0 ${STY%%.*}; do sleep 5; done; kill '$ESH_NODE_PID'; sleep 3600; rm -f '$ESH_LOGFILE';" </dev/null >/dev/null 2>&1 &

c='env screen -S $STY -X monitor off;'
c+='env screen -S $STY -X screen;'
c+='nohup sh -c "while kill -0 ${STY%%.*}; do sleep 5; done; kill $ESH_NODE_PID; sleep 6; rm -f $ESH_LOGFILE" </dev/null >/dev/null 2>&1 &'
c+='tail -f $ESH_LOGFILE'
screen -- sh -c "$c"
